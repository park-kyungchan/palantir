import json
import os
from typing import Dict, Any, List

SCHEMA_DIR = ".agent/schemas"
OUTPUT_FILE = "scripts/ontology.py"

TYPE_MAPPING = {
    "string": "str",
    "integer": "int",
    "boolean": "bool",
    "array": "List",
    "object": "Dict[str, Any]"  # Fallback
}

from enum import Enum

def parse_property(prop_name: str, prop_def: Dict[str, Any], classes: List[str]) -> str:
    prop_type = prop_def.get("type")
    enum_values = prop_def.get("enum")
    
    if enum_values:
        # Create Enum Class
        enum_name = prop_name.capitalize() + "Enum"
        generate_enum(enum_name, enum_values, classes)
        return enum_name
    
    if prop_type == "array":
        items = prop_def.get("items", {})
        item_type = items.get("type")
        if item_type == "object":
            # Nested object in array -> Create a new class
            class_name = prop_name.capitalize().rstrip('s') # jobs -> Job
            generate_class(class_name, items, classes)
            return f"List[{class_name}]"
        else:
            py_type = TYPE_MAPPING.get(item_type, "Any")
            return f"List[{py_type}]"
            
    elif prop_type == "object":
        class_name = prop_name.capitalize()
        generate_class(class_name, prop_def, classes)
        return class_name
        
    else:
        return TYPE_MAPPING.get(prop_type, "Any")

def generate_enum(enum_name: str, values: List[str], classes: List[str]):
    lines = [f"class {enum_name}(str, Enum):"]
    for v in values:
        # Handle special chars if needed, but assuming simple strings for now
        safe_name = v.upper().replace(" ", "_").replace("-", "_")
        lines.append(f"    {safe_name} = '{v}'")
    lines.append("")
    classes.append("\n".join(lines))

def generate_class(class_name: str, schema: Dict[str, Any], classes: List[str]):
    properties = schema.get("properties", {})
    required = schema.get("required", [])
    
    lines = [f"class {class_name}(BaseModel):"]
    if not properties:
        lines.append("    pass")
    
    for prop_name, prop_def in properties.items():
        py_type = parse_property(prop_name, prop_def, classes)
        is_optional = prop_name not in required
        
        if is_optional:
            lines.append(f"    {prop_name}: Optional[{py_type}] = None")
        else:
            lines.append(f"    {prop_name}: {py_type}")
    
    lines.append("")
    classes.append("\n".join(lines))

def main():
    print("âš™ï¸  Generating Pydantic Models from Schemas...")
    
    schema_dirs = [
        ".agent/schemas",
        "uclp/ontology/schemas"
    ]
    
    classes = []
    
    for d in schema_dirs:
        if not os.path.exists(d):
            continue
            
        for filename in os.listdir(d):
            if filename.endswith(".schema.json"):
                filepath = os.path.join(d, filename)
                print(f"   Reading {filepath}...")
                with open(filepath, 'r') as f:
                    schema = json.load(f)
                    
                # Infer class name from title or filename
                # plan.schema.json -> Plan
                # concept.schema.json -> Concept
                class_name = filename.replace(".schema.json", "").capitalize()
                generate_class(class_name, schema, classes)
    
    # Write to file
    content = [
        "# ðŸ¤– AUTO-GENERATED BY scripts/codegen.py",
        "# DO NOT EDIT MANUALLY",
        "",
        "from typing import List, Optional, Dict, Any",
        "from enum import Enum",
        "from pydantic import BaseModel",
        "",
    ]
    
    # Keep bottom-up order (Job before Plan)
    # Note: Since we process multiple files, the order depends on file system.
    # Ideally we should topological sort, but for now we rely on Python's lazy resolution or just append.
    # Pydantic handles string forward refs if needed, but let's just dump them.
    content.extend(classes)
    
    with open(OUTPUT_FILE, 'w') as f:
        f.write("\n".join(content))
        
    print(f"âœ… Generated {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
