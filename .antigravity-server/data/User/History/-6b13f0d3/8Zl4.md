# ODA 3-Stage Protocol Framework

**Version:** 1.0
**Date:** 2026-01-05
**Status:** ARCHITECTURAL_BLUEPRINT
**Protocol Enforcement:** SCRIPT-LEVEL (Enforced by GovernanceEngine)

---

## 1. Overview

The **3-Stage Protocol Framework** is a mandatory operational framework in Orion ODA that ensures every action, plan, and audit follows a rigorous deep-dive methodology. Unlike guideline-based protocols, this framework is embedded at the script-level to programmatically mandate compliance and evidence gathering.

### Core Objectives
1. **Anti-Hallucination**: Force the agent to provide proof of codebase analysis via mandatory evidence logs.
2. **Integration Safety**: Trace data flows and side effects before performing mutations.
3. **Universal Consistency**: Apply the same rigor to Auditing, Planning, Task Distribution, and Execution.

---

## 2. Framework Architecture

### 2.1 Core Components (`scripts/ontology/protocols/base.py`)

#### `Stage` Enum
- `A_SCAN`: Surface scan/blueprint scan (Landscape view).
- `B_TRACE`: Logic trace/Integration trace (Call stack/Data flow).
- `C_VERIFY`: Quality audit/Quality gate (Atomic verification).

#### `StageResult`
Each stage must return a result containing:
- `passed`: Boolean status.
- `findings`: List of observations.
- `evidence`: **Mandatory** evidence map (files viewed, line numbers, quoted snippets).

#### `ThreeStageProtocol` (Base Class)
Abstract base class defining the sequence:
1. `execute_stage_a()`
2. `execute_stage_b()` (Building on A)
3. `execute_stage_c()` (Final verification)

---

## 3. Protocol Implementations

| Protocol | Stage A (SCAN) | Stage B (TRACE) | Stage C (VERIFY) |
|----------|----------------|-----------------|------------------|
| **AuditProtocol** | File structure & patterns | Call stack & data flow | Line-by-line quality |
| **PlanningProtocol**| Domain requirements | Integration dependencies | Design & Safety gate |
| **ExecutionProtocol**| Pre-state & Pre-flight | Action execution | Post-state validation |
| **Orchestration** | Task decomposition | Dependency mapping | Synthesis & Consolidation |

---

## 4. Enforcement Layer

### 4.1 `@require_protocol` Decorator
Actions can be decorated to mandate a specific protocol pass before execution.
```python
@require_protocol(AuditProtocol, policy=ProtocolPolicy.BLOCK)
class DeepAuditAction(ActionType):
    ...
```

### 4.2 GovernanceEngine Integration
The `GovernanceEngine` checks for a valid, passed protocol session associated with the current `ActionContext`.
- **BLOCK**: Execution is denied if protocol has not passed.
- **WARN**: Execution proceeds but logs a compliance violation.

### 4.3 Evidence-Based Validation
The framework verifies that `StageResult.evidence` is populated with actual file paths and references tracked by the system, making it impossible to "skip" analysis without leaving a trace.

---

## 5. Metadata Schema (Evidence Tracking)

Protocols log evidence in the following format to ensure auditability:
```json
{
  "files_viewed": ["scripts/ontology/actions/__init__.py"],
  "lines_referenced": {
    "scripts/ontology/actions/__init__.py": [242, 315]
  },
  "verification_checks": ["pydantic_validation", "null_check"]
}
```

---

## 6. Implementation Roadmap (Jan 2026)

1. **Phase 1**: Implement `base.py` and `StageResult` structures.
2. **Phase 2**: Integrate `ProtocolEnforcer` into `GovernanceEngine`.
3. **Phase 3**: Migrate existing `/deep-audit` workflow to the enforced `AuditProtocol`.
4. **Phase 4**: Enable `PlanningProtocol` for all `Proposals`.
