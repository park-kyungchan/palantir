#!/bin/bash
# =============================================================================
# Layer2 Output Handler - PostToolUse Hook
# =============================================================================
# Automatically saves full subagent output to .agent/outputs/ with timestamp.
# Part of the Layer1/Layer2 Output Architecture.
#
# Trigger: PostToolUse for Task tool
# Output: {timestamp}_{description}.md
# =============================================================================

set -euo pipefail

# Configuration
OUTPUT_DIR="/home/palantir/.agent/outputs"
MAX_DESC_LENGTH=50

# Ensure output directory exists
mkdir -p "$OUTPUT_DIR"

# Parse input from stdin
INPUT=$(cat)

# Extract tool name
TOOL_NAME=$(echo "$INPUT" | python3 -c "
import sys, json
try:
    d = json.load(sys.stdin)
    print(d.get('tool_name', ''))
except:
    print('')
" 2>/dev/null || echo "")

# Only process Task tool
if [ "$TOOL_NAME" != "Task" ]; then
    echo '{"continue": true}'
    exit 0
fi

# Extract task details using python3
PARSED=$(echo "$INPUT" | python3 -c "
import sys, json, re

try:
    d = json.load(sys.stdin)
    tool_input = d.get('tool_input', {})
    tool_result = d.get('tool_result', '')

    # Get agent_id
    agent_id = tool_input.get('agent_id', d.get('agent_id', 'unknown'))

    # Get description and sanitize
    description = tool_input.get('description', 'task')
    description = re.sub(r'[^a-zA-Z0-9]', '_', description.lower())
    description = re.sub(r'_+', '_', description)[:50]
    description = description.strip('_') or 'task'

    # Get result
    if isinstance(tool_result, dict):
        result = json.dumps(tool_result, indent=2, ensure_ascii=False)
    else:
        result = str(tool_result) if tool_result else '[No output]'

    # Get transcript path
    transcript = d.get('agent_transcript_path', 'N/A')

    print(f'{agent_id}|||{description}|||{transcript}')
except Exception as e:
    print(f'unknown|||task|||N/A')
" 2>/dev/null || echo "unknown|||task|||N/A")

# Parse the output
IFS='|||' read -r AGENT_ID DESCRIPTION TRANSCRIPT_PATH <<< "$PARSED"

# Generate timestamp
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Generate filename
FILENAME="${TIMESTAMP}_${DESCRIPTION}.md"
OUTPUT_PATH="${OUTPUT_DIR}/${FILENAME}"

# Extract tool result separately (can be large)
TOOL_RESULT=$(echo "$INPUT" | python3 -c "
import sys, json
try:
    d = json.load(sys.stdin)
    r = d.get('tool_result', '')
    if isinstance(r, dict):
        print(json.dumps(r, indent=2, ensure_ascii=False))
    else:
        print(str(r) if r else '[No output captured]')
except:
    print('[Parse error]')
" 2>/dev/null || echo "[Parse error]")

# Write Layer2 output file
cat > "$OUTPUT_PATH" << LAYER2_EOF
# Layer2 Full Output: ${DESCRIPTION}

## Metadata
| Field | Value |
|-------|-------|
| Agent ID | ${AGENT_ID} |
| Timestamp | $(date -u +"%Y-%m-%dT%H:%M:%SZ") |
| Description | ${DESCRIPTION} |
| Transcript | ${TRANSCRIPT_PATH} |
| Output File | ${OUTPUT_PATH} |

## Full Output

${TOOL_RESULT}

## Recovery Options

### Resume Agent
\`\`\`python
Task(resume="${AGENT_ID}", prompt="Continue previous work")
\`\`\`

### Read Transcript
\`\`\`bash
cat "${TRANSCRIPT_PATH}"
\`\`\`

---
*Generated by Layer2 Output Handler v1.0.0*
LAYER2_EOF

# Log success
echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] Layer2 saved: ${FILENAME} | Agent: ${AGENT_ID}" >> "${OUTPUT_DIR}/index.log"

# Output for hook system
echo "{\"continue\": true, \"systemMessage\": \"Layer2 output saved: ${FILENAME}\"}"

exit 0
