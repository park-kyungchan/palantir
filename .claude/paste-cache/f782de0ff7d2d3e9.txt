Claude Code v2.1.6 기반 Thread 중심 에이전트 인프라 구현 기술서
개요: 멀티 스레드 에이전트 환경의 설계
Anthropic의 Claude Code는 터미널 기반의 AI 코딩 에이전트로, 개발 워크플로우의 다양한 부분을 자동화합니다[1]. 이 문서에서는 Claude Code v2.1.6의 최신 기능들을 활용하여 스레드(병렬 세션) 기반의 에이전트 인프라를 구현하는 방법을 상세히 설명합니다. Boris Cherny (Claude Code의 창시자)의 실제 사용 사례를 토대로, 병렬 인스턴스 운영, Plan 모드와 Auto-accept 모드 전환, Slash Command 및 Hook 기반 자동화, 설정 디렉토리 구조, 검증 루프 설계 등을 모두 아우르는 구현 지침을 제시합니다. 모든 구성 요소를 .claude 설정 디렉토리에 통합하여, 바로 실무에 적용 가능한 형태의 기술 문서를 제공합니다.
특히 Claude Code v2.1.6에서 새로 도입된 기능들 – 예를 들어 컨텍스트 창 사용률 표시, 중첩 폴더의 skills 자동탐색, /stats 통계 개선, /doctor의 업데이트 채널 토글 및 권한 규칙 진단, 백그라운드 작업 메트릭, OpenTelemetry 통합 등 – 을 모두 반영하여 인프라를 구축합니다. Sub-agent(하위 에이전트) 오케스트레이션은 Claude 자체 기능에 맡기며 별도 구현을 생략합니다. 대신 Slash Command, MCP, Hook (Pre/Post/Stop), Plan 모드, 백그라운드 작업 제어, .claude 디렉토리 구조, Telemetry 태깅, 권한 정책 등 모든 설정 지점을 구조적이고 실용적으로 활용하는 방법에 집중합니다.
이 문서는 Markdown 양식으로 작성되어 Claude Code 환경에 그대로 복사-붙여넣기하여 참고할 수 있습니다. 각 섹션마다 설정 파일 예시(.claude/settings.json, .claude/commands/..., .claude/skills/..., hooks/..., mprocs.yaml 등)를 포함하며, 팀 단위 협업과 재사용을 고려한 포괄적인 레퍼런스를 제시합니다.
1. 병렬 Claude 인스턴스 운영 – 멀티 스레드 설정
Boris Cherny는 생산성을 극대화하기 위해 여러 Claude Code 세션을 병렬로 실행합니다[2]. 예를 들어, 로컬 터미널에서 5개의 Claude 프로세스를 동시에 구동하고, 필요에 따라 Claude 웹 인터페이스(claude.ai/code) 상에서도 5~10개의 추가 세션을 병렬로 활용합니다[2]. 이렇게 다수의 스레드(세션)를 병렬 운영함으로써 한 세션에 과부하를 주지 않고 여러 작업을 동시 처리하여 개발 속도를 높입니다[3][4].
1.1 병렬 세션용 Git 작업공간 분리
여러 Claude 세션이 동일한 코드베이스에서 작업할 경우 파일 충돌을 방지하는 것이 중요합니다. Boris는 각 로컬 Claude 세션마다 서로 다른 git 클론을 사용하여 작업 영역을 완전히 분리합니다[2]. 이렇게 하면 한 세션이 코드 변경을 진행해도 다른 세션과 충돌하지 않으며, 브랜치 분기나 git worktree를 쓰지 않고도 안전하게 병렬 개발이 가능합니다[2]. 예를 들어 5개의 세션을 위해 동일한 레포지토리를 5번 별도 경로에 클론해 두고, 각 터미널 탭에서 해당 경로로 이동하여 claude를 실행합니다.
# 예: 5개의 별도 디렉토리에 클론 (repo1 ~ repo5)
git clone https://github.com/myorg/myrepo.git ~/workspace/repo1
git clone https://github.com/myorg/myrepo.git ~/workspace/repo2
... (생략) ...
git clone https://github.com/myorg/myrepo.git ~/workspace/repo5

# 각 터미널에서 해당 디렉토리로 이동 후 Claude Code 실행
cd ~/workspace/repo1 && claude
이렇게 5개의 Claude 인스턴스를 병렬 실행하면, 각 Claude가 자기만의 git 작업공간에서 독립적으로 코드를 생성하고 수정하게 됩니다. 동일 레포지토리이지만 작업공간이 격리되어 있어 충돌 없이 여러 기능을 병렬 개발할 수 있습니다.
Tip: Anthropic 공식 문서에 따르면 병렬화는 Claude Code의 강력한 장점으로, 여러 단순 세션을 활용하는 것이 하나의 복잡한 세션에 모든 작업을 몰아넣는 것보다 효과적이라고 합니다[4][5]. 팀 공동작업 시에도 각 개발자 혹은 각 작업 기능별로 세션을 나누어 병렬 처리하면 효율이 극대화됩니다.
1.2 mprocs를 활용한 다중 세션 관리 (예시)
병렬 프로세스를 수동으로 여는 대신, 터미널 멀티프로세스 도구인 mprocs를 사용하면 여러 Claude 세션을 한 번에 실행하고 모니터링할 수 있습니다. 아래는 mprocs.yaml 설정 예시로, 5개의 Claude 세션을 동시에 실행합니다:
# mprocs.yaml - 여러 Claude Code 인스턴스를 병렬 실행
procs:
  claude1:
    shell: "cd ~/workspace/repo1 && claude"
  claude2:
    shell: "cd ~/workspace/repo2 && claude"
  claude3:
    shell: "cd ~/workspace/repo3 && claude"
  claude4:
    shell: "cd ~/workspace/repo4 && claude"
  claude5:
    shell: "cd ~/workspace/repo5 && claude"
위 설정을 저장한 후 현재 디렉토리에서 mprocs 명령을 실행하면 5개의 패널에 각 claude 프로세스가 실행됩니다. mprocs는 각 프로세스의 출력을 별도 창으로 분리하여 표시하고, 하나의 터미널에서 손쉽게 여러 Claude 세션을 전환하며 조작할 수 있게 해줍니다[6][7].
Boris는 macOS의 iTerm2 터미널의 탭 알림 기능을 활용하여, Claude 세션들 중 사용자 입력이 필요한 시점에 시스템 알림으로 알려주기도 합니다[8]. 이처럼 각 세션에 번호를 매기고(예: Tab 1~5) 알림을 설정해두면, 병렬로 실행되는 여러 Claude 중 어느 세션이 현재 대기 상태인지 쉽게 파악할 수 있습니다.
1.3 로컬 ↔ 원격 세션 전환
Claude Code v2.1.6에서는 로컬 세션에서 웹 세션으로 작업을 “텔레포트”하는 기능도 제공합니다. 터미널 Claude 대화에서 명령 앞에 & 기호를 붙이면 해당 프롬프트를 클라우드 세션으로 보내 원격 실행할 수 있습니다[9][10]. 예를 들어:
& Fix the authentication bug in src/auth/login.ts
위와 같이 입력하면 현재까지의 대화 컨텍스트를 포함한 새로운 웹 세션이 생성되고, 해당 작업을 웹(cluade.ai/code)의 안전한 클라우드 환경에서 수행합니다[11]. 로컬 터미널에서는 즉시 다음 작업을 이어갈 수 있고, 백그라운드로 원격 작업이 진행됩니다. 진행 상황은 /tasks 명령으로 확인하거나, claude.ai 웹 UI나 모바일 앱에서 해당 세션을 직접 열어 모니터링할 수 있습니다[10].
반대로, 웹에서 실행되던 세션을 로컬로 가져올 수도 있습니다. /teleport 명령을 사용하면 지정한 원격 세션ID의 컨텍스트를 통째로 로컬 Claude 세션으로 불러와 이어서 작업할 수 있습니다[12][13]. 다만 현재는 세션 전송은 단방향(웹→로컬)만 지원되며, 이미 진행 중인 로컬 세션을 웹으로 내보내는 기능은 제공되지 않습니다[14]. 따라서 웹 세션으로 작업을 던지고 싶을 때는 처음부터 &로 시작하여 새 세션을 만들고 실행하는 방식을 사용합니다.
참고: Boris는 실무에서 로컬 Claude 세션에서 작업하다가 시간이 오래 걸리거나 리소스가 많이 필요한 작업은 &로 원격에 위임하고, 나중에 /teleport로 결과를 가져오는 패턴을 활용합니다[15]. 또한 매일 아침 Claude 모바일 앱(iOS)을 통해 몇 개의 세션을 시작해두고, 하루 동안 틈틈이 진행 상황을 확인한다고 합니다[16]. 이러한 유연한 멀티세션 전략으로 언제 어디서든 병렬 작업을 유지합니다.
2. Plan 모드와 Auto-Accept 모드 – 계획 수립과 실행
Plan 모드는 Claude Code의 계획 수립 기능으로, AI가 코딩 작업을 시작하기 전에 단계별 플랜(Plan)을 제시하도록 합니다. 복잡한 기능 구현이나 다중 파일 변경이 예상될 때 Plan 모드를 사용하면, Claude가 전체 작업 계획을 세우고 사용자의 확인을 거친 후 실행을 진행합니다[17]. Boris Cherny를 비롯한 숙련 사용자들은 “거의 모든 비트리ivial 작업은 Plan 모드로 시작”할 만큼 이 기능을 핵심으로 활용합니다[17][18].
2.1 Plan 모드 진입 및 활용
Plan 모드는 Shift + Tab 키를 두 번 눌러 활성화할 수 있습니다[19]. 현재 대화 프롬프트가 Plan 모드로 전환되면 Claude는 곧바로 코드를 작성하지 않고, 대신 “이러이러한 순서로 작업을 진행하겠다”는 작업 계획서를 작성합니다. 예를 들어 Pull Request를 생성하는 것이 목표라면, Claude는 해당 PR을 구현하기 위한 단계(예: 1. 기능 A 수정, 2. 테스트 추가, 3. 문서 업데이트 등)를 나열합니다.
사용자는 Plan 내용을 검토하여 누락된 부분이나 잘못된 접근이 없는지 확인하고, 필요하면 Claude와 몇 차례 계획을 수정/보완하는 대화를 주고받습니다[20]. Boris는 “좋은 계획이 정말 중요하다 (A good plan is really important!)”고 강조하며, 충분히 만족스러운 계획이 나올 때까지 Claude와 Plan 단계에서 여러 번 상호작용한다고 합니다[21].
Plan 모드의 이점은 사전에 경로를 정함으로써 시행착오를 줄인다는 것입니다. 계획 없이 곧바로 코딩에 들어가면 잘못된 방향으로 구현하여 나중에 고치는 데 시간이 들 수 있지만, Plan을 통해 “measure twice, cut once”를 실천하면 전체 작업 시간이 단축됩니다[22]. 실제로 Boris를 비롯해 일관되게 성과를 내는 개발자들은 Plan 단계를 건너뛰지 않고, 계획 부실로 인한 실수를 미연에 방지한다고 합니다[22].
변경점: v1.0 시절에 도입된 Plan 모드는 Claude Code 2.x에서 더욱 정교해졌습니다. 현재 Plan 모드로 생성한 플랜은 ~/.claude/plans/ 경로에 문서로 저장되며, 사용자 확인 후 Spec Driven Development 스타일로 활용될 수 있습니다[23][24]. 이는 각 계획을 나중에 참조하거나 팀과 공유하기 쉽게 합니다.
2.2 Auto-Accept(자동 승인) 모드 전환
만족스러운 계획이 수립되었다면, 다음 단계는 계획을 실행하는 것입니다. 기본적으로 Claude Code는 코드 수정/생성 같은 Write/Edit 액션 전마다 사용자에게 확인을 요청합니다. 하지만 Auto-accept edits 모드를 켜면 파일 수정 단계들을 일일이 승인할 필요 없이 Claude가 알아서 순차적으로 수행합니다[20][25]. Boris는 Plan 모드에서 계획 확정 후 자동 편집 승인 모드로 전환함으로써, Claude가 계획된 작업을 한 번에 실행(one-shot)하도록 합니다[20].
Auto-accept 모드로 전환하는 방법:
•    단축키 사용: 기본 설정에서 Shift + Tab 한 번 누르면 Auto-accept(편집 자동승인) 모드를 토글할 수 있습니다[26]. Windows 환경에서는 Alt + M 키 조합이 사용되며, WSL이 아닐 경우에도 이 키로 토글 가능합니다[27][28].
•    CLI 인자 사용: claude --permission-mode=acceptEdits 옵션을 주어 Claude를 실행하면 처음부터 파일편집 자동승인 모드로 시작할 수도 있습니다[29]. 이 플래그는 Plan 모드가 끝난 후 수동으로 키지 않아도 곧바로 코드를 적용할 수 있게 해줍니다.
Auto-accept 모드에서는 파일 쓰기/편집 단계가 사용자 확인 없이 곧바로 이행됩니다. 단, Bash 명령 실행 등은 여전히 권한 확인 대상인데(이는 permission 모드 설정에 따름), “편집(auto-accept) 모드”라는 이름이示示하듯 코드 변경에 대한 승인만 생략되는 것입니다[30]. 따라서 Claude가 Plan에 따라 여러 파일을 수정/생성하는 경우, Auto-accept를 켜두면 끊김 없이 일괄적으로 모든 변경이 적용됩니다[31]. Boris의 경험에 따르면 Opus 4.5 모델은 탄탄한 플랜만 주어지면 한 번에 결과물을 완성하는 경향이 있기 때문에, Plan → Auto-accept 연계 사용으로 대부분 작업을 원큐에 끝낼 수 있다고 합니다[19].
팁: Auto-accept edits 모드는 편리하지만, 코드 변경을 자동 승인하는 것이므로 신뢰할 수 있는 환경에서 사용해야 합니다. 만약 Claude가 오판하여 잘못된 파일을 대량 수정하는 상황을 방지하려면, Plan 단계에서 충분히 검토하거나 Auto-accept를 켜기 전에 중요한 파일들에 보호 Hook(후술)을 걸어두는 방법도 있습니다.
2.3 Plan 모드와 권한 모델의 관계
Plan 모드에서는 Claude가 실제 코드를 실행하거나 변경하지 않으므로, 내부적으로 모든 Write/Edit 툴 사용을 금지하는 특별 권한 모드로 볼 수 있습니다. Plan 단계에서는 Claude에게 분석 및 계획 수립만 허용되고, 실행은 차단되는 셈입니다. 이는 Plan 모드가 끝나면 사용자가 다시 일반 모드나 auto-accept 모드로 전환하여 실제 작업을 승인하기 전까지 Claude가 함부로 코드를 변환하지 않도록 하는 안전장치입니다. Claude Code 2.x의 권한 체계에서 Plan 모드는 별도 permission mode로 구현되어 있을 가능성이 높습니다[32][33].
실제로 GitHub 이슈에서 Plan 전용 권한 모드를 요청하는 논의도 있었는데, “분석만 수행하고 코드 변경을 하지 않도록 하는 planning permission mode”에 대한 것이었습니다[34]. 현재 Claude Code에서는 Plan 모드 진입 시 이러한 동작이 자동 적용됩니다. Plan 완료 후 auto-accept 모드로 전환하면 permission 모드도 acceptEdits로 바뀌어 파일 편집은 자동 허용되지만 Bash 등의 위험 작업은 여전히 별도 확인을 받는 식으로 동작합니다[30][35].
2.4 Plan-Auto 절차의 예시
종합하면, 권장 워크플로우는 다음과 같습니다:
1.    Plan 수립: Shift+Tab×2 → Claude가 계획 제안 → 사용자와 협의하여 수정.
2.    Auto-accept 실행: Shift+Tab (또는 /config에서 Editing Mode를 Auto로) → Claude가 계획 단계별로 코드 작성 & 편집을 일괄 수행.
3.    검토 및 마무리: 결과물 확인 → 필요시 /review로 코드리뷰 받거나 /test 명령 (커스텀)으로 테스트 실행 → 완료 시 PR 생성 (/commit-push-pr 등 커스텀 명령 활용, 다음 섹션 참고).
Boris Cherny는 이 흐름을 통해 “대부분의 Pull Request를 한 번에 완료”한다고 밝혔습니다[19]. 핵심은 충분한 Plan으로 방향을 잡고, Auto-accept로 시행착오 없이 실행하는 것입니다.
3. Slash Command와 Skills – 반복 작업의 모듈화
Claude Code의 Slash Command(/<name>)는 자주 쓰는 프롬프트나 작업 흐름을 별도의 명령어로 정의하여, 대화 중 언제든 호출할 수 있게 해주는 기능입니다[36][37]. Boris는 하루에도 수십 번씩 반복하는 “inner loop” 작업들을 모두 Slash Command로 만들어 사용합니다[38]. 예를 들어, PR 작성 루틴을 자동화한 /commit-push-pr 명령은 Boris의 터미널에서 하루 수십 차례 실행되며, 매번 일일이 git 명령과 설명을 입력하지 않아도 한 번에 커밋, 푸시, PR 생성까지 수행합니다[38].
한편, Skill은 본래 Claude에게 특정 분야의 지식을 가르치거나 행동 패턴을 추가하는 전문가 모듈 개념이었으나, v2.1부터 Slash Command와 통합되었습니다[39]. 이제 .claude/skills/ 디렉토리에 저장된 스킬들도 모두 Slash Command처럼 메뉴에 나타나며, 명령 형태로 호출되거나 자동으로 활용됩니다[40][39]. 요약하면 “Skills = Slash Commands”이며, 사람이나 모델 모두 동일한 방식으로 사용할 수 있게 단일 개념으로 단순화되었습니다[41].
이 섹션에서는 Slash Command (이제는 Skills 포함)의 구조와 작성 방법, 그리고 Boris의 예제를 통해 반복 작업의 자동화를 구현하는 방법을 살펴봅니다.
3.1 .claude/commands/ 디렉토리와 명령 정의
사용자 정의 Slash Command는 프로젝트 폴더 내 .claude/commands/ 디렉토리에 마크다운 파일로 정의합니다[42][43]. 파일명(확장자 .md 제외)이 곧 명령 이름이 되며, 내용은 해당 명령이 Claude에게 수행시킬 지시사항을 담습니다[44][45]. 예를 들어 optimize.md 파일을 만들고 아래와 같이 작성하면, Claude에게 코드 최적화를 요청하는 /optimize 명령이 생성됩니다:
# .claude/commands/optimize.md
Analyze this code for performance issues and suggest optimizations:
위처럼 내용만 한 줄 넣는 간단한 형식도 유효하며, /optimize를 입력하면 Claude가 해당 문장을 프롬프트로 받아들여 실행합니다[42][43]. 그러나 Claude Code의 Slash Command는 여기에 그치지 않고 보다 강력한 기능을 제공합니다:
•    인수 (Arguments): 명령에 매개변수를 전달할 수 있습니다. $ARGUMENTS로 전체 인수를, $1, $2처럼 번호로 개별 인수를 참조하여 명령 내용에 삽입할 수 있습니다[46][47]. 이를 통해 동적인 명령 생성이 가능합니다.
•    파일 참조: @filename 문법으로 현재 프로젝트의 파일 내용을 참조하여 명령에 포함시킬 수 있습니다[48][49]. Claude는 해당 파일의 내용을 읽어와 컨텍스트로 활용합니다.
•    Frontmatter 메타데이터: 명령 파일 맨 앞을 ---로 구분된 YAML 메타데이터 블록(Frontmatter)로 작성하여 추가 설정을 지정할 수 있습니다[50][51]. 예를 들어 description, allowed-tools, context: fork, model 등을 설정합니다.
명령 예시: /commit-push-pr
Boris가 실제 사용하는 /commit-push-pr 명령을 참고해보겠습니다. 이 명령은 현재 git 상태를 파악하고 적절한 커밋 메시지를 생성하여 푸시하고 PR까지 만드는 일련의 작업을 자동화한 것입니다. Boris는 이 명령을 하루에도 몇십 번씩 활용하여 작은 변경을 빠르게 커밋/PR 하는데, 관련 명령 파일 (.claude/commands/commit-push-pr.md)은 다음과 같이 구성할 수 있습니다:
---
allowed-tools: Bash(git add:*), Bash(git status:*), Bash(git commit:*), Bash(git push:*), Bash(gh pr create:*)
description: Commit changes with an AI-written message, push to remote, and open a PR
---

## Context

- Current branch: !`git branch --show-current`
- Git status output: !`git status -s`
- Diff of staged changes: !`git diff --cached`

## Task

1. Stage all pending changes (`git add -A`).
2. Generate a clear, descriptive commit message for the above changes.
3. Commit the changes with that message.
4. Push the commit to the remote branch.
5. Create a GitHub pull request (using `gh pr create` CLI) with the commit message as title.
설명: 위 명령 정의는 다음을 보여줍니다.
•    allowed-tools: 해당 명령이 실행 중 사용할 수 있는 툴(명령)의 허용 목록입니다. 여기서는 Git 관련 Bash 명령들을 whitelisting하여, Claude가 이 명령 수행 중에는 git add, git status, git commit, git push, gh pr create 등을 사용자 승인 없이 실행할 수 있도록 합니다[52][53]. (명령 파일의 allowed-tools는 이 명령 실행에 한해 적용되는 일종의 권한 예외입니다.)
•    description: 명령의 짧은 설명입니다. /help 명령으로 조회하거나 명령 자동완성 메뉴에 이 설명이 표시됩니다.
•    ## Context 섹션: 여기에는 ! 프리픽스를 사용한 Bash 명령들이 나열되어 있습니다. 느낌표(!)가 앞에 붙은 행은 명령 실행 전에 실제 Bash 명령을 실행하고, 그 출력을 명령 컨텍스트에 삽입합니다[54][55]. 예를 들어 !가 붙은 `git status -s`는 Claude에게 전달되기 전에 현재 git 상태 결과로 대체됩니다. Boris가 말한 “inline bash to pre-compute context”란 바로 이 기능으로, 모델이 필요한 정보를 얻기 위해 여러 번 Tool을 호출하지 않도록 미리 필요한 데이터를 넣어주는 것입니다[38][56].
•    ## Task 섹션: Claude에게 실제로 시킬 작업 내용을 단계적으로 서술합니다. 일반적인 자연어 지시이며, Plan 없이 곧장 실행되지만 복잡한 시퀀스를 포함할 수 있습니다. 예시에서는 1) 변경 스테이징, 2) 커밋 메시지 생성, 3) 커밋 실행, 4) 푸시, 5) PR 생성의 다섯 단계를 요구하고 있습니다.
이 명령을 정의해두면, Claude Code 세션에서 /commit-push-pr만 입력하면 위에서 정의한 Context 수집을 자동으로 수행한 뒤, Claude가 해당 Task를 알아서 실행합니다. git 상태를 읽고 커밋 메시지를 만들고, Bash 명령들을 순차 호출하여 커밋/푸시/PR까지 진행할 것입니다. 사람은 명령 하나로 복잡한 반복 작업을 끝낼 수 있게 되는 것입니다. Boris는 이 커맨드를 매일 수십 회 사용하며 반복 프롬프트의 수고를 덜고 있다고 합니다[38].
주의: allowed-tools로 허용한 범위 외의 명령을 Claude가 실행하려 하면 평소처럼 권한 확인을 거칩니다. 따라서 명령 설계 시 필요 명령을 모두 whitelisting하는 것이 중요합니다. 또한 ! Bash 실행 결과가 너무 방대하면 컨텍스트 창을 크게 차지할 수 있으므로, 필요한 정보만 간결히 가져오는 것이 좋습니다 (예: git diff --stat로 변경 요약만 가져오는 등).
Skills 디렉토리와 네임스페이스
.claude/skills/ 디렉토리도 .claude/commands/와 동일한 방식으로 명령 파일(md)을 포함할 수 있습니다. v2.1.0 이후로는 skills 디렉토리에 있는 파일들도 별도 추가작업 없이 Slash Command로 자동 등록됩니다[40][39]. Skills는 논리적으로 특정 분야나 컴포넌트에 국한된 명령 세트로서 하위 폴더 구조로 관리하기 유용합니다. Claude Code는 명령 네임스페이스로 폴더명을 활용하는데, 예를 들어 .claude/commands/frontend/build.md와 .claude/commands/backend/build.md 두 파일이 있다면 모두 /build라는 명령으로 호출되지만 설명에 (project:frontend), (project:backend)처럼 구분되어 표시됩니다[57][58].
v2.1.6에서는 중첩된 skills 폴더 자동탐색 기능이 추가되었습니다. 이는 하위 디렉토리별로 .claude/skills/를 둘 경우, Claude가 해당 경로에서 작업할 때 그 폴더의 skills도 자동 로드된다는 의미입니다[59]. 예를 들어 src/components/Login/.claude/skills/에 로그인 기능 관련 특화 명령들을 넣어두면, Claude가 src/components/Login 경로 내 파일을 주로 다루는 세션에서는 해당 명령들을 우선적으로 활용할 수 있습니다. 이를 통해 모노레포나 대규모 프로젝트에서 컴포넌트별 특화 자동화 루틴을 구성할 수 있습니다.
3.2 서브에이전트 (Sub-agent)와 중첩 실행
Boris의 설정에서 Slash Command는 사람이 직접 호출할 뿐만 아니라, Claude 스스로 부속 작업이 필요할 때 호출하기도 합니다[41]. Claude Code는 메인 대화 외에 Sub-agent라는 독립적인 하위 에이전트를 실행할 수 있는데, Slash Command를 sub-agent 형태로 실행하면 부모 대화의 컨텍스트를 오염시키지 않고 병렬 작업을 처리하게 할 수 있습니다[60][61].
•    명령 파일 Frontmatter에 context: fork를 지정하면 해당 명령은 별도 대화 컨텍스트(서브에이전트)에서 실행됩니다[62]. agent: <type> 필드로 어떤 타입의 내장 에이전트를 쓸지도 선택 가능하며, 기본은 general-purpose입니다[63][51].
•    Claude 메인은 이 sub-agent에게 작업을 위임하고, 완료되면 결과만 받아봅니다[64]. 예컨대 /verify-app 같은 명령을 context: fork로 정의하면, 메인 Claude가 전체 테스트 시나리오를 별도의 sub-agent에게 맡겨 실행하게 할 수 있습니다.
Boris는 실제로 코드 단순화(code-simplifier), 애플리케이션 검증(verify-app) 등의 서브에이전트를 정기적으로 사용합니다[65]. 이러한 서브에이전트들은 해당 작업에 맞춘 시스템 프롬프트와 권한으로 동작하며, 메인 작업 흐름과 병렬 또는 비동기로 실행될 수 있어 효율적입니다[66][60]. 다행히 Claude Code에서는 이러한 sub-agent 오케스트레이션을 내부적으로 관리해주므로, 사용자는 단지 필요한 slash command/skill을 정의해두고 필요 시 Claude가 이를 호출하도록 유도하면 됩니다[67].
예를 들어, Plan 단계에서 “이후 전체 앱을 검증한다”는 스텝을 넣으면 Claude가 해당 단계에서 자동으로 /verify-app 명령(서브에이전트 실행)을 호출하여 정해진 테스트 시나리오를 수행하도록 할 수 있습니다. 이때 메인 컨텍스트는 테스트 로그 등으로 더럽혀지지 않고 결과만 요약되어 돌아오므로, 맥락 관리 측면에서 sub-agent는 중요한 도구입니다[68][69].
Note: Sub-agent와 Slash Command의 관계는 Claude Code의 MCP (Model Context Protocol)과도 연계됩니다. 외부 도구에 질의를 보내는 MCP 커넥터도 Slash Command 형태로 노출되는데, /mcp__서버명__명령 형태로 호출됩니다[70][71]. 이러한 MCP 명령들도 필요에 따라 sub-agent로 실행되어 메인 대화를 방해하지 않고 결과를 가져오곤 합니다. (MCP는 다음 장에서 자세히 다룹니다.)
3.3 명령 및 스킬 예시 모음
아래는 실무에서 유용한 몇 가지 Slash Command 예시와 그 구현을 간략히 나열합니다:
•    /review (코드 리뷰 요청): 현재 변경 내용을 요약 정리하고, 코드 스타일/버그 가능성을 피드백하도록 지시. (CLAUDE.md의 팀 코드 스타일 가이드와 연계)
•    /test-all (전체 테스트 실행): allowed-tools에 Bash(npm run test) 등을 허용하고 !로 이전 테스트 결과 캐시 제거, 테스트 실행. 실패하면 로그를 요약해서 표시.
•    /deploy-check (배포 점검): 특정 환경 변수나 설정 파일들을 점검하는 스크립트를 호출하여 문제가 없으면 OK 메시지, 문제 있으면 상세 경고 출력[72].
•    /security-review (보안 리뷰): (개인 명령 예시) 코드베이스에서 보안 취약점 패턴 찾기 – .claude/commands/security-review.md에 "Review this code for security vulnerabilities:" 같은 내용 작성[73][74].
이처럼 반복되는 작업, 체크리스트, 스크립트화 가능한 루틴은 모두 Slash Command로 승격시켜두면, Claude가 스스로 필요한 일을 처리하거나 사용자가 간편히 명령을 내려 효율을 높일 수 있습니다. Boris는 이러한 철학을 “여러분이 하루에도 몇 번씩 반복하는 일이라면, 그것을 코드(명령)로 만들어라”고 요약합니다[65][75]. Claude Code에서는 그것이 Slash Command/Skills이고, 이는 곧 개발자의 내재화된 습관을 AI에게 학습시켜 공유하는 과정이라 할 수 있습니다.
4. Hook 기반 자동화 – 도구 이벤트에 대한 맞춤 액션
Hook는 Claude Code가 특정 이벤트 시 자동으로 실행할 사용자 정의 명령을 설정하는 기능입니다. 예를 들어 “파일 편집이 끝나면 자동으로 코드 포매터를 돌려라”, “Claude가 내 입력을 기다릴 때 데스크톱 알림을 띄워라”, “특정 파일에 대한 수정은 차단하라” 등의 동작을 Hook으로 구현할 수 있습니다[76][77]. Hook은 LLM의 자율적인 판단에 맡기는 것이 아니라 사용자가 강제하는 결정론적 자동화이므로, 꾸준히 동일한 처리를 보장해 줍니다[78][76]. Boris Cherny도 Claude Code의 Hook 기능을 활용하여 코드 포매팅 등의 반복 작업을 자동화하고 있습니다[79][80].
Claude Code에서는 다양한 Hook 이벤트를 제공합니다[81]:
•    PreToolUse: Claude가 Tool(Bash, Write 등)을 사용하기 직전. (여기서 명령을 가로채 실행을 막거나 대안을 제시할 수도 있음)
•    PostToolUse: Tool 사용이 완료된 직후. (결과를 후처리하거나 부가 작업을 수행)
•    PermissionRequest: 권한 허용 다이얼로그가 떴을 때. (자동 허용/거부 로직 삽입 가능)
•    UserPromptSubmit: 사용자가 프롬프트를 입력하고 Claude 처리 전에. (특정 키워드 필터링 등 가능)
•    Notification: Claude가 OS 알림을 보낼 때. (알림 방식을 커스터마이징)
•    Stop: Claude의 한 사이클 응답이 완료되었을 때. (전체 작업 종료 시 동작)
•    SubagentStop: 서브에이전트 태스크가 끝났을 때.
•    PreCompact: Claude가 대화 압축(compact)을 수행하기 직전.
•    SessionStart, SessionEnd: 세션이 시작되거나 종료될 때.
이 중 많이 활용되는 것은 PreToolUse, PostToolUse, Stop 세 가지입니다. 이제 Boris의 사례와 함께 Hook 설정 방법을 살펴보겠습니다.
4.1 .claude/settings.json에서 Hook 설정
Hook은 프로젝트 단위 또는 사용자 단위의 설정(JSON)에서 정의합니다. 프로젝트의 .claude/settings.json 파일에 "hooks": { ... } 섹션을 추가하면 해당 프로젝트에서 Hook이 활성화됩니다. Boris의 팀은 .claude/settings.json을 git에 공유하여 팀원 모두 동일한 Hook 규칙을 적용받도록 하고 있습니다[82].
예시: 코드 포매팅 Hook – Boris는 Claude가 코드 변경 후 CI에서 형식 문제로 실패하는 일을 막기 위해, 파일 편집이 끝날 때 자동으로 포매터를 실행합니다. 그의 PostToolUse Hook 설정 예시는 다음과 같습니다:
"hooks": {
  "PostToolUse": [
    {
      "matcher": "Write|Edit",
      "hooks": [
        {
          "type": "command",
          "command": "bun run format || true"
        }
      ]
    }
  ]
}
이 설정은 파일 쓰기(Write) 또는 편집(Edit) 툴 사용 직후에, "bun run format || true" 쉘 커맨드를 실행하는 Hook을 등록합니다[83][84]. matcher: "Write|Edit"는 이벤트 필터로 정규식처럼 동작하여, Write나 Edit 툴인 경우에만 안쪽 훅이 동작하도록 합니다. "type": "command"는 쉘 커맨드를 실행하는 훅임을 뜻하며, 지정된 커맨드를 현재 OS 쉘에서 실행합니다[85][86]. 위 예에서 || true를 덧붙인 것은 포매팅 툴이 에러코드(non-zero)로 종료해도 Hook 파이프라인이 중단되지 않게 하기 위함입니다.
주의: Hook에서 실행되는 쉘 명령은 현재 프로젝트 디렉토리에서 실행됩니다. 필요 시 경로를 절대경로나 $CLAUDE_PROJECT_DIR 환경변수를 사용해 지정할 수 있습니다[87][88].
위 설정을 적용하면, Claude가 파일을 수정하는 툴을 쓸 때마다 자동으로 Prettier (bun 이용) 등이 돌아가서 코드 스타일을 바로잡습니다. Boris의 말대로 Claude 자체도 대부분 포맷을 잘 맞추지만, 이 Hook이 “CI에서 포맷 문제를 잡아내는 마지막 10%”를 해소해 준다고 합니다[89].
또 다른 예제로 Markdown 포맷팅 Hook을 들 수 있습니다. Anthropic 문서에 제시된 예시로, Markdown 파일의 코드블럭에 언어 태그가 없으면 자동으로 감지해 채워넣고, 불필요한 공백을 정리하는 파이썬 스크립트를 PostToolUse 훅으로 등록하는 방식입니다[90][91]. 이러한 스크립트를 .claude/hooks/ 디렉토리에 저장해 두고 Hook 설정에서 호출하면, Claude가 문서 수정 시 알아서 마크다운 형식을 손봐주게 됩니다[92][88].
4.2 Hooks 설정 GUI와 검증
Hook은 JSON을 직접 편집하지 않고도 대화창 UI에서 설정할 수 있습니다. /hooks Slash Command를 입력하면 Hook 설정 인터페이스가 열리며, 여기서 Hook 이벤트 종류 선택 → 매처 추가 → Hook 동작 추가를 순차적으로 할 수 있습니다[93][94]. 예를 들어 PreToolUse → matcher: Bash → hook: notify-send ... 등을 GUI로 지정하고 저장하면, 내부적으로 .claude/settings.json에 해당 JSON이 반영됩니다[95][96].
Hook 설정을 JSON으로 저장할 때, 프로젝트 단위로 저장할지, 사용자(글로벌) 단위로 저장할지를 선택할 수 있습니다[97][98]. 예컨대 위 포매팅 훅은 팀 전체에 공유되야 하므로 프로젝트 설정에 넣고, 개개인이 자신의 시스템 알림을 사용하고 싶다면 Notification 훅을 User settings (예: ~/.claude/settings.json)에 넣을 수 있습니다.
저장 후 ~/.claude/settings.json 또는 <proj>/.claude/settings.json 파일에서 "hooks": { ... } 섹션을 확인하면 설정이 반영된 것을 볼 수 있습니다[95][96]. Hook 설정이 올바르게 동작하는지 확인하려면 실제 해당 이벤트를 트리거해보는 것이 최선입니다. 예를 들어 방금 추가한 Bash 명령 로깅 PreToolUse 훅이 있다면, Claude에게 간단한 ls 명령을 실행시키고 ~/.claude/bash-command-log.txt 파일에 로그가 남는지 확인합니다[99][100].
4.3 활용 예시: Notification 및 보호 Hook
데스크톱 알림 Hook: 여러 Claude 세션을 돌릴 때 유용한 훅입니다. Notification 이벤트 훅을 사용하여 Claude가 입력 대기 상태에 들어갈 때 OS 알림을 띄우도록 할 수 있습니다. 예컨대 Linux 환경에서는 다음과 같은 설정을 .claude/settings.json에 추가합니다:
"hooks": {
  "Notification": [
    {
      "matcher": "",
      "hooks": [
        {
          "type": "command",
          "command": "notify-send 'Claude Code' 'Awaiting your input'"
        }
      ]
    }
  ]
}
matcher를 빈 문자열로 두면 모든 종류의 Notification 이벤트에 대해 훅을 실행한다는 뜻입니다. Claude가 사용자의 응답이나 승인을 기다릴 때 기본 알림 외에, notify-send를 통해 커스텀 팝업을 띄워주는 훅입니다[101][102]. Boris는 Mac의 경우 iTerm2 연동 알림을 사용했지만, Windows나 Linux에서도 이처럼 Hook으로 구현 가능하며, 멀티태스킹 상황에서 Claude 대기가 생길 때 바로 알아차릴 수 있게 해줍니다.
파일 편집 차단 Hook: 매우 중요한 설정 파일이나 민감한 파일을 Claude가 수정하지 못하도록 강제하는 것도 Hook으로 가능합니다. PreToolUse 이벤트에 matcher: "Edit|Write"를 주고, 훅 명령에서 특정 경로면 에러 코드를 리턴하여 Claude에게 거부시키는 방식입니다. Anthropic 예시를 보면 .env나 package-lock.json, .git/ 폴더 등 포함되면 실패 코드를 반환하여 Claude가 수정을 멈추도록 했습니다[103][104]. 이러한 Hook을 통해 중요 자원에 대한 쓰기 금지 정책도 구현할 수 있습니다.
Hook는 이 외에도 무궁무진한 활용이 가능합니다. 회사 정책상 인터넷 검색을 막아야 한다면 PreToolUse에서 "matcher": "WebSearch"로 잡아두고 차단하거나, PermissionRequest 훅에서 특정 명령은 자동 승인/거절하는 로직을 넣을 수도 있습니다. 모든 Hook 실행 코드에 대해서는 보안에 유의해야 합니다. Hook 스크립트 자체가 악의적으로 변경되면 사용자 크레덴셜로 임의 코드가 실행되므로, 팀 프로젝트에서는 Hook 설정 변경에 코드리뷰를 적용하는 등 안전 장치를 마련해야 합니다[105][106].
5. 백그라운드 작업 관리와 검증 루프
일부 코딩 작업은 실행에 오랜 시간이 걸립니다. 예를 들어 전체 테스트 스위트를 돌린다든지, 대용량 데이터를 처리한다든지, UI를 실제로 띄워서 확인한다든지 하는 작업은 Claude의 한 회차 응답으로 끝나지 않고 장기간 돌아가야 할 수 있습니다. Claude Code는 이러한 Long-Running Task에 대처하기 위한 여러 메커니즘을 제공합니다[107]:
•    백그라운드 에이전트로 검증: Claude에게 “이 작업이 끝나면 백그라운드 에이전트를 통해 결과를 검증해”라고 프롬프트에 지시하여, 메인 작업 완료 후 별도 sub-agent가 결과를 확인하도록 할 수 있습니다[108].
•    Stop Hook 활용: 작업 완료를 Claude가 알게 될 Stop 이벤트에 Hook을 걸어, 예컨대 메인 프로세스가 끝나면 자동으로 테스트 실행 (PreToolUse Stop 서브에이전트)하거나, 결과물을 요약 정리하는 스크립트를 돌릴 수 있습니다[109].
•    자율 반복 플러그인: Anthropic이 제공하는 Ralph Wiggum 플러그인은 Claude가 스스로 피드백 루프를 돌며 문제 해결을 반복하도록 해줍니다[110]. 이 플러그인을 사용하면 사용자가 개입하지 않아도 Claude가 일정 기준을 충족할 때까지 결과를 개선하는 루프를 수행합니다.
Boris는 상기 세 가지 방식을 모두 상황에 따라 활용하지만, 특히 Ralph Wiggum과 같은 자율 루프를 장시간 실행해야 할 때는 권한 프롬프트로 인해 중단되지 않도록 설정하는 것을 강조합니다[111]. 즉, --permission-mode=dontAsk 또는 극단적으로 --dangerously-skip-permissions 모드를 켜고, 샌드박스 모드에서 실행하면 Claude가 사용자 승인 없이 계속 작업을 진행할 수 있습니다[111]. 샌드박스는 Claude Code의 /sandbox 기능으로, Claude의 Bash 명령을 격리된 파일시스템/네트워크 공간에서 돌리는 모드입니다[112]. 위험한 권한 스킵을 할 때는 샌드박스를 반드시 활용하여 실제 시스템에 변경을 가하지 않도록 해야 합니다.
5.1 백그라운드 Bash 작업 (/bashes)
Claude Code에서는 Bash 명령을 백그라운드로 실행할 수도 있습니다. 만약 Claude에게 장시간 실행되는 프로세스(예: 서버 실행 npm start 등)를 실행시키면, Claude는 이를 자동으로 백그라운드로 돌리고 다음 작업을 이어나갈 수 있습니다. 사용자는 /bashes 명령으로 현재 백그라운드에서 실행 중인 bash 프로세스 목록을 확인하고, 필요한 경우 개별 프로세스를 종료(/kill <id> 또는 UI에서 선택)할 수 있습니다[113].
예를 들어, Claude가 테스트 서버를 띄워야 하는 시나리오가 오면, context: fork된 sub-agent를 통해 서버를 띄우고, 메인 대화는 계속 진행하면서 sub-agent가 백그라운드로 서버 로그를 모니터링하도록 구성할 수 있습니다. 이때 /bashes에 서버 프로세스가 표시되고, 사용자가 수동으로 끄거나 할 수도 있습니다. v2.1.3 업데이트에서는 상태 표시줄의 백그라운드 작업 개수와 /tasks 또는 /bashes에 표시되는 항목 수가 일치하지 않던 버그도 수정되어, 정확한 작업 모니터링이 가능해졌습니다[114][115].
5.2 검증(Verification) 루프 설계
Boris는 “Claude에게 자기 일을 검증할 방법을 주는 것”이 가장 중요하다고 말합니다[116]. 결과의 품질을 2~3배 높이는 비결은 Claude 스스로 결과를 테스트하고 피드백 받는 루프를 만들면 된다는 것입니다[116]. Claude Code에서는 이 검증 루프를 구현하기 위해 여러 도구를 쓸 수 있습니다:
•    간단한 검증: Bash 명령 실행으로 충분한 경우. 예) 빌드 커맨드 실행, 특정 스크립트 실행 등. Plan에 “마지막에 npm run build 실행하여 성공 여부 확인” 등을 넣으면 Claude가 자체 검증하게 할 수 있습니다[117].
•    중간 난이도: 테스트 스위트 실행. 예) npm test나 pytest 등을 돌려 통과 여부 확인. Claude가 test 결과를 보고 필요한 수정 작업을 이어서 진행하게 할 수 있습니다.
•    복잡한 검증: UI 테스트나 실제 앱 시뮬레이션. 이 경우 MCP를 활용하여 브라우저를 원격 제어하거나, 모바일 시뮬레이터 MCP를 통해 앱을 띄워 확인할 수 있습니다[118][119]. Anthropic이 제공하는 Claude Chrome Extension은 Claude가 웹 브라우저를 열어 UI를 직접 검사하고 조작할 수 있게 해주며, Boris 팀은 이를 활용해 claude.ai 웹앱의 모든 변경을 브라우저 테스트로 검증한다고 합니다[120][121].
Claude에게 이러한 도구와 권한만 주어지면, 나머지는 AI가 알아서 최적화합니다. Boris는 “Claude는 그저 출력물을 볼 수 있는 도구만 주어지면, 알아서 나머지를 해낸다”고 말하며, 검증 루프 구축은 생각보다 단순하다고 조언합니다[122][123]:
1.    Claude가 결과를 볼 수 있는 수단을 제공 – 서버 코드면 서버 실행 방법, 웹 코드면 UI를 띄워 상호작용할 방법 등을 도구로 추가.
2.    Claude에게 그 도구를 언제 쓸지 알려주기 – 도구 설명을 잘 적어 Claude가 필요 시 이를 사용하도록 유도.
이 두 가지만 세팅하면 Claude가 나머지는 스스로 figure out한다는 것입니다[122][123]. 실제로 Boris의 Claude Code 워크플로우에서는 PR 작성이 끝나면 항상 전체 애플리케이션을 실행하고, 브라우저 테스트를 돌려본 후 PR을 완성합니다[120][121]. 이러한 자동 검증 인프라 구축에는 초front에 투자가 필요하지만, 한번 만들어두면 모든 작업에 걸쳐 품질을 담보해주므로 “그 투자비용 이상의 효과를 낸다”고 강조됩니다[124].
Ralph Wiggum 자율 루프
Ralph Wiggum 플러그인은 자율 에이전트 실행을 위한 공식 플러그인으로, 한 번 명령을 내리면 Claude가 멈추지 않고 목표 달성까지 계속 루프를 돕습니다. 예컨대 /loop-until-done <task> 형태로 플러그인을 호출하면, Claude가 스스로 결과를 평가하며 여러 번 Plan-Execute를 반복합니다[110][125]. Boris는 장시간 인간 개입 없이 돌려도 되는 작업 (몇 시간씩 걸리는 작업 등)에 이 플러그인을 활용한다고 합니다[125].
Ralph Wiggum은 Geoffrey Huntley가 고안한 아이디어를 Anthropic이 실험적으로 구현한 것으로 알려져 있으며[125], 필요시 claude plugins install ralph-wiggum 등을 통해 설치하여 사용할 수 있습니다[126]. 다만, 이처럼 완전 자율 모드로 둘 때는 반드시 샌드박스 모드 + skip permissions 조합을 사용하여 사람이 확인하지 않아도 진행되도록 설정해주어야 합니다[111].
요약하면, 백그라운드/장시간 작업에 대해서는:
•    가급적 Claude에게 검증도구를 주어 자기완결 루프를 설계한다.
•    사람 개입 없이 돌릴 때는 권한 승인 모드를 완화하고 (dontAsk 또는 skip-permissions) 샌드박스 격리를 사용한다.
•    필요하면 Stop Hook으로 후처리를 걸어 신뢰성을 높인다 (예: 작업 끝나면 /notify 성공 등).
이렇게 구축된 인프라 하에서 Claude Code는 단순히 코딩 보조를 넘어, 스스로 코딩 -> 실행 -> 검증 -> 수정의 사이클을 일부 자율화하여 개발자의 부담을 덜어줄 것입니다.
6. MCP 통합 – 외부 도구 및 서비스 연결
MCP (Model Context Protocol)는 Claude Code가 외부 서비스(API, DB 등)에 접근할 수 있도록 해주는 플러그형 통신 프로토콜입니다[127]. Anthropic는 Slack, GitHub, BigQuery, Sentry 등 여러 도구에 대한 MCP 커넥터를 제공하며, 사용자도 직접 MCP 서버를 만들어 Claude와 연동할 수 있습니다. Boris Cherny는 Claude Code를 모든 개발 도구의 허브로 사용하기 위해 MCP를 적극 활용합니다. 예를 들어 Slack MCP를 설정해 둔 덕분에, Claude가 답변이 필요한 질문을 Slack 채널에서 검색해 찾아오거나, 특정 키워드에 반응해 Slack에 메시지를 남기도록 할 수 있습니다[128].
6.1 .mcp.json 설정 및 사용
프로젝트 루트에 .mcp.json 파일을 만들어 MCP 서버 설정을 넣어두면 Claude Code가 해당 연결 정보를 읽어들입니다. Boris의 예시를 보면, Slack 통합을 위해 .mcp.json에 다음과 같이 설정했습니다[129]:
{
  "mcpServers": {
    "slack": {
      "type": "http",
      "url": "https://slack.mcp.anthropic.com/mcp"
    }
  }
}
여기서 "slack"은 MCP 서버의 이름(임의 지정)이고, type: "http"는 HTTP 프로토콜로 통신하는 MCP 서버임을 의미하며, url은 Anthropic이 제공하는 Slack MCP 중계 서버 주소입니다[130]. 이 설정을 팀과 공유하면 모두 같은 Slack 워크스페이스 연동을 활용할 수 있습니다. (Slack MCP를 사용하려면 사전에 Claude Slack 앱 설치 등 OAuth 인증 절차가 필요하지만, /mcp 명령으로 설정을 마칠 수 있습니다[131].)
MCP 서버를 등록한 후 Claude Code에서 제공되는 관련 슬래시 명령을 사용할 수 있습니다. 예컨대 Slack MCP의 경우 /mcp__slack__list_channels 같은 명령이 자동 등록되어, Claude가 Slack API를 통해 채널 목록을 가져오도록 할 수 있습니다[132]. 사용자 입장에선 단순히 Slash Command를 사용하지만, 실제로는 Claude Code가 MCP 프로토콜로 외부 API를 호출하고 결과를 받아와 Claude에게 전달합니다.
MCP를 이용하면 Claude가 가진 툴셋을 사실상 무제한으로 확장할 수 있습니다[128][129]. 빅쿼리 질의, 헬스체크, 타사 API 호출 등 무엇이든 MCP 서버만 구현되어 있다면 Claude의 도구로서 활용 가능합니다. Anthropic는 이러한 MCP 서버들을 위한 모델contextprotocol 패키지를 제공하고 있어, 간단한 CLI 명령으로 통용되는 MCP 서버(예: claude mcp add --transport stdio github npx -y @modelcontextprotocol/server-github)를 추가할 수도 있습니다[133][134].
On-demand Tool Loading: MCP 및 플러그인 등을 많이 등록하면 컨텍스트 창 용량에 영향을 줄까 걱정될 수 있습니다. 하지만 Claude Code는 도구를 실제 쓰기 전까지는 프롬프트에 최소한의 힌트만 유지하고, 호출 시 동적으로 불러오는 최적화를 갖추고 있습니다[135]. 예컨데 Slack MCP를 등록해두어도 Claude의 대화에 해당 MCP를 쓰지 않으면 토큰을 거의 차지하지 않으므로, 필요한 MCP를 과감하게 추가해 두어도 됩니다.
6.2 MCP 보안 및 정책
팀 환경에서 MCP 사용 시 보안과 접근 제어도 중요합니다. Claude Code v2.1.6에서는 Managed MCP 설정을 도입하여, 관리자가 허용한 MCP 서버만 사용한다든지, 특정 MCP 종류(예: 파일시스템 접근 MCP 등)를 전면 차단할 수 있는 정책을 적용할 수 있습니다[136][137]. 예를 들어 관리 설정으로 allowedMcpServers나 deniedMcpServers를 지정하면, 팀원들이 임의로 위험한 MCP를 추가하지 못하도록 강제할 수 있습니다[136][137].
기본적으로 .mcp.json에 정의된 MCP는 프로젝트별로 적용되며, ~/.claude/mcp.json에 넣으면 전역 적용도 가능합니다. Boris는 .mcp.json을 프로젝트에 포함시켜 팀 전체가 Slack MCP를 쓰도록 했는데, 이때 v2.1.6에서 추가된 /config의 Release Channel 설정을 통해 모든 팀원이 같은 버전의 Claude Code를 사용하도록 유도하기도 합니다[39][138]. (Release Channel은 stable과 latest 중 선택 가능하며, /config UI나 .claude/settings.json의 "updateChannel": "latest"와 같은 설정으로 지정할 수 있습니다.)
MCP를 활용하면 Claude Code는 단순한 코딩 도우미를 넘어, 프로덕션 환경과 각종 DevOps 도구까지 제어하는 중앙 허브로 발전합니다. 예컨대 Claude에게 “에러 로그에서 오늘 5xx 오류 빈도 알려줘”라고 물으면, Sentry MCP를 통해 로그 데이터를 질의하여 답변하게 할 수 있습니다[128][129]. 이러한 통합은 코딩 맥락에서 필요한 부가정보를 Claude가 직접 수집하게 해주므로, 개발자는 더욱 고차원적인 문제 해결에 집중할 수 있습니다.
7. .claude 디렉토리 구조와 설정 통합
지금까지 다룬 다양한 설정 요소들은 모두 .claude 디렉토리 아래에 구조화됩니다. Claude Code는 프로젝트 루트의 .claude/ 폴더와 사용자 홈의 ~/.claude/ 폴더를 주요 설정 소스로 사용합니다. 각각 프로젝트(팀) 스코프와 유저 개인 스코프로 작동하며, 프로젝트 설정이 우선 적용되되 없으면 글로벌 설정을 따르는 방식입니다[139][140].
아래는 Boris의 사례를 토대로 한 .claude/ 디렉토리 구조 예시입니다:
/myproject
 ├── CLAUDE.md
 ├── .claude/
 │    ├── settings.json         # 프로젝트별 설정: 권한, 훅, 기본 모델 등
 │    ├── commands/             # 프로젝트 커스텀 명령 디렉토리
 │    │    ├── commit-push-pr.md
 │    │    ├── optimize.md
 │    │    └── ... (기타 명령들)
 │    ├── skills/               # (선택) 프로젝트 스킬 명령 디렉토리 
 │    │    └── devops/ 
 │    │         └── deploy-check.md 
 │    ├── hooks/                # (선택) 훅 스크립트 등 저장소
 │    │    └── markdown_formatter.py
 │    └── agents/               # (선택) 커스텀 sub-agent 정의 (Markdown 파일들)
 │         └── db-migration-expert.md
 └── .mcp.json                  # 프로젝트 MCP 서버 설정 (선택 사항)
•    CLAUDE.md: 이 파일은 메모리 파일로, Claude에게 제공되는 지속 컨텍스트입니다[141][142]. Boris의 팀은 여기 팀의 코딩 스타일, 규칙, 과거 실수 교훈 등을 기록해두고, Claude가 모든 세션에서 이를 참조하게 합니다[143][141]. CLAUDE.md는 slash command /memory나 /init 명령으로 편집/생성할 수 있고, Claude Code는 이 파일 내용을 자동으로 프롬프트 앞부분(시스템/기억 영역)에 포함시킵니다[144][145]. 결과적으로 CLAUDE.md를 잘 관리하면 쌓이는 지식이 세션 간에도 지속되어, 같은 실수를 반복하지 않도록 도와줍니다[146][147].
•    settings.json: 프로젝트 레벨 설정 파일로, 후술할 다양한 설정 키를 JSON 구조로 포함합니다. Boris는 이 파일에 주로 permissions 허용 목록, hooks 설정, 기본 모델 지정 등을 넣어둔다고 밝혔습니다[82]. 이 파일은 팀원들과 git으로 공유되어 모두 같은 환경을 갖추게 합니다[148]. settings.json의 주요 설정 항목은 다음과 같습니다:
•    model: 기본 사용할 Claude 모델 (예: "claude-4-5-opus"). Boris는 Opus 4.5 모델을 모든 세션에 기본 사용하도록 설정합니다[149][150].
•    permissions: allow, ask, deny 배열로 구성된 툴 권한 규칙[151][152]. Boris 팀은 여기에 bun run build:*, bun run test:* 등 자주 쓰는 안전 명령을 allow로 넣었습니다[153][148]. 또한 CI 비밀이나 환경파일에 해당하는 경로는 deny로 지정해 Claude가 접근하지 못하게 하는 등 설정이 가능합니다. defaultMode로 기본 권한 모드("default", "acceptEdits", "requireApproval", "planning", "bypassPermissions" 등)를 정할 수도 있습니다[154].
•    hooks: 이전 장에서 논의한 Hook 설정 JSON. Boris의 프로젝트 settings.json에는 PostToolUse 포매터 훅과, 특정 권한 skip을 방지하기 위한 trust 설정 등이 들어 있습니다[79][83].
•    그 외 outputStyle(출력 스타일 지정), sandbox(샌드박스 세부 설정), statusLine(상태 표시줄 커스터마이즈) 등도 이 파일에 넣을 수 있습니다[155][156]. v2.1.6에서는 상태 표시줄에 컨텍스트 창 사용량을 표시하는 기능이 강화되어, context_window.used_percentage와 remaining_percentage 값을 이용해 사용자 정의 상태줄을 만들 수 있습니다[59]. 기본 /context 명령도 그래픽으로 컨텍스트 사용 상황을 보여주지만, 상시 표시를 원하면 statusLine 스크립트를 설정하면 됩니다.
•    commands/ 및 skills/: 앞서 다룬 사용자 정의 명령 모음 디렉토리입니다. 파일 수가 늘어나면 하위 폴더로 조직화하고, skills 폴더는 특정 영역 모듈화에 활용합니다. Boris는 commands/ 폴더에 일반 워크플로우 명령들을, 필요한 경우 skills/ 하위에 카테고리별 명령을 넣는 식으로 관리합니다.
•    hooks/: 긴 JSON을 settings.json에 직접 쓰기보다, 복잡한 훅은 스크립트를 별도 파일로 작성해 hooks 폴더에 두고 훅 설정에서 호출하기도 합니다[87][88]. 예를 들어 위 markdown_formatter.py처럼 말이죠.
•    agents/: 사용자가 정의한 고정 Sub-agent들입니다. Slash Command와 달리 Sub-agent는 미리 시스템 프롬프트와 권한, 모델 등이 설정된 에이전트를 정의해둘 수 있습니다[157][158]. 예시의 db-migration-expert.md는 데이터베이스 마이그레이션에 특화된 sub-agent 정의이며, name, description, model, tools 등을 frontmatter로 지정하고 나머지 본문에 역할 지침을 적습니다[157][159]. 이렇게 .claude/agents 폴더에 정의해두면 Claude가 대화 중 관련 작업 필요 시 자동으로 해당 sub-agent를 불러쓸 수도 있고(/agents 명령으로 목록 관리), 사용자가 /agents run <name> 형태로 직접 실행할 수도 있습니다[61][113]. (Sub-agent 정의는 고급 주제이므로 여기서는 깊이 다루지 않습니다. 다만 v2.1 이후 Boris가 Sub-agent를 직접 정의해서 쓰는 일은 드물다고 언급한 바 있습니다 – 기본 slash command로 충분한 경우가 많기 때문입니다.)
•    .mcp.json: 앞절에 설명한 MCP 서버 정의 파일입니다. 프로젝트와 함께 체크인하여 팀 전체가 동일한 MCP 구성을 갖도록 합니다. 민감한 API 토큰 등은 이 파일에 직접 담지 않고, OAuth 흐름 등을 통해 인증하게 하는 것이 일반적입니다. (.mcp.json 자체에는 토큰을 넣을 수도 있으나, 보안상 repository에 올리는 것은 권장되지 않습니다. Anthropic은 Managed Settings로 MCP 허용 목록 등을 통제할 수 있도록 했습니다[136].)
이러한 .claude 디렉토리 구조는 한 번 설정해두면 지속적으로 축적되는 자산이 됩니다. Boris의 팀은 CLAUDE.md와 commands, settings 등을 모두 git으로 관리하여, Claude가 학습하는 환경과 규칙이 코드베이스와 함께 버전 관리되도록 하고 있습니다[141][143]. 예컨대 PR 코멘트로 @.claude를 태그하면 CLAUDE.md에 들어갈 항목을 자동으로 생성해주는 GitHub Action(/install-github-action 명령)도 활용하여, 개발과 문서/규칙 업데이트를 한 흐름에서 처리하고 있습니다[160][161].
업데이트 관리: v2.1.6부터 /doctor 명령이 자동 업데이트 불가 원인을 명시적으로 알려주도록 개선되었습니다[162]. 예컨대 NPM 글로벌 설치로 인한 권한 문제로 auto-update가 꺼져 있으면 /doctor가 그 이유를 표시해주고, /config → Release Channel에서 latest로 스위치하라는 안내를 합니다[162][163]. 팀원들이 모두 최신 기능을 쓰기 위해 /doctor로 상태를 점검하고 claude update를 수행하는 것이 좋습니다. 또한 /doctor는 v2.1.3부터 설정한 권한 규칙 중 도달하지 않는(unreachable) 규칙을 탐지하여 경고해줍니다[163][164]. 예를 들어 동일 패턴에 대해 먼저 allow 후 later deny 규칙이 있으면 후자가 영향 없음을 지적해주고, 각 규칙 소스와 해결 가이드도 출력합니다.
정리하면, .claude/ 폴더와 그 하위 구조를 잘 구성하는 것이 Claude Code 에이전트 인프라의 뼈대입니다. 모든 설정을 코드로 기록하고, 팀과 공유하며, 점진적으로 개선해 나갈 수 있습니다. Boris는 특별한 트릭 없이도 이러한 공유 설정과 병렬화, 검증 루프의 “규모의 경제”로 하루 수백 커밋의 생산성을 내고 있다고 밝혔습니다[165][166].
8. Telemetry와 모니터링 – 사용 통계 및 성능 측정
Claude Code v2.1.6는 개발자 생산성 도구로서 사용량 통계와 메트릭 수집 기능도 대폭 향상되었습니다. 이를 통해 팀은 AI 코딩 어시스턴트의 활용도를 측정하고, 병목 지점을 찾거나 비용 관리에 활용할 수 있습니다.
8.1 /stats 명령과 사용 패턴 분석
/stats 명령은 Claude Code 사용 통계를 시각화해줍니다[167][168]. 최근 개선된 /stats는 일일 사용량, 세션 히스토리, 연속 사용 일수(Streak), 모델 별 사용 비중 등을 그래프로 보여줍니다. 예컨대 하루 동안 얼마나 Opus vs Sonnet 모델을 썼는지, 지난 일주일 간 토큰 소비량은 어떠했는지 등을 확인할 수 있습니다. 또한 기간 필터를 적용하여 특정 기간의 통계를 볼 수 있고, 특정 프로젝트나 세션만 선택해 분석할 수도 있습니다 (예: 프로덕션 버그 수정에 Claude를 얼마나 썼나 등).
이 기능은 연말이 되면 흔히 보는 “Yearly Wrapped”와 같은 개념으로, AI 코딩 사용량을 리뷰하는 데도 쓰입니다. 개발자는 /stats를 참고하여 AI 도움에 의존한 정도나 효율성 향상 지표를 자가 측정할 수 있습니다. WakaTime 같은 개발 분석 도구와도 비견되며, 특정 클라이언트(Claude Code)로 필터링해 대시보드에 통합할 수도 있습니다[169].
v2.1.x 업데이트에서는 /stats 출력에 필터 버튼이 생겨 원하는 범위만 볼 수 있게 되었고, Markdown 형식으로 데이터를 내보내는 기능도 향상되었습니다[170]. 예를 들어 stats --time 옵션으로 실제 "손을 움직인 키보드 시간"을 추정하는 지표를 볼 수도 있습니다[170]. 이러한 데이터는 모두 SQLite에 로컬 저장되므로, 원한다면 추가적인 쿼리나 시각화도 가능할 것입니다.
8.2 OpenTelemetry 통합
Anthropic는 기업 환경의 요구를 반영하여 Claude Code에 OpenTelemetry(OTel) 기반의 모니터링 기능을 추가했습니다[171]. OTel Metrics와 Events를 통해 Claude Code의 내부 동작 메트릭을 표준 방식으로 내보낼 수 있습니다[171][172]. 이를 활용하면 Grafana 같은 모니터링 대시보드에 Claude Code 관련 지표를 수집하여 표시할 수 있습니다.
활성화 방법: OTel 연동은 환경변수 설정로 간편하게 켤 수 있습니다. 예를 들어 다음과 같이 설정합니다[173][174]:
export CLAUDE_CODE_ENABLE_TELEMETRY=1
export OTEL_METRICS_EXPORTER=otlp        # OTLP 프로토콜로 메트릭 전송
export OTEL_LOGS_EXPORTER=otlp          # 이벤트도 OTLP로
export OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317  # 수집기 엔드포인트
# 필요시 인증 헤더 등 추가 설정...
claude   # Claude Code 실행
위와 같이 하면 Claude Code 실행 시부터 각종 메트릭을 지정한 OTLP 엔드포인트(예: 로컬 Collector)에 보냅니다[173][175]. Metrics는 기본 60초 주기로 Push되며, Logs/Events는 5초 주기로 전송됩니다[176]. 개발 단계에서는 간격을 줄여서 실시간으로 확인하고, 운영시에는 기본값으로 두면 됩니다.
수집되는 메트릭 예시: Anthropic 문서에 따르면 다음과 같은 지표들이 제공됩니다[177][178]:
•    Session counter: 세션 생성 및 종료 수.
•    Lines of code counter: 생성된 코드 라인 수.
•    Pull request counter: PR 생성 횟수.
•    Commit counter: 커밋 횟수.
•    Cost counter: API 호출 비용(토큰 사용 등) 합계.
•    Token counter: 사용 토큰 수 (프롬프트/완료 별).
•    Code edit tool decision counter: Write/Edit 툴 사용 횟수.
•    Active time counter: 사용자가 Claude Code와 상호작용한 활성 시간 누적.
또한 이벤트로는 UserPrompt 이벤트(사용자 프롬프트 제출), ToolResult 이벤트(툴 실행 결과), API Request/Response 이벤트 등이 로그 형태로 전송됩니다[179]. 각 메트릭에는 팀, 사용자, 모델, 세션ID 등의 속성이 붙어 필터링이 가능하며, 특히 AskUserQuestion 메트릭에는 v2.1.3부터 metadata.source 필드가 추가되어 어느 기능(예: “remember” 맥락 등)에서 유발한 질문인지 추적할 수 있게 되었습니다[180][181]. 이는 사용자 UI에는 나타나지 않지만, Telemetry 데이터로는 남기 때문에 어떤 경로로 사용자가 질문을 받게 되었는지 분석할 수 있습니다.
활용: OTel 메트릭을 수집하면 Claude Code의 ROI를 측정할 수 있습니다. 예를 들어 한 주간 AI가 작성한 코드 라인 수 대비 인간이 개입한 시간 비율(Active time)을 보면 생산성 향상도를 수치화할 수 있습니다. 오류 이벤트를 모니터링해 Claude Code의 문제 발생 빈도를 추적하거나, 모델별 토큰 소모를 비교하여 비용 효율을 최적화하는 것도 가능합니다. Anthropic는 이러한 데이터를 활용한 성과 측정 가이드를 별도로 제공하고 있으며[182][183], 기업에서는 팀별 Claude Code 사용량을 분석해 교육이나 정책 수립에 활용할 수 있습니다.
주의: Telemetry 데이터에는 코드 내용이나 경로 등 민감정보는 포함되지 않도록 설계되어 있습니다[184][185]. 기본적으로 Statsig 기반의 익명화된 이벤트도 존재하며, 이를 끌 수도 있습니다 (DISABLE_TELEMETRY=1)[186]. OTel은 사용자가 명시적으로 opt-in해야 작동하며(CLAUDE_CODE_ENABLE_TELEMETRY), 내보낸 데이터의 수집/보관은 전적으로 사용자 측 인프라에 달려 있습니다. 조직 정책에 맞게 적절히 활성화 여부를 결정하면 됩니다.
8.3 비용 및 효율 모니터링
Claude Code는 사용자 플랜의 제약 내에서 작동하므로, Pro/Max 플랜의 한도나 초과요금 등을 모니터링하는 것도 중요합니다. /usage 명령을 사용하면 현재 구독 플랜에서 사용한 토큰 및 잔여 한도를 보여주며, API Rate Limit 상황도 표시합니다[187][188]. 이 정보를 DevOps 모니터링에 통합하면 예기치 않은 요금 폭탄을 방지할 수 있습니다. 예를 들어 토큰 사용량이 비정상적으로 급증하면 웹후크 알림을 보내도록 설정하는 식입니다.
또한, 모델 선택 최적화도 telemetry를 통해 가능해집니다. Opus vs Sonnet 사용 비율과 각각의 성공률(예: 코드 에러 수정률)을 추적하면, 어떤 작업에 어떤 모델이 더 효과적인지 팀 차원에서 학습할 수 있습니다. Boris는 기본적으로 Opus 4.5를 선호하지만[149], 이는 그의 맥락에 맞춘 것이고, 조직마다 최적 지점이 다를 수 있습니다. Claude Code v2.1.6의 통계 도구들을 충분히 활용하여 데이터에 기반한 AI 도구 활용 전략을 세울 것을 권장합니다.
9. 권한 제어와 보안 – 신뢰할 수 있는 자동화 구축
AI 코딩 도구를 적극 활용하면서도 보안과 안전을 유지하는 일은 매우 중요합니다. Claude Code는 세밀한 Permission 시스템과 샌드박스, 정책 관리 기능으로 이에 대응합니다. 앞서 부분부분 언급되었지만, 이 절에서 종합적으로 정리합니다.
9.1 권한 모드와 정책
Claude Code에는 몇 가지 Permission Mode가 존재합니다[189][190]:
•    기본 모드 (default/requireApproval): 위험한 툴 사용 전에 항상 사용자에게 승인 질문을 합니다. (권장 기본값)
•    Auto-accept edits 모드 (acceptEdits): 파일 쓰기/편집은 자동 승인하지만, Bash 명령 등은 계속 승인 필요[25][30]. 즉, 코드 변경에만 자동화된 모드로, Plan 후 실행용.
•    DontAsk 모드: 모든 권한 질문을 생략하고 자동 허용합니다. 단, deny로 설정된 것은 여전히 차단됩니다. 사실상 사용자를 귀찮게 묻지 않을 뿐, 정책 자체는 지킵니다.
•    BypassPermissions 모드 (일명 Dangerously Skip): 모든 권한 체크를 무시하고 실행합니다. --dangerously-skip-permissions 플래그로 켜지며, 모든 제한을 우회하므로 절대 신뢰할 수 있는 상황(예: 완전 격리된 테스트 환경) 외에는 비권장입니다[82][191].
•    Planning 모드: Plan 단계 전용으로, Write/Edit 툴 사용을 금지하는 모드입니다. (사용자가 직접 고를 일은 적고, Plan 모드 진입시 자동으로 적용됨).
권한 모드는 claude --permission-mode=<mode> 인자나, 실행 중 Shift+Tab 반복 눌러 순환시켜 변경할 수도 있습니다[192][193]. Boris는 일반적으로 기본 모드로 두고 작업하다가, 특정 세션만 dontAsk로 전환하거나 (예: 대량 리팩토링을 밤새 돌릴 때), Plan→acceptEdits처럼 일시적으로 auto-accept를 켜는 식으로만 씁니다. 아예 skip-permissions는 쓰지 않는다고 하며, 필요한 경우 샌드박스 모드에서만 허용한다고 합니다[82][191].
.claude/settings.json의 defaultMode 키를 "acceptEdits" 등으로 지정하면 해당 프로젝트에서 기본 권한 모드도 바꿀 수 있습니다[154]. 다만 조직 차원에서 위험을 낮추려면 기본은 승인 필요 모드로 두고, 개발 편의를 위해 개별적으로 /permissions 명령으로 세부 allow 리스트를 늘리는 방식을 추천합니다.
9.2 권한 허용/차단 세부 설정
Permission Rules는 툴별 세밀한 제어를 가능하게 합니다. allow, ask, deny 배열에 "툴이름(패턴)" 문자열을 넣는 식인데, 예를 들어:
•    "Bash(git push:*)" – git push로 시작하는 Bash 명령은 물어보지 말고 (ask 또는 allow 목록에 따라) 처리.
•    "WebFetch(https://api.mycompany.com/*)" – 특정 도메인 API 호출 허용 (그 외 URL은 계속 물어봄).
•    "Read(./secrets/**)" – 프로젝트 secrets 폴더 내 파일 읽기 차단 (deny).
Bash의 패턴 매칭은 단순 prefix 기반이며 정규식은 아닙니다[151][194]. 위 예시에서 git push: 뒤에 *는 “git push로 시작하면 모두”라는 의미입니다. Boris 팀은 bun run build:*, bun run test:* 등을 allow에 넣어두어, 빌드/테스트 반복시 매번 승인 누르는 번거로움을 해결했습니다[195][148].
Anthropic는 v2.1.3에서 도달 불가능한 권한 규칙 감지 기능을 추가했습니다[163][164]. 예를 들어 이미 "Bash(git *:*)"을 allow로 넣고 다시 "Bash(git commit:*)"을 ask로 넣으면, 후자는 앞 규칙 때문에 절대 도달하지 않는데, /doctor가 이를 경고하여 사용자가 깨끗하게 규칙을 정리하도록 돕습니다. 따라서 권한 규칙은 구체적인 것부터 상단에, 범용 패턴을 하단에 두는 식으로 관리합니다.
샌드박스: settings.json의 sandbox.enabled를 true로 하면, Claude의 Bash 명령은 프로젝트를 컨테이너 격리된 환경에서 실행합니다[196][197]. 읽기/쓰기는 permissions 규칙에 따르지만, 최후의 보루로 시스템 파일 접근을 차단하고 네트워크도 제한합니다. autoAllowBashIfSandboxed 옵션이 기본 true라, 샌드박스 환경에서는 Bash 명령을 자동 승인해줘도 비교적 안전합니다[197][198]. 만약 조직 정책상 반드시 모든 명령을 샌드박스에서만 실행해야 한다면, allowUnsandboxedCommands를 false로 두면 어떠한 경우에도 dangerouslyDisableSandbox가 동작하지 않게 강제할 수 있습니다[199][200].
Boris의 경우 프로덕션 코드를 다루는 세션은 샌드박스를 끄고 (로컬 파일에 직접 작업해야 하니), 대신 민감 명령은 모두 permission ask로 유지했습니다. 반면 장난감 프로젝트나 시뮬레이션은 샌드박스+dontAsk 모드로 돌려 자유롭게 실험시키는 편입니다. 상황별 모드 전환이 유연하게 가능하므로, 개발자는 항상 “이 세션의 Claude는 얼마나 믿어도 되는가”를 염두에 두고 모드를 결정하면 됩니다.
9.3 팀 협업 시 권한 관리
팀에서 Claude Code를 도입할 때 우려 중 하나는 개발자마다 권한 설정이 제각각이면 위험할 수 있다는 점입니다. 이를 위해 Boris의 팀처럼 .claude/settings.json을 공유하여 통일된 정책을 쓰는 것이 좋습니다[148]. 그리고 중요한 것은 Skip을 쓰지 않는 문화를 정착시키는 것입니다. Boris는 --dangerously-skip-permissions는 절대 사용하지 말고, 필요하면 허용 리스트를 늘리라고 조언합니다[82][191]. Skip-permission은 말 그대로 모든 안전장치를 끄는 것이므로, 한 번 편리함에 익숙해지면 실수로 프로덕션을 망칠 위험도 있습니다.
대신 권한 요청이 자주 뜬다면 그것을 자동화(allow)하거나, 차라리 그 기능을 Hook으로 처리하도록 개선합니다. 예를 들어 CI 린트 포맷 때문에 매 커밋마다 npm run lint:fix를 돌려야 한다면, 차라리 PostToolUse Hook으로 자동화하여 권한 프롬프트가 아예 안 뜨게 하는 식입니다. 결국 권한 프롬프트 빈도가 높은 건 자동화할 기회로 볼 수 있습니다.
Anthropic의 Claude Code는 기본적으로 매우 보수적인 보안 기본값을 가지고 있으며[201][189], 사용자가 이를 인지하고 필요한 부분만 풀어주는 것이 좋습니다. 엔터프라이즈 환경에서는 Managed Settings 기능을 통해 개발자가 함부로 skip 모드를 쓰지 못하게 제한하고 (disableBypassPermissionsMode)[202][203], 허용된 MCP나 플러그인 마켓플레이스만 사용하게 강제하는 등의 통제가 가능합니다[204][205]. Claude Code v2.1.6는 조직의 IT 정책 준수를 지원하도록 이러한 관리 포인트들을 제공하니, 회사 규정에 따라 적용하면 됩니다.
________________________________________
마지막으로, Boris Cherny의 케이스는 특이하게도 별다른 “꼼수” 없이 기본 기능들을 disciplined 하게 적용한 사례라는 점을 기억해야 합니다[206][5]. 그는 여러 대의 Claude를 병렬로 돌리고, Plan/Auto-accept로 큰 그림을 잡고, 허락된 범위 내에서 Hook과 명령으로 자동화를 하며, 꾸준히 CLAUDE.md와 설정을 업데이트하는 성실한 루틴으로 성과를 냈습니다[206][207]. Karpathy 등이 언급한 초복잡 에이전트 체인을 구현하지 않아도, 기본에 충실한 설계만으로 충분히 큰 생산성 향상을 얻을 수 있다는 점이 그의 사례가 주는 교훈입니다.
이 문서의 내용대로 Claude Code 기반 에이전트 인프라를 구축하면, 개발팀은 반복 작업에서 해방되고 보다 창의적인 문제 해결에 집중할 수 있을 것입니다. AI 에이전트와 인간이 함께 코딩하는 미래를 대비하여, 이러한 인프라를 미리 깔아두는 것은 곧 경쟁력이 될 것입니다.
참고 문헌 & 출처: Boris Cherny의 공유 글[19][206], Anthropic 공식 문서[42][151], InfoQ 보도[2][208] 등. (각주 링크 참조)
________________________________________
[1] [23] [24] [68] [69] Reflections of Claude Code from CHANGELOG - DEV Community
https://dev.to/oikon/reflections-of-claude-code-from-changelog-833
[2] [208] Inside the Development Workflow of Claude Code's Creator - InfoQ
https://www.infoq.com/news/2026/01/claude-code-creator-workflow/
[3] [4] [5] [17] [18] [20] [21] [22] [38] [56] [65] [75] [79] [80] [82] [83] [84] [89] [107] [108] [109] [110] [111] [116] [117] [120] [121] [124] [125] [128] [129] [130] [135] [141] [142] [143] [146] [147] [148] [149] [150] [153] [160] [161] [191] [195] [206] [207] How the Creator of Claude Code Uses Claude Code
https://paddo.dev/blog/how-boris-uses-claude-code/
[6] [7] GitHub - pvolok/mprocs: Run multiple commands in parallel
https://github.com/pvolok/mprocs
[8] [12] [13] [15] [16] [19] [41] [67] [118] [119] [122] [123] [126] Claude Code creator Boris shares his setup with 13 detailed steps,full details below : r/ClaudeAI
https://www.reddit.com/r/ClaudeAI/comments/1q2c0ne/claude_code_creator_boris_shares_his_setup_with/
[9] [10] [11] [14] Claude Code on the web - Claude Code Docs
https://code.claude.com/docs/en/claude-code-on-the-web
[25] [30] Interactive Mode | Tencent Cloud Code Assistant CodeBuddy
https://www.codebuddy.ai/docs/cli/interactive-mode
[26] [31] 6/ Most sessions start in Plan mode (shift+tab twice). If my goal is to ...
https://www.threads.com/@boris_cherny/post/DTBVppIEkdE/most-sessions-start-in-plan-mode-shift-tab-twice-if-my-goal-is-to-write-a-pull
[27] [28] [29] [35] [192] [193] How to turn on or off "auto accept edits” mode in Windows? : r/ClaudeAI
https://www.reddit.com/r/ClaudeAI/comments/1ly66mo/how_to_turn_on_or_off_auto_accept_edits_mode_in/
[32] Integrate Claude Code's planning permission mode #233 - GitHub
https://github.com/ruvnet/claude-flow/issues/233
[33] [34] Understanding Claude Code Permissions and Security Settings
https://www.petefreitag.com/blog/claude-code-permissions/
[36] [37] [42] [43] [44] [45] [46] [47] [48] [49] [50] [51] [52] [53] [54] [55] [57] [58] [62] [63] [70] [71] [73] [74] [112] [131] [167] [168] Slash commands - Claude Code Docs
https://code.claude.com/docs/en/slash-commands
[39] [114] [115] [138] [163] [164] [180] [181] Anthropic just released Claude Code 2.1.3, full details below : r/ClaudeAI
https://www.reddit.com/r/ClaudeAI/comments/1q8okkb/anthropic_just_released_claude_code_213_full/
[40] Claude Code 2.1 Is Here — I Tested 16 New Changes (Don't Miss ...
https://medium.com/@joe.njenga/claude-code-2-1-is-here-i-tested-all-16-new-changes-dont-miss-this-update-ea9ca008dab7
[59] Itomaru (@izag82161) / Posts / X - Twitter
https://x.com/izag82161?lang=en
[60] [61] [64] [66] [113] [127] [132] [133] [134] [144] [145] [157] [158] [159] [187] [188] The Ultimate Claude Code Cheat Sheet: Your Complete Command Reference | by Toni Maxx | Nov, 2025 | Medium
https://medium.com/@tonimaxx/the-ultimate-claude-code-cheat-sheet-your-complete-command-reference-f9796013ea50
[72] Top 10 Claude Code Commands Practical Guide | Medium
https://alirezarezvani.medium.com/10-claude-code-commands-that-cut-my-dev-time-60-a-practical-guide-60036faed17f
[76] [77] [78] [81] [85] [86] [87] [88] [90] [91] [92] [93] [94] [95] [96] [97] [98] [99] [100] [101] [102] [103] [104] [105] [106] Get started with Claude Code hooks - Claude Code Docs
https://code.claude.com/docs/en/hooks-guide
[136] [137] [139] [140] [151] [152] [154] [155] [156] [184] [185] [186] [194] [196] [197] [198] [199] [200] [202] [203] [204] [205] Claude Code settings - Claude Code Docs
https://code.claude.com/docs/en/settings
[162] Claude Code 2.1 (New Upgrades): Are they copying OpenCode ...
https://www.youtube.com/watch?v=IwjIhUI8fFQ
[165] [166] Boris Cherny Claude Code Creator Shares These 22 Tips (You’re Probably Using It Wrong) | by Joe Njenga | Jan, 2026 | Medium
https://medium.com/@joe.njenga/boris-cherny-claude-code-creator-shares-these-22-tips-youre-probably-using-it-wrong-1b570aedefbe
[169] Get ready for your yearly wrapped code stats - WakaTime
https://wakatime.com/blog/69-get-ready-for-your-yearly-wrapped-code-stats
[170] Claude code history exporter with cross-platform support + stats
https://www.reddit.com/r/ClaudeAI/comments/1pexehu/claude_code_history_exporter_with_crossplatform/
[171] [172] [173] [174] [175] [176] [177] [178] [179] [182] [183] Monitoring - Claude Code Docs
https://code.claude.com/docs/en/monitoring-usage
[189] [201] How to stop Claude Code from asking for permission every time?
https://www.reddit.com/r/ClaudeAI/comments/1l45dcr/how_to_stop_claude_code_from_asking_for/
[190] How to Set Claude Code Permission Mode - ClaudeLog
https://www.claudelog.com/faqs/how-to-set-claude-code-permission-mode/
