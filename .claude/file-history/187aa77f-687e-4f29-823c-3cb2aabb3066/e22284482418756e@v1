"""
Orion ODA v3.0 - Execution Orchestrator
=======================================

Facade orchestrating plan execution with automatic verification.

This module integrates:
- OutputLayerManager: 3-Layer Progressive-Disclosure (L1/L2/L3)
- ContextBudgetManager: V2.1.7 effective context window management
- TaskDecomposer: 32K token compliance via scope-based splitting
- AgentRegistry: Agent lifecycle tracking with resume support
- PlanFile: Bidirectional markdown sync

Main Agent Interface:
    orchestrator = get_orchestrator()
    result = orchestrator.execute_plan("path/to/plan.md")

    # Or phase-by-phase:
    orchestrator.load_plan("path/to/plan.md")
    for phase in orchestrator.get_pending_phases():
        result = orchestrator.execute_phase(phase.number)
        if not orchestrator.recovery_gate(result):
            break  # BLOCKED - needs recovery

Usage:
    from lib.oda.planning import (
        ExecutionOrchestrator,
        get_orchestrator,
        RecoveryDecision,
    )

    orchestrator = get_orchestrator(session_id="my_session")
    orchestrator.load_plan(".agent/plans/my_plan.md")

    # Execute with automatic verification
    result = orchestrator.execute_phase(1)

    # Check recovery gate
    if result.decision == RecoveryDecision.NEEDS_REDELEGATION:
        # Handle blocked state
        options = orchestrator.get_recovery_options(result)
"""

from __future__ import annotations

import logging
import os
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

# =============================================================================
# Internal Module Imports
# =============================================================================
from .output_layer_manager import (
    OutputLayerManager,
    OutputLayer,
    is_summary_only,
    read_layer_auto,
    verify_subagent_result,
    extract_agent_id_from_result,
    get_output_manager,
)
from .context_budget_manager import (
    ContextBudgetManager,
    ThinkingMode,
    DelegationDecision,
    get_session_manager,
    check_context_before_task,
)
from .task_decomposer import (
    TaskDecomposer,
    SubagentType,
    SubTask,
    should_decompose_task,
    decompose_task,
)
from .agent_registry import (
    AgentRegistry,
    AgentEntry,
    get_registry,
    register_agent,
    can_resume_agent,
)
from .plan_file import (
    PlanFile,
    PlanStatus,
    PhaseStatus,
    AgentStatus as PlanAgentStatus,
    Phase,
    load_plan,
)

# =============================================================================
# Logging Setup
# =============================================================================
logger = logging.getLogger(__name__)


# =============================================================================
# Enums and Dataclasses
# =============================================================================

class RecoveryDecision(str, Enum):
    """Recovery gate decision outcomes."""
    COMPLETE = "complete"              # Full result available
    L2_RECOVERED = "l2_recovered"      # Got detailed content from L2
    L3_RECOVERED = "l3_recovered"      # Got detailed content from L3
    NEEDS_REDELEGATION = "needs_redelegation"  # Must resume/re-execute
    BLOCKED = "blocked"                # Critical failure, manual intervention


class ExecutionStatus(str, Enum):
    """Overall execution status."""
    SUCCESS = "success"
    PARTIAL = "partial"
    FAILED = "failed"
    BLOCKED = "blocked"


@dataclass
class RecoveryOption:
    """Option presented to user for recovery."""
    label: str
    description: str
    action: str  # "resume", "re_execute", "manual_read", "skip"
    agent_id: Optional[str] = None
    params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class VerificationResult:
    """Result of verifying subagent output."""
    agent_id: str
    agent_type: str
    is_complete: bool
    is_summary_only: bool
    summary_indicators: List[str] = field(default_factory=list)
    content: Optional[str] = None
    layer_accessed: Optional[OutputLayer] = None
    decision: RecoveryDecision = RecoveryDecision.COMPLETE


@dataclass
class PhaseResult:
    """Result of executing a single phase."""
    phase_number: int
    phase_name: str
    status: ExecutionStatus
    agent_ids: List[str] = field(default_factory=list)
    verifications: List[VerificationResult] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    recovery_required: bool = False
    recovery_options: List[RecoveryOption] = field(default_factory=list)


@dataclass
class ExecutionResult:
    """Result of executing a full plan."""
    plan_path: str
    status: ExecutionStatus
    phases_completed: int
    phases_total: int
    phase_results: List[PhaseResult] = field(default_factory=list)
    blocked_at_phase: Optional[int] = None
    summary: str = ""


# =============================================================================
# ExecutionOrchestrator Class
# =============================================================================

class ExecutionOrchestrator:
    """
    Facade orchestrating plan execution with automatic verification.

    Composes:
    - OutputLayerManager: Result verification and layer access
    - ContextBudgetManager: Pre-delegation budget checks
    - TaskDecomposer: Large task splitting for 32K compliance
    - AgentRegistry: Agent lifecycle tracking
    - PlanFile: Plan state persistence

    Main Agent Interface:
    - execute_plan(plan_path) -> ExecutionResult
    - execute_phase(phase_num) -> PhaseResult
    - verify_result(result, agent_id) -> VerificationResult
    - recovery_gate(result) -> bool (True = proceed, False = blocked)
    """

    def __init__(
        self,
        session_id: Optional[str] = None,
        thinking_mode: ThinkingMode = ThinkingMode.STANDARD,
        output_dir: str = ".agent/outputs",
        log_dir: str = ".agent/logs",
    ):
        """
        Initialize ExecutionOrchestrator.

        Args:
            session_id: Optional session identifier for tracking
            thinking_mode: Context budget mode (STANDARD, EXTENDED, ULTRATHINK)
            output_dir: Directory for L2/L3 outputs
            log_dir: Directory for logs
        """
        self.session_id = session_id or datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        self.thinking_mode = thinking_mode
        self.output_dir = output_dir
        self.log_dir = log_dir

        # Composed modules (lazy initialization)
        self._output_manager: Optional[OutputLayerManager] = None
        self._budget_manager: Optional[ContextBudgetManager] = None
        self._task_decomposer: Optional[TaskDecomposer] = None
        self._agent_registry: Optional[AgentRegistry] = None

        # Current plan state
        self._plan: Optional[PlanFile] = None
        self._current_phase: Optional[int] = None
        self._retry_counts: Dict[str, int] = {}  # agent_id -> retry count
        self._max_retries: int = 3

        # Ensure directories exist
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        Path(log_dir).mkdir(parents=True, exist_ok=True)

        logger.info(f"ExecutionOrchestrator initialized: session={self.session_id}, mode={thinking_mode}")

    # =========================================================================
    # Properties - Lazy Module Initialization
    # =========================================================================

    @property
    def output_manager(self) -> OutputLayerManager:
        """Get or create OutputLayerManager."""
        if self._output_manager is None:
            self._output_manager = get_output_manager()
        return self._output_manager

    @property
    def budget_manager(self) -> ContextBudgetManager:
        """Get or create ContextBudgetManager."""
        if self._budget_manager is None:
            self._budget_manager = get_session_manager(
                session_id=self.session_id,
                thinking_mode=self.thinking_mode,
            )
        return self._budget_manager

    @property
    def task_decomposer(self) -> TaskDecomposer:
        """Get or create TaskDecomposer."""
        if self._task_decomposer is None:
            self._task_decomposer = TaskDecomposer()
        return self._task_decomposer

    @property
    def agent_registry(self) -> AgentRegistry:
        """Get or create AgentRegistry."""
        if self._agent_registry is None:
            self._agent_registry = get_registry()
        return self._agent_registry

    @property
    def plan(self) -> Optional[PlanFile]:
        """Current loaded plan."""
        return self._plan

    # =========================================================================
    # Plan Management
    # =========================================================================

    def load_plan(self, path: str) -> PlanFile:
        """
        Load plan from file.

        Args:
            path: Path to plan markdown file

        Returns:
            Loaded PlanFile instance
        """
        self._plan = load_plan(path)
        self._plan.set_status(PlanStatus.IN_PROGRESS)
        self._plan.save()
        logger.info(f"Loaded plan: {self._plan.title} ({len(self._plan.phases)} phases)")
        return self._plan

    def sync_plan_file(self) -> None:
        """Write current plan state to file."""
        if self._plan and self._plan.path:
            self._plan.save()
            logger.debug(f"Plan file synced: {self._plan.path}")

    def get_pending_phases(self) -> List[Phase]:
        """Get list of phases not yet completed."""
        if not self._plan:
            return []
        return [p for p in self._plan.phases if p.status != PhaseStatus.COMPLETED]

    def get_current_phase(self) -> Optional[Phase]:
        """Get currently executing phase."""
        if not self._plan or self._current_phase is None:
            return None
        for phase in self._plan.phases:
            if phase.number == self._current_phase:
                return phase
        return None

    # =========================================================================
    # Pre-Delegation Checks
    # =========================================================================

    def check_before_delegation(
        self,
        task: str,
        subagent_type: SubagentType,
        scope: Optional[str] = None,
    ) -> Tuple[DelegationDecision, List[SubTask]]:
        """
        Check if delegation is safe and decompose if needed.

        Args:
            task: Task description
            subagent_type: Target subagent type
            scope: Optional scope path for decomposition check

        Returns:
            Tuple of (decision, subtasks)
            - If PROCEED: subtasks is empty or single task
            - If REDUCE_SCOPE: subtasks contains decomposed tasks
            - If DEFER/ABORT: subtasks is empty
        """
        # Check context budget
        estimated_tokens = self._estimate_task_tokens(task, subagent_type)
        budget_decision = check_context_before_task(subagent_type.value, estimated_tokens)

        if budget_decision in [DelegationDecision.DEFER, DelegationDecision.ABORT]:
            logger.warning(f"Context budget check: {budget_decision.value}")
            return budget_decision, []

        # Check if decomposition needed
        if scope and should_decompose_task(task, scope):
            subtasks = self.task_decomposer.decompose(task, scope, subagent_type)
            logger.info(f"Task decomposed into {len(subtasks)} subtasks")
            return DelegationDecision.REDUCE_SCOPE, subtasks

        # Single task, safe to proceed
        return DelegationDecision.PROCEED, []

    def _estimate_task_tokens(self, task: str, subagent_type: SubagentType) -> int:
        """Estimate token count for a task."""
        # Base estimate from task description
        base = len(task.split()) * 2  # Rough word-to-token ratio

        # Add budget overhead by subagent type
        budgets = {
            SubagentType.EXPLORE: 5000,
            SubagentType.PLAN: 10000,
            SubagentType.GENERAL_PURPOSE: 15000,
        }
        return base + budgets.get(subagent_type, 10000)

    # =========================================================================
    # Result Verification (Step 6)
    # =========================================================================

    def verify_result(
        self,
        result: str,
        agent_id: str,
        agent_type: str = "general-purpose",
    ) -> VerificationResult:
        """
        Verify subagent result for completeness.

        Uses is_summary_only() to detect headline-only output,
        then attempts L2/L3 recovery if needed.

        Args:
            result: Raw result string from subagent
            agent_id: Agent identifier
            agent_type: Subagent type for layer access

        Returns:
            VerificationResult with decision
        """
        verification = VerificationResult(
            agent_id=agent_id,
            agent_type=agent_type,
            is_complete=False,
            is_summary_only=False,
        )

        # Check if summary-only
        summary_only, indicators = is_summary_only(result)
        verification.is_summary_only = summary_only
        verification.summary_indicators = indicators

        if not summary_only:
            # Result is complete
            verification.is_complete = True
            verification.content = result
            verification.decision = RecoveryDecision.COMPLETE
            logger.info(f"Result verification: COMPLETE for {agent_id}")
            return verification

        # Attempt L2/L3 recovery
        logger.info(f"Result verification: Summary-only detected for {agent_id}, attempting recovery")

        try:
            layer, content = read_layer_auto(agent_id, agent_type)

            if layer == OutputLayer.L2_STRUCTURED:
                verification.content = content
                verification.layer_accessed = OutputLayer.L2_STRUCTURED
                verification.is_complete = True
                verification.decision = RecoveryDecision.L2_RECOVERED
                logger.info(f"Result verification: L2_RECOVERED for {agent_id}")

            elif layer == OutputLayer.L3_RAW:
                verification.content = content
                verification.layer_accessed = OutputLayer.L3_RAW
                verification.is_complete = True
                verification.decision = RecoveryDecision.L3_RECOVERED
                logger.info(f"Result verification: L3_RECOVERED for {agent_id}")

            else:
                # No recovery possible
                verification.decision = RecoveryDecision.NEEDS_REDELEGATION
                logger.warning(f"Result verification: NEEDS_REDELEGATION for {agent_id}")

        except Exception as e:
            logger.error(f"Result verification error: {e}")
            verification.decision = RecoveryDecision.NEEDS_REDELEGATION

        return verification

    # =========================================================================
    # Recovery Gate (Step 7)
    # =========================================================================

    def recovery_gate(self, phase_result: PhaseResult) -> bool:
        """
        Recovery gate - BLOCKING check before proceeding.

        Args:
            phase_result: Result from execute_phase()

        Returns:
            True if can proceed, False if BLOCKED
        """
        if not phase_result.recovery_required:
            # All verifications passed
            self._update_phase_completed(phase_result.phase_number)
            return True

        # Check retry counts
        for verification in phase_result.verifications:
            if verification.decision == RecoveryDecision.NEEDS_REDELEGATION:
                agent_id = verification.agent_id
                self._retry_counts[agent_id] = self._retry_counts.get(agent_id, 0) + 1

                if self._retry_counts[agent_id] >= self._max_retries:
                    logger.error(f"Max retries ({self._max_retries}) exceeded for {agent_id}")
                    phase_result.status = ExecutionStatus.BLOCKED
                    phase_result.recovery_options = self._generate_recovery_options(verification)
                    self._log_recovery_event(phase_result)
                    return False

        # Generate recovery options
        phase_result.recovery_options = []
        for verification in phase_result.verifications:
            if verification.decision == RecoveryDecision.NEEDS_REDELEGATION:
                phase_result.recovery_options.extend(
                    self._generate_recovery_options(verification)
                )

        self._log_recovery_event(phase_result)
        return False

    def _generate_recovery_options(self, verification: VerificationResult) -> List[RecoveryOption]:
        """Generate recovery options for failed verification."""
        options = []

        # Option 1: Resume with previous agent ID
        if can_resume_agent(verification.agent_id):
            options.append(RecoveryOption(
                label="Resume",
                description=f"Continue from where {verification.agent_id} left off",
                action="resume",
                agent_id=verification.agent_id,
            ))

        # Option 2: Re-execute
        options.append(RecoveryOption(
            label="Re-execute",
            description="Start fresh with a new subagent",
            action="re_execute",
            params={"agent_type": verification.agent_type},
        ))

        # Option 3: Manual read
        options.append(RecoveryOption(
            label="Manual Read",
            description="Read output file manually and provide content",
            action="manual_read",
            params={"output_path": f".agent/outputs/{verification.agent_id}/"},
        ))

        # Option 4: Skip (if non-critical)
        options.append(RecoveryOption(
            label="Skip",
            description="Skip this task and proceed (may cause issues)",
            action="skip",
        ))

        return options

    def _update_phase_completed(self, phase_num: int) -> None:
        """Mark phase as completed and sync plan file."""
        if self._plan:
            self._plan.update_phase_status(phase_num, PhaseStatus.COMPLETED)
            self.sync_plan_file()
            logger.info(f"Phase {phase_num} marked as COMPLETED")

    def _log_recovery_event(self, phase_result: PhaseResult) -> None:
        """Log recovery event to file."""
        log_path = Path(self.log_dir) / "recovery_gate.log"

        with open(log_path, "a") as f:
            f.write(f"\n{'='*60}\n")
            f.write(f"Timestamp: {datetime.now(timezone.utc).isoformat()}\n")
            f.write(f"Session: {self.session_id}\n")
            f.write(f"Phase: {phase_result.phase_number} - {phase_result.phase_name}\n")
            f.write(f"Status: {phase_result.status.value}\n")
            f.write(f"Recovery Required: {phase_result.recovery_required}\n")

            for v in phase_result.verifications:
                if v.decision == RecoveryDecision.NEEDS_REDELEGATION:
                    f.write(f"\nAgent: {v.agent_id}\n")
                    f.write(f"  Decision: {v.decision.value}\n")
                    f.write(f"  Indicators: {v.summary_indicators}\n")
                    f.write(f"  Retries: {self._retry_counts.get(v.agent_id, 0)}\n")

            f.write(f"\nRecovery Options:\n")
            for opt in phase_result.recovery_options:
                f.write(f"  - {opt.label}: {opt.description}\n")

    # =========================================================================
    # Phase Execution
    # =========================================================================

    def execute_phase(self, phase_num: int) -> PhaseResult:
        """
        Execute a single phase.

        Note: This method prepares the phase for execution but does NOT
        actually invoke Task() - that must be done by the Main Agent.

        This returns the delegation parameters and tracks the execution.

        Args:
            phase_num: Phase number to execute

        Returns:
            PhaseResult with execution status
        """
        if not self._plan:
            return PhaseResult(
                phase_number=phase_num,
                phase_name="Unknown",
                status=ExecutionStatus.FAILED,
                errors=["No plan loaded. Call load_plan() first."],
            )

        # Find phase
        phase = None
        for p in self._plan.phases:
            if p.number == phase_num:
                phase = p
                break

        if not phase:
            return PhaseResult(
                phase_number=phase_num,
                phase_name="Unknown",
                status=ExecutionStatus.FAILED,
                errors=[f"Phase {phase_num} not found in plan."],
            )

        self._current_phase = phase_num
        self._plan.update_phase_status(phase_num, PhaseStatus.IN_PROGRESS)
        self.sync_plan_file()

        result = PhaseResult(
            phase_number=phase_num,
            phase_name=phase.name,
            status=ExecutionStatus.SUCCESS,
        )

        logger.info(f"Executing Phase {phase_num}: {phase.name}")

        # Check pre-delegation
        task_desc = f"{phase.goal}: {', '.join(t.description for t in phase.tasks)}"
        scope = phase.files_affected[0] if phase.files_affected else None

        decision, subtasks = self.check_before_delegation(
            task=task_desc,
            subagent_type=SubagentType.GENERAL_PURPOSE,
            scope=scope,
        )

        if decision == DelegationDecision.ABORT:
            result.status = ExecutionStatus.BLOCKED
            result.errors.append("Context budget exceeded - cannot delegate")
            result.recovery_required = True
            return result

        if decision == DelegationDecision.DEFER:
            result.status = ExecutionStatus.BLOCKED
            result.errors.append("Context budget high - consider /compact before proceeding")
            result.recovery_required = True
            return result

        # Note: Actual Task() invocation happens in Main Agent
        # This method returns the preparation result
        return result

    def get_delegation_params(
        self,
        phase_num: int,
        subagent_type: str = "general-purpose",
    ) -> Dict[str, Any]:
        """
        Get Task() parameters for delegating a phase.

        Args:
            phase_num: Phase number
            subagent_type: Subagent type to use

        Returns:
            Dict of parameters for Task() tool
        """
        if not self._plan:
            return {}

        phase = None
        for p in self._plan.phases:
            if p.number == phase_num:
                phase = p
                break

        if not phase:
            return {}

        # Build prompt with output budget constraint
        budget = self._get_budget_for_type(subagent_type)
        task_list = "\n".join(f"- {t.description}" for t in phase.tasks)
        files_list = "\n".join(f"- {f}" for f in phase.files_affected) if phase.files_affected else "N/A"

        prompt = f"""## Phase {phase.number}: {phase.name}

### Goal
{phase.goal}

### Tasks
{task_list}

### Files Affected
{files_list}

### Constraint: Output Budget
YOUR OUTPUT MUST NOT EXCEED {budget} TOKENS.
Return ONLY: Key findings, implementation results, summary.
DO NOT include: Full file contents, verbose explanations.
Format: Bullet points with file:line references.

### Evidence Required
- files_modified: [must populate with actual files changed]
- verification_results: [test results, lint results]
- summary: [key findings in bullet points]
"""

        return {
            "subagent_type": subagent_type,
            "prompt": prompt,
            "description": f"Phase {phase.number}: {phase.name[:30]}",
            "run_in_background": True,
        }

    def _get_budget_for_type(self, subagent_type: str) -> int:
        """Get token budget for subagent type."""
        budgets = {
            "explore": 5000,
            "plan": 10000,
            "general-purpose": 15000,
        }

        # ULTRATHINK mode increases budgets
        if self.thinking_mode == ThinkingMode.ULTRATHINK:
            budgets = {
                "explore": 15000,
                "plan": 25000,
                "general-purpose": 32000,
            }

        return budgets.get(subagent_type.lower(), 15000)

    # =========================================================================
    # Full Plan Execution
    # =========================================================================

    def execute_plan(self, plan_path: str) -> ExecutionResult:
        """
        Execute a full plan.

        Note: This method orchestrates phases but actual Task() calls
        must be made by the Main Agent.

        Args:
            plan_path: Path to plan markdown file

        Returns:
            ExecutionResult with overall status
        """
        self.load_plan(plan_path)

        result = ExecutionResult(
            plan_path=plan_path,
            status=ExecutionStatus.SUCCESS,
            phases_completed=0,
            phases_total=len(self._plan.phases),
        )

        for phase in self._plan.phases:
            phase_result = self.execute_phase(phase.number)
            result.phase_results.append(phase_result)

            if phase_result.status in [ExecutionStatus.BLOCKED, ExecutionStatus.FAILED]:
                result.status = ExecutionStatus.PARTIAL
                result.blocked_at_phase = phase.number
                break

            # Recovery gate check
            if not self.recovery_gate(phase_result):
                result.status = ExecutionStatus.BLOCKED
                result.blocked_at_phase = phase.number
                break

            result.phases_completed += 1

        # Final status
        if result.phases_completed == result.phases_total:
            result.status = ExecutionStatus.SUCCESS
            self._plan.set_status(PlanStatus.COMPLETED)
        else:
            self._plan.set_status(PlanStatus.BLOCKED)

        self.sync_plan_file()
        result.summary = self._generate_summary(result)
        return result

    def _generate_summary(self, result: ExecutionResult) -> str:
        """Generate human-readable summary."""
        lines = [
            f"Plan: {self._plan.title if self._plan else 'Unknown'}",
            f"Status: {result.status.value}",
            f"Progress: {result.phases_completed}/{result.phases_total} phases",
        ]

        if result.blocked_at_phase:
            lines.append(f"Blocked at: Phase {result.blocked_at_phase}")

        return "\n".join(lines)

    # =========================================================================
    # Agent Registration
    # =========================================================================

    def register_agent(
        self,
        agent_id: str,
        phase_num: int,
        subagent_type: str,
    ) -> None:
        """
        Register an agent for tracking.

        Args:
            agent_id: Agent identifier from Task() result
            phase_num: Phase number this agent is executing
            subagent_type: Type of subagent
        """
        task_desc = f"Phase {phase_num}"
        if self._plan:
            for p in self._plan.phases:
                if p.number == phase_num:
                    task_desc = f"Phase {phase_num}: {p.name}"
                    p.agent_id = agent_id
                    break

        # Register in agent registry
        register_agent(
            agent_id=agent_id,
            agent_type=subagent_type,
            description=task_desc,
            session_id=self.session_id,
        )

        # Add to plan file
        if self._plan:
            self._plan.add_agent(
                agent_id=agent_id,
                task=task_desc,
                status=PlanAgentStatus.IN_PROGRESS,
                resume_eligible=True,
            )
            self.sync_plan_file()

        logger.info(f"Registered agent: {agent_id} for {task_desc}")


# =============================================================================
# Factory Function - Session-Scoped Orchestrators
# =============================================================================

_orchestrators: Dict[str, ExecutionOrchestrator] = {}


def get_orchestrator(
    session_id: Optional[str] = None,
    thinking_mode: ThinkingMode = ThinkingMode.STANDARD,
    force_new: bool = False,
) -> ExecutionOrchestrator:
    """
    Get or create session-scoped ExecutionOrchestrator.

    Args:
        session_id: Optional session identifier
        thinking_mode: Context budget mode
        force_new: Force creation of new instance

    Returns:
        ExecutionOrchestrator instance
    """
    global _orchestrators

    key = session_id or "default"

    if force_new or key not in _orchestrators:
        _orchestrators[key] = ExecutionOrchestrator(
            session_id=session_id,
            thinking_mode=thinking_mode,
        )
        logger.info(f"Created new orchestrator: {key}")

    return _orchestrators[key]


def reset_orchestrator(session_id: Optional[str] = None) -> None:
    """Reset orchestrator for session."""
    global _orchestrators
    key = session_id or "default"
    if key in _orchestrators:
        del _orchestrators[key]
        logger.info(f"Reset orchestrator: {key}")


# =============================================================================
# Module Exports
# =============================================================================

__all__ = [
    # Enums
    "RecoveryDecision",
    "ExecutionStatus",
    # Dataclasses
    "RecoveryOption",
    "VerificationResult",
    "PhaseResult",
    "ExecutionResult",
    # Main Class
    "ExecutionOrchestrator",
    # Factory Functions
    "get_orchestrator",
    "reset_orchestrator",
]
