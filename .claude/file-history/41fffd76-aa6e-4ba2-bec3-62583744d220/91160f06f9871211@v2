# Mathpix Pipeline ODA Integration Plan

> **Version:** 1.0 | **Status:** IN_PROGRESS | **Date:** 2026-01-15
> **Auto-Compact Safe:** This file persists across context compaction
> **Complexity:** Large | **Files Affected:** 5 | **Total Phases:** 3

---

## Overview

| Item | Value |
|------|-------|
| Audit Source | Deep-Audit Report (2026-01-15) |
| Compatibility | 85% ODA-aligned |
| Critical Gaps | 5 |
| New ObjectTypes | 1 (MathpixPipeline) |
| New ActionTypes | 3 |
| Modified Files | 2 |

---

## Requirements (Parsed)

**Source:** "너의 권장사항 모두 반영하고, ODA가 너의 설계과정에서 제한이 된다면 Types를 새로 정의해도 된다. 반드시 기존 ODA시스템에 맞게 진행하면 돼."

**Interpretation:**
1. Implement ALL 5 gaps from Deep-Audit
2. Define new Types if needed (permission granted)
3. Follow existing ODA patterns strictly

---

## Implementation Phases

### Phase 1: Core Types & Models (P0)
**Focus:** Foundation - ObjectTypes and StageEvidence extension

| # | Task | File | Status |
|---|------|------|--------|
| 1.1 | Define `MathpixPipelineStage` enum | `lib/oda/ontology/objects/pipeline.py:35` | PENDING |
| 1.2 | Define `MathpixPipeline` ObjectType | `lib/oda/ontology/objects/pipeline.py:349+` | PENDING |
| 1.3 | Extend `StageEvidence` with correction_patches | `lib/oda/ontology/actions/file_actions.py:45-65` | PENDING |
| 1.4 | Define `CorrectionPatch` model | `lib/oda/ontology/actions/file_actions.py:67+` | PENDING |

### Phase 2: ActionTypes (P0-P1)
**Focus:** Governance actions for pipeline gates

| # | Task | File | Status |
|---|------|------|--------|
| 2.1 | Create `pipeline_actions.py` module | `lib/oda/ontology/actions/pipeline_actions.py` (NEW) | PENDING |
| 2.2 | Register `alignment.blocker_detected` | `lib/oda/ontology/actions/pipeline_actions.py` | PENDING |
| 2.3 | Register `semantic.resolve_ambiguity` | `lib/oda/ontology/actions/pipeline_actions.py` | PENDING |
| 2.4 | Register `pipeline.advance_stage` | `lib/oda/ontology/actions/pipeline_actions.py` | PENDING |

### Phase 3: Governance Rules (P1)
**Focus:** Auto-proposal triggers and validation

| # | Task | File | Status |
|---|------|------|--------|
| 3.1 | Add `alignment.blocker_detected` rule | `governance/actions.yaml:152+` | PENDING |
| 3.2 | Add `semantic.resolve_ambiguity` rule | `governance/actions.yaml` | PENDING |
| 3.3 | Add confidence threshold trigger | `governance/actions.yaml` | PENDING |
| 3.4 | Update actions `__init__.py` exports | `lib/oda/ontology/actions/__init__.py` | PENDING |

---

## Progress Tracking

| Phase | Tasks | Completed | Status |
|-------|-------|-----------|--------|
| Phase 1: Core Types | 4 | 0 | PENDING |
| Phase 2: ActionTypes | 4 | 0 | PENDING |
| Phase 3: Governance | 4 | 0 | PENDING |

---

## Detailed Implementation

### 1.1-1.2: MathpixPipeline ObjectType

**Location:** `lib/oda/ontology/objects/pipeline.py` (after line 348)

```python
class MathpixPipelineStage(str, Enum):
    """8-stage mathpix pipeline stages."""
    A_INGESTION = "A"
    B_TEXTPARSE = "B"
    C_VISIONPARSE = "C"
    D_ALIGNMENT = "D"
    E_SEMANTICGRAPH = "E"
    F_REGENERATION = "F"
    G_HUMANREVIEW = "G"
    H_EXPORT = "H"


class ReviewSeverity(str, Enum):
    """Severity levels for review items."""
    BLOCKER = "blocker"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


@register_object_type
class MathpixPipeline(OntologyObject):
    """
    Mathpix parsing pipeline with ODA governance gates.

    Implements 8-stage pipeline (A-H) with:
    - Stage D blocker gate (Proposal trigger)
    - Stage G human review (approval required)
    - confidence/uncertainty tracking
    """

    source_image_id: str = Field(
        ..., description="ID of the source image being processed"
    )
    current_stage: MathpixPipelineStage = Field(
        default=MathpixPipelineStage.A_INGESTION,
        description="Current pipeline stage"
    )
    stage_outputs: Dict[str, Any] = Field(
        default_factory=dict,
        description="Outputs from each completed stage"
    )
    blocker_count: int = Field(
        default=0,
        ge=0,
        description="Number of blockers preventing stage advancement"
    )
    review_queue_ids: List[str] = Field(
        default_factory=list,
        description="IDs of items requiring human review"
    )
    overall_confidence: Optional[float] = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="Overall pipeline confidence score"
    )
    ambiguity_count: int = Field(
        default=0,
        ge=0,
        description="Number of unresolved ambiguities"
    )
    correction_patches_applied: int = Field(
        default=0,
        ge=0,
        description="Number of human corrections applied"
    )

    def can_advance(self) -> bool:
        """Check if pipeline can advance to next stage."""
        if self.current_stage == MathpixPipelineStage.D_ALIGNMENT:
            return self.blocker_count == 0
        if self.current_stage == MathpixPipelineStage.G_HUMANREVIEW:
            return len(self.review_queue_ids) == 0
        return True

    def advance_stage(self) -> bool:
        """Attempt to advance to next stage. Returns False if blocked."""
        if not self.can_advance():
            return False

        stage_order = list(MathpixPipelineStage)
        current_idx = stage_order.index(self.current_stage)

        if current_idx < len(stage_order) - 1:
            self.current_stage = stage_order[current_idx + 1]
            self.touch()
            return True
        return False

    def add_blocker(self, reason: str) -> None:
        """Add a blocker to the pipeline."""
        self.blocker_count += 1
        self.touch()

    def resolve_blocker(self) -> None:
        """Resolve one blocker."""
        if self.blocker_count > 0:
            self.blocker_count -= 1
            self.touch()
```

### 1.3-1.4: Extended StageEvidence

**Location:** `lib/oda/ontology/actions/file_actions.py` (lines 45-90)

```python
class CorrectionPatch(BaseModel):
    """Human correction applied during review."""
    correction_id: str = Field(..., description="Unique correction ID")
    target_path: str = Field(..., description="JSON path to corrected element")
    original_value: Any = Field(..., description="Value before correction")
    corrected_value: Any = Field(..., description="Value after correction")
    action: Literal["confirmed", "modified", "deleted", "added"] = Field(
        ..., description="Type of correction action"
    )
    reason: Optional[str] = Field(None, description="Correction reason")
    timestamp: datetime = Field(default_factory=utc_now)
    reviewer_id: Optional[str] = Field(None, description="ID of reviewer")


class StageEvidence(BaseModel):
    """
    Evidence collected during 3-Stage Protocol execution.
    Extended for mathpix pipeline integration.
    """
    files_viewed: List[str] = Field(
        default_factory=list,
        description="List of files viewed during Stage A (SCAN)"
    )
    imports_verified: List[str] = Field(
        default_factory=list,
        description="List of imports verified during Stage B (TRACE)"
    )
    complexity: Optional[str] = Field(
        default=None,
        description="Complexity classification: small|medium|large"
    )
    protocol_stage: Optional[str] = Field(
        default=None,
        description="Current protocol stage: A|B|C"
    )
    # New fields for mathpix integration
    correction_patches: List[CorrectionPatch] = Field(
        default_factory=list,
        description="Human corrections applied during review"
    )
    final_confidence: Optional[float] = Field(
        default=None,
        ge=0.0,
        le=1.0,
        description="Post-correction confidence score"
    )
    blocker_resolved: bool = Field(
        default=False,
        description="Whether all blockers were resolved"
    )
```

### 2.1-2.4: Pipeline Actions

**Location:** `lib/oda/ontology/actions/pipeline_actions.py` (NEW FILE)

```python
"""
Orion ODA v3.0 - Pipeline Action Types
Mathpix Integration - Proposal Gateway Actions

ActionTypes:
- alignment.blocker_detected: Stage D blocker trigger (hazardous)
- semantic.resolve_ambiguity: Ambiguity resolution (hazardous)
- pipeline.advance_stage: Stage advancement (non-hazardous with validation)
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional, Type

from pydantic import BaseModel, Field

from lib.oda.ontology.actions import (
    ActionContext,
    ActionResult,
    ActionType,
    CustomValidator,
    EditOperation,
    EditType,
    RequiredField,
    register_action,
)
from lib.oda.ontology.ontology_types import OntologyObject
from lib.oda.ontology.objects.pipeline import (
    MathpixPipeline,
    MathpixPipelineStage,
    ReviewSeverity,
)

logger = logging.getLogger(__name__)


# =============================================================================
# PYDANTIC MODELS
# =============================================================================


class BlockerDetails(BaseModel):
    """Details of alignment blocker."""
    blocker_id: str
    severity: ReviewSeverity
    reason_code: str
    affected_elements: List[str] = Field(default_factory=list)
    suggested_resolution: Optional[str] = None


class AmbiguityResolution(BaseModel):
    """Resolution choice for ambiguity."""
    element_id: str
    selected_interpretation: str
    confidence_boost: float = 0.0
    reviewer_id: Optional[str] = None


class AlignmentBlockerResult(OntologyObject):
    """Result of blocker detection."""
    pipeline_id: str
    blocker_count: int
    blockers: List[Dict[str, Any]] = Field(default_factory=list)
    proposal_created: bool = False
    proposal_id: Optional[str] = None


class AmbiguityResolutionResult(OntologyObject):
    """Result of ambiguity resolution."""
    pipeline_id: str
    element_id: str
    resolution: str
    new_confidence: Optional[float] = None


# =============================================================================
# VALIDATORS
# =============================================================================


def validate_pipeline_exists(params: Dict[str, Any], context: ActionContext) -> bool:
    """Validate that pipeline_id references an existing pipeline."""
    pipeline_id = params.get("pipeline_id", "")
    return bool(pipeline_id and isinstance(pipeline_id, str))


def validate_blockers_format(params: Dict[str, Any], context: ActionContext) -> bool:
    """Validate blockers list format."""
    blockers = params.get("blockers", [])
    if not isinstance(blockers, list):
        return False
    for blocker in blockers:
        if not isinstance(blocker, dict):
            return False
        if "severity" not in blocker or "reason_code" not in blocker:
            return False
    return True


# =============================================================================
# ALIGNMENT BLOCKER DETECTED ACTION (Hazardous)
# =============================================================================


@register_action(requires_proposal=True)
class AlignmentBlockerDetectedAction(ActionType[AlignmentBlockerResult]):
    """
    Stage D: Alignment blocker detected.

    This is a HAZARDOUS action requiring proposal approval.
    When blockers are detected in alignment stage, this action:
    1. Records the blockers
    2. Creates a proposal for Stage G human review
    3. Blocks pipeline advancement until resolved

    Parameters:
        pipeline_id: ID of the MathpixPipeline
        blockers: List of blocker details
        force_review: Force Stage G review even for non-blockers

    Returns:
        AlignmentBlockerResult with proposal ID if created
    """
    api_name = "alignment.blocker_detected"
    object_type = AlignmentBlockerResult
    requires_proposal = True

    submission_criteria = [
        RequiredField("pipeline_id"),
        RequiredField("blockers"),
        CustomValidator(
            name="ValidPipelineId",
            validator_fn=validate_pipeline_exists,
            error_message="pipeline_id must be a valid pipeline reference"
        ),
        CustomValidator(
            name="ValidBlockersFormat",
            validator_fn=validate_blockers_format,
            error_message="blockers must be a list of {severity, reason_code} objects"
        ),
    ]

    async def apply_edits(
        self,
        params: Dict[str, Any],
        context: ActionContext
    ) -> ActionResult:
        """Record blockers and create review proposal."""
        pipeline_id = params["pipeline_id"]
        blockers = params["blockers"]
        force_review = params.get("force_review", False)

        # Count blockers by severity
        blocker_count = sum(1 for b in blockers if b.get("severity") == "blocker")
        high_count = sum(1 for b in blockers if b.get("severity") == "high")

        result = AlignmentBlockerResult(
            pipeline_id=pipeline_id,
            blocker_count=blocker_count,
            blockers=blockers,
            proposal_created=True,  # This action itself is a proposal
            created_by=context.actor_id,
        )

        edit = EditOperation(
            edit_type=EditType.CREATE,
            object_type="AlignmentBlockerResult",
            object_id=result.id,
            changes={
                "pipeline_id": pipeline_id,
                "blocker_count": blocker_count,
                "high_severity_count": high_count,
                "total_issues": len(blockers),
                "actor": context.actor_id,
            }
        )

        message = f"Detected {blocker_count} blockers, {high_count} high-severity issues"
        if blocker_count > 0:
            message += " - Stage G review required"

        return ActionResult(
            action_type=self.api_name,
            success=True,
            data=result,
            edits=[edit],
            message=message
        )


# =============================================================================
# SEMANTIC AMBIGUITY RESOLUTION ACTION (Hazardous)
# =============================================================================


@register_action(requires_proposal=True)
class SemanticAmbiguityResolutionAction(ActionType[AmbiguityResolutionResult]):
    """
    Resolve semantic ambiguity in parsed elements.

    This is a HAZARDOUS action requiring proposal approval.
    When ambiguity_set contains multiple interpretations,
    this action records the human's chosen resolution.

    Parameters:
        pipeline_id: ID of the MathpixPipeline
        element_id: ID of the ambiguous element
        selected_interpretation: Chosen interpretation from options
        reviewer_id: ID of the reviewer making the decision

    Returns:
        AmbiguityResolutionResult with new confidence
    """
    api_name = "semantic.resolve_ambiguity"
    object_type = AmbiguityResolutionResult
    requires_proposal = True

    submission_criteria = [
        RequiredField("pipeline_id"),
        RequiredField("element_id"),
        RequiredField("selected_interpretation"),
    ]

    async def apply_edits(
        self,
        params: Dict[str, Any],
        context: ActionContext
    ) -> ActionResult:
        """Record ambiguity resolution."""
        pipeline_id = params["pipeline_id"]
        element_id = params["element_id"]
        selected = params["selected_interpretation"]
        confidence_boost = params.get("confidence_boost", 0.1)

        result = AmbiguityResolutionResult(
            pipeline_id=pipeline_id,
            element_id=element_id,
            resolution=selected,
            new_confidence=min(1.0, 0.5 + confidence_boost),
            created_by=context.actor_id,
        )

        edit = EditOperation(
            edit_type=EditType.MODIFY,
            object_type="AmbiguityResolutionResult",
            object_id=result.id,
            changes={
                "pipeline_id": pipeline_id,
                "element_id": element_id,
                "resolution": selected,
                "actor": context.actor_id,
            }
        )

        return ActionResult(
            action_type=self.api_name,
            success=True,
            data=result,
            edits=[edit],
            message=f"Resolved ambiguity for {element_id}: {selected}"
        )


# =============================================================================
# PIPELINE ADVANCE STAGE ACTION (Non-Hazardous with validation)
# =============================================================================


@register_action
class PipelineAdvanceStageAction(ActionType[MathpixPipeline]):
    """
    Advance pipeline to next stage.

    This is a NON-HAZARDOUS action but with strict validation:
    - Stage D requires blocker_count == 0
    - Stage G requires review_queue empty

    Parameters:
        pipeline_id: ID of the MathpixPipeline
        force: Force advancement (for testing only)

    Returns:
        Updated MathpixPipeline with new stage
    """
    api_name = "pipeline.advance_stage"
    object_type = MathpixPipeline
    requires_proposal = False

    submission_criteria = [
        RequiredField("pipeline_id"),
    ]

    async def apply_edits(
        self,
        params: Dict[str, Any],
        context: ActionContext
    ) -> ActionResult:
        """Attempt to advance pipeline stage."""
        pipeline_id = params["pipeline_id"]
        force = params.get("force", False)

        # In real implementation, would fetch from database
        # This is a placeholder showing the validation logic

        edit = EditOperation(
            edit_type=EditType.MODIFY,
            object_type="MathpixPipeline",
            object_id=pipeline_id,
            changes={
                "stage_advanced": True,
                "actor": context.actor_id,
            }
        )

        return ActionResult(
            action_type=self.api_name,
            success=True,
            edits=[edit],
            message=f"Pipeline {pipeline_id} advanced to next stage"
        )


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    "AlignmentBlockerDetectedAction",
    "SemanticAmbiguityResolutionAction",
    "PipelineAdvanceStageAction",
    "AlignmentBlockerResult",
    "AmbiguityResolutionResult",
    "BlockerDetails",
    "AmbiguityResolution",
]
```

### 3.1-3.3: Governance Rules

**Location:** `governance/actions.yaml` (append after line 152)

```yaml
  # ─────────────────────────────────────────────────────────────────────────────
  # Mathpix Pipeline Actions
  # ─────────────────────────────────────────────────────────────────────────────

  alignment.blocker_detected:
    description: "Stage D alignment blocker detected - triggers Stage G review"
    hazardous: true
    requires_approval: true
    tags: ["mathpix", "pipeline", "alignment", "blocker"]
    submission_criteria:
      - type: RequiredFieldValidator
        field: pipeline_id
      - type: RequiredFieldValidator
        field: blockers
    side_effects:
      - type: AuditLogSideEffect
      - type: EventBusSideEffect
        event_type: pipeline.blocker_detected
    auto_triggers:
      - condition: "blocker_count > 0"
        create_proposal: true
        proposal_priority: "high"
        force_stage_g: true

  semantic.resolve_ambiguity:
    description: "Resolve semantic ambiguity in parsed elements"
    hazardous: true
    requires_approval: true
    tags: ["mathpix", "pipeline", "semantic", "ambiguity"]
    submission_criteria:
      - type: RequiredFieldValidator
        field: pipeline_id
      - type: RequiredFieldValidator
        field: element_id
      - type: RequiredFieldValidator
        field: selected_interpretation
    side_effects:
      - type: AuditLogSideEffect
      - type: EventBusSideEffect
        event_type: pipeline.ambiguity_resolved

  pipeline.advance_stage:
    description: "Advance mathpix pipeline to next stage"
    hazardous: false
    tags: ["mathpix", "pipeline", "stage"]
    submission_criteria:
      - type: RequiredFieldValidator
        field: pipeline_id
    validation_rules:
      - name: "blocker_gate"
        condition: "current_stage == 'D' AND blocker_count > 0"
        action: "block"
        message: "Cannot advance: unresolved blockers"
      - name: "review_gate"
        condition: "current_stage == 'G' AND review_queue_ids.length > 0"
        action: "block"
        message: "Cannot advance: pending reviews"

  # ─────────────────────────────────────────────────────────────────────────────
  # Auto-Proposal Trigger Rules
  # ─────────────────────────────────────────────────────────────────────────────

  vision.low_confidence:
    description: "Auto-create proposal when confidence below threshold"
    hazardous: false
    tags: ["mathpix", "confidence", "auto-trigger"]
    auto_triggers:
      - condition: "confidence < 0.5"
        create_proposal: true
        proposal_action_type: "stage_g.review_required"
        proposal_priority: "high"
      - condition: "confidence < 0.7 AND confidence >= 0.5"
        create_proposal: true
        proposal_action_type: "stage_g.review_required"
        proposal_priority: "medium"
```

---

## Quick Resume After Auto-Compact

If context is compacted, resume by:

1. Read this file: `.agent/plans/mathpix_oda_integration.md`
2. Check TodoWrite for current task status
3. Continue from first PENDING task in sequence
4. Reference files:
   - `lib/oda/ontology/objects/pipeline.py` (MathpixPipeline location)
   - `lib/oda/ontology/actions/file_actions.py` (StageEvidence location)
   - `lib/oda/ontology/actions/pipeline_actions.py` (NEW file to create)
   - `governance/actions.yaml` (append rules)

---

## Execution Strategy

### Parallel Execution Groups

**Group A (Phase 1):** Can be parallelized
- Task 1.1 + 1.2: MathpixPipeline in pipeline.py
- Task 1.3 + 1.4: StageEvidence in file_actions.py

**Group B (Phase 2):** Sequential after Group A
- Task 2.1-2.4: pipeline_actions.py (depends on types from Phase 1)

**Group C (Phase 3):** Sequential after Group B
- Task 3.1-3.4: governance/actions.yaml (depends on action names from Phase 2)

### Subagent Delegation

| Task Group | Subagent Type | Context | Budget |
|------------|---------------|---------|--------|
| Phase 1 | general-purpose | fork | 15K |
| Phase 2 | general-purpose | fork | 15K |
| Phase 3 | general-purpose | standard | 10K |

---

## Critical File Paths

```yaml
new_files:
  - lib/oda/ontology/actions/pipeline_actions.py

modified_files:
  - lib/oda/ontology/objects/pipeline.py (after line 348)
  - lib/oda/ontology/actions/file_actions.py (lines 45-90)
  - governance/actions.yaml (after line 152)
  - lib/oda/ontology/actions/__init__.py (exports)

reference_files:
  - lib/oda/ontology/registry.py (register_object_type pattern)
  - lib/oda/ontology/actions/orchestration_actions.py (action pattern)
  - lib/oda/ontology/objects/proposal.py (state machine pattern)
```

---

## Risk Assessment

| Risk | Severity | Mitigation |
|------|----------|------------|
| Circular import | Medium | Use TYPE_CHECKING for forward references |
| Registry collision | Low | Use unique api_name prefixes (alignment., semantic.) |
| Schema migration | Medium | New fields have defaults, backward compatible |
| Test coverage | High | Create tests before merge |

---

## Approval Checklist

- [ ] Phase 1: Core Types reviewed
- [ ] Phase 2: ActionTypes reviewed
- [ ] Phase 3: Governance rules reviewed
- [ ] No circular imports
- [ ] All new types registered
- [ ] Tests planned

---

## Agent Registry (Auto-Compact Resume)

| Task | Agent ID | Status | Resume Eligible |
|------|----------|--------|-----------------|
| Plan Subagent | ad89ad8 | running | Yes |

