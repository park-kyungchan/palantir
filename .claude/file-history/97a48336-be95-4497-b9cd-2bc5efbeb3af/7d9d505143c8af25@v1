"""
Text-Visual Matcher for Stage D (Alignment).

Matches text elements (from Stage B) with visual elements (from Stage C):
- Spatial matching: bbox overlap between text and visual elements
- Semantic matching: content similarity (equation ↔ curve)
- Label matching: point labels, axis labels, etc.

Schema Version: 2.0.0
"""

import logging
import re
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Tuple

from ..schemas import (
    BBox,
    Confidence,
    EquationElement,
    LineSegment,
    MatchedPair,
    MatchType,
    MergedElement,
    TextElement,
    TextSpec,
    VisualElement,
    VisionSpec,
)
from ..utils.geometry import calculate_iou

logger = logging.getLogger(__name__)


# =============================================================================
# Configuration
# =============================================================================

@dataclass
class MatcherConfig:
    """Configuration for text-visual matcher."""
    # Spatial matching
    min_iou_threshold: float = 0.1  # Minimum IoU for spatial match
    proximity_threshold_px: int = 50  # Max distance for proximity match

    # Semantic matching
    equation_curve_weight: float = 0.7  # Weight for equation-curve matching
    label_point_weight: float = 0.8  # Weight for label-point matching

    # Matching strategy
    allow_many_to_one: bool = False  # Allow multiple text to match one visual
    prefer_exact_match: bool = True  # Prefer exact label matches


# =============================================================================
# Matching Strategies
# =============================================================================

class SpatialMatcher:
    """Matches elements based on spatial overlap."""

    def __init__(self, config: MatcherConfig):
        self.config = config

    def calculate_overlap(self, bbox1: BBox, bbox2: BBox) -> float:
        """Calculate IoU between two bboxes."""
        return calculate_iou(bbox1, bbox2)

    def calculate_proximity(self, bbox1: BBox, bbox2: BBox) -> float:
        """Calculate proximity score (inverse of distance).

        Returns 1.0 if adjacent, decreasing with distance.
        """
        # Calculate center points
        cx1 = bbox1.x + bbox1.width / 2
        cy1 = bbox1.y + bbox1.height / 2
        cx2 = bbox2.x + bbox2.width / 2
        cy2 = bbox2.y + bbox2.height / 2

        # Euclidean distance
        distance = ((cx1 - cx2) ** 2 + (cy1 - cy2) ** 2) ** 0.5

        # Convert to score (1.0 at distance=0, 0.0 at threshold)
        if distance >= self.config.proximity_threshold_px:
            return 0.0
        return 1.0 - (distance / self.config.proximity_threshold_px)


class SemanticMatcher:
    """Matches elements based on semantic similarity."""

    # Equation patterns for curve matching
    CURVE_PATTERNS = {
        "linear": re.compile(r"y\s*=\s*[+-]?\d*\.?\d*\s*x(?:\s*[+-]\s*\d+)?"),
        "quadratic": re.compile(r"x\^2|x²"),
        "cubic": re.compile(r"x\^3|x³"),
        "sine": re.compile(r"sin\s*\(|\\sin"),
        "cosine": re.compile(r"cos\s*\(|\\cos"),
        "exponential": re.compile(r"e\^|\\exp"),
        "logarithm": re.compile(r"log|\\ln|\\log"),
    }

    # Point label patterns
    POINT_LABEL_PATTERN = re.compile(r"^[A-Z]$|^P_?\d*$|^Q_?\d*$")

    def match_equation_to_curve(
        self,
        equation: str,
        curve_type: Optional[str],
    ) -> float:
        """Calculate match score between equation and curve type.

        Args:
            equation: LaTeX or text equation
            curve_type: Detected curve type from vision

        Returns:
            Match score (0.0-1.0)
        """
        if not equation or not curve_type:
            return 0.0

        equation_lower = equation.lower()

        # Check each curve pattern
        for pattern_type, pattern in self.CURVE_PATTERNS.items():
            if pattern.search(equation) or pattern.search(equation_lower):
                # Check if detected curve type matches
                if pattern_type in curve_type.lower():
                    return 0.95
                elif "function" in curve_type.lower():
                    return 0.7  # Generic function match

        return 0.3  # Low confidence match

    def match_label_to_point(
        self,
        label_text: str,
        point_label: Optional[str],
    ) -> float:
        """Calculate match score between text label and point label.

        Args:
            label_text: Text content
            point_label: Point label from vision

        Returns:
            Match score (0.0-1.0)
        """
        if not label_text or not point_label:
            return 0.0

        # Exact match
        if label_text.strip() == point_label.strip():
            return 1.0

        # Case-insensitive match
        if label_text.strip().upper() == point_label.strip().upper():
            return 0.95

        # Partial match (e.g., "Point A" matches "A")
        if point_label.strip() in label_text:
            return 0.8

        return 0.0

    def match_coordinate_reference(
        self,
        text: str,
        coordinates: Optional[Dict[str, float]],
    ) -> float:
        """Match coordinate references in text to visual coordinates.

        Args:
            text: Text that might contain coordinates
            coordinates: Visual element coordinates

        Returns:
            Match score (0.0-1.0)
        """
        if not text or not coordinates:
            return 0.0

        # Extract numbers from text
        numbers = re.findall(r"-?\d+\.?\d*", text)
        if len(numbers) < 2:
            return 0.0

        # Try to match as (x, y)
        try:
            parsed = [float(n) for n in numbers[:2]]
            x, y = parsed[0], parsed[1]

            if "x" in coordinates and "y" in coordinates:
                x_match = abs(x - coordinates["x"]) < 0.5
                y_match = abs(y - coordinates["y"]) < 0.5

                if x_match and y_match:
                    return 0.95
                elif x_match or y_match:
                    return 0.6
        except (ValueError, IndexError):
            pass

        return 0.0


# =============================================================================
# Text-Visual Matcher
# =============================================================================

class TextVisualMatcher:
    """Matches text elements with visual elements.

    Combines spatial and semantic matching strategies to create
    matched pairs for alignment.

    Usage:
        config = MatcherConfig()
        matcher = TextVisualMatcher(config)

        matches = matcher.match(text_spec, vision_spec, image_id)
    """

    def __init__(self, config: Optional[MatcherConfig] = None):
        """Initialize matcher.

        Args:
            config: Matcher configuration
        """
        self.config = config or MatcherConfig()
        self.spatial = SpatialMatcher(self.config)
        self.semantic = SemanticMatcher()

    def _extract_text_elements(self, text_spec: TextSpec) -> List[TextElement]:
        """Extract matchable text elements from TextSpec.

        Args:
            text_spec: Stage B output

        Returns:
            List of TextElement for matching
        """
        elements: List[TextElement] = []

        # From equations
        for idx, eq in enumerate(text_spec.equations):
            elements.append(TextElement(
                id=eq.id,
                content=eq.latex,
                latex=eq.latex,
                bbox=eq.bbox,
                source_line_id=None,
            ))

        # From line segments
        for seg in text_spec.line_segments:
            elements.append(TextElement(
                id=seg.id,
                content=seg.text,
                latex=seg.latex,
                bbox=seg.bbox,
                source_line_id=seg.id,
            ))

        return elements

    def _extract_visual_elements(self, vision_spec: VisionSpec) -> List[VisualElement]:
        """Extract matchable visual elements from VisionSpec.

        Args:
            vision_spec: Stage C output

        Returns:
            List of VisualElement for matching
        """
        elements: List[VisualElement] = []

        for merged in vision_spec.merged_output.elements:
            elements.append(VisualElement(
                id=merged.id,
                element_class=merged.element_class.value,
                semantic_label=merged.semantic_label,
                bbox=merged.bbox,
                source_merged_id=merged.id,
            ))

        return elements

    def _calculate_match_score(
        self,
        text_elem: TextElement,
        visual_elem: VisualElement,
    ) -> Tuple[float, MatchType]:
        """Calculate combined match score and determine match type.

        Args:
            text_elem: Text element
            visual_elem: Visual element

        Returns:
            Tuple of (score, match_type)
        """
        scores: List[Tuple[float, MatchType, float]] = []  # (score, type, weight)

        # Spatial matching (if bbox available)
        if text_elem.bbox and visual_elem.bbox:
            iou = self.spatial.calculate_overlap(text_elem.bbox, visual_elem.bbox)
            proximity = self.spatial.calculate_proximity(text_elem.bbox, visual_elem.bbox)
            spatial_score = max(iou, proximity * 0.7)

            if spatial_score > 0:
                scores.append((spatial_score, MatchType.LABEL_TO_POINT, 0.3))

        # Semantic matching based on element types
        visual_class = visual_elem.element_class.lower()

        # Equation to curve
        if text_elem.latex and "curve" in visual_class:
            eq_score = self.semantic.match_equation_to_curve(
                text_elem.latex,
                visual_elem.semantic_label
            )
            if eq_score > 0:
                scores.append((eq_score, MatchType.EQUATION_TO_GRAPH, self.config.equation_curve_weight))

        # Label to point
        if "point" in visual_class or "label" in visual_class:
            label_score = self.semantic.match_label_to_point(
                text_elem.content,
                visual_elem.semantic_label
            )
            if label_score > 0:
                scores.append((label_score, MatchType.LABEL_TO_POINT, self.config.label_point_weight))

        # Axis label
        if "axis" in visual_class:
            if text_elem.content in ["x", "y", "X", "Y"]:
                scores.append((0.9, MatchType.AXIS_LABEL, 0.8))
            elif "axis" in text_elem.content.lower():
                scores.append((0.7, MatchType.AXIS_LABEL, 0.6))

        # No matches found
        if not scores:
            return 0.0, MatchType.DESCRIPTION_TO_ELEMENT

        # Calculate weighted average, using highest match type
        best = max(scores, key=lambda x: x[0] * x[2])
        return best[0], best[1]

    def match(
        self,
        text_spec: TextSpec,
        vision_spec: VisionSpec,
        image_id: str,
        base_threshold: float = 0.6,
    ) -> List[MatchedPair]:
        """Match text and visual elements.

        Args:
            text_spec: Stage B output
            vision_spec: Stage C output
            image_id: Image identifier
            base_threshold: Base threshold for match acceptance

        Returns:
            List of MatchedPair
        """
        text_elements = self._extract_text_elements(text_spec)
        visual_elements = self._extract_visual_elements(vision_spec)

        matched_pairs: List[MatchedPair] = []
        used_visual_ids: set = set()
        match_idx = 0

        # For each text element, find best visual match
        for text_elem in text_elements:
            best_match: Optional[Tuple[VisualElement, float, MatchType]] = None
            best_score = 0.0

            for visual_elem in visual_elements:
                # Skip if already used (unless many-to-one allowed)
                if visual_elem.id in used_visual_ids and not self.config.allow_many_to_one:
                    continue

                score, match_type = self._calculate_match_score(text_elem, visual_elem)

                if score > best_score:
                    best_score = score
                    best_match = (visual_elem, score, match_type)

            # Create matched pair if score above minimum
            if best_match and best_score >= self.config.min_iou_threshold:
                visual_elem, score, match_type = best_match

                matched_pair = MatchedPair(
                    id=f"{image_id}-match-{match_idx:03d}",
                    match_type=match_type,
                    text_element=text_elem,
                    visual_element=visual_elem,
                    consistency_score=score,
                    confidence=Confidence(
                        value=score,
                        source="alignment-matcher",
                    ),
                    applied_threshold=base_threshold,
                    spatial_overlap=self.spatial.calculate_overlap(
                        text_elem.bbox, visual_elem.bbox
                    ) if text_elem.bbox else None,
                    semantic_similarity=score,
                )

                matched_pairs.append(matched_pair)
                used_visual_ids.add(visual_elem.id)
                match_idx += 1

                logger.debug(
                    f"Matched {text_elem.id} -> {visual_elem.id} "
                    f"(score={score:.2f}, type={match_type.value})"
                )

        return matched_pairs

    def get_unmatched(
        self,
        text_spec: TextSpec,
        vision_spec: VisionSpec,
        matched_pairs: List[MatchedPair],
    ) -> Tuple[List[TextElement], List[VisualElement]]:
        """Get elements that were not matched.

        Args:
            text_spec: Stage B output
            vision_spec: Stage C output
            matched_pairs: Already matched pairs

        Returns:
            Tuple of (unmatched_text, unmatched_visual)
        """
        matched_text_ids = {p.text_element.id for p in matched_pairs}
        matched_visual_ids = {p.visual_element.id for p in matched_pairs}

        unmatched_text = [
            elem for elem in self._extract_text_elements(text_spec)
            if elem.id not in matched_text_ids
        ]
        unmatched_visual = [
            elem for elem in self._extract_visual_elements(vision_spec)
            if elem.id not in matched_visual_ids
        ]

        return unmatched_text, unmatched_visual


# =============================================================================
# Export
# =============================================================================

__all__ = [
    "MatcherConfig",
    "SpatialMatcher",
    "SemanticMatcher",
    "TextVisualMatcher",
]
