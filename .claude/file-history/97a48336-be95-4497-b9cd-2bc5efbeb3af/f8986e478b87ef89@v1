"""
Alignment Engine for Stage D.

Main orchestrator that combines:
- Text-Visual matching
- Consistency checking
- Inconsistency detection
- Threshold application

Produces AlignmentReport as output.

Schema Version: 2.0.0
"""

import logging
import time
from dataclasses import dataclass
from typing import List, Optional, Tuple

from ..schemas import (
    AlignmentReport,
    AlignmentStatistics,
    Confidence,
    Inconsistency,
    MatchedPair,
    Provenance,
    PipelineStage,
    ReviewMetadata,
    ReviewSeverity,
    TextElement,
    TextSpec,
    UnmatchedElement,
    VisualElement,
    VisionSpec,
)
from ..schemas.threshold import (
    ThresholdConfig,
    ThresholdContext,
    FeedbackStats,
    compute_effective_threshold,
)
from .matcher import MatcherConfig, TextVisualMatcher
from .consistency import ConsistencyConfig, ConsistencyChecker
from .inconsistency import InconsistencyConfig, InconsistencyDetector

logger = logging.getLogger(__name__)


# =============================================================================
# Configuration
# =============================================================================

@dataclass
class AlignmentEngineConfig:
    """Configuration for alignment engine."""
    # Component configs
    matcher_config: MatcherConfig = None
    consistency_config: ConsistencyConfig = None
    inconsistency_config: InconsistencyConfig = None

    # Threshold settings
    base_alignment_threshold: float = 0.60
    base_inconsistency_threshold: float = 0.80

    # Processing settings
    enable_threshold_adjustment: bool = True
    enable_auto_fix_detection: bool = True

    def __post_init__(self):
        """Initialize default configs if not provided."""
        if self.matcher_config is None:
            self.matcher_config = MatcherConfig()
        if self.consistency_config is None:
            self.consistency_config = ConsistencyConfig()
        if self.inconsistency_config is None:
            self.inconsistency_config = InconsistencyConfig()


# =============================================================================
# Alignment Engine
# =============================================================================

class AlignmentEngine:
    """Main alignment engine for Stage D.

    Orchestrates the alignment process:
    1. Match text elements to visual elements
    2. Check consistency of matched pairs
    3. Detect inconsistencies
    4. Apply thresholds and determine review requirements
    5. Generate AlignmentReport

    Usage:
        config = AlignmentEngineConfig()
        engine = AlignmentEngine(config)

        report = engine.align(text_spec, vision_spec)
    """

    def __init__(
        self,
        config: Optional[AlignmentEngineConfig] = None,
        threshold_config: Optional[ThresholdConfig] = None,
    ):
        """Initialize alignment engine.

        Args:
            config: Engine configuration
            threshold_config: Threshold calibration configuration
        """
        self.config = config or AlignmentEngineConfig()
        self.threshold_config = threshold_config

        # Initialize components
        self.matcher = TextVisualMatcher(self.config.matcher_config)
        self.consistency_checker = ConsistencyChecker(self.config.consistency_config)
        self.inconsistency_detector = InconsistencyDetector(self.config.inconsistency_config)

    def _get_effective_threshold(
        self,
        element_type: str,
        context: Optional[ThresholdContext] = None,
        feedback_stats: Optional[FeedbackStats] = None,
    ) -> float:
        """Get effective threshold for element type.

        Args:
            element_type: Type of element (e.g., 'alignment_match')
            context: Optional threshold context
            feedback_stats: Optional feedback statistics

        Returns:
            Effective threshold value
        """
        if not self.config.enable_threshold_adjustment or not self.threshold_config:
            return self.config.base_alignment_threshold

        if context is None:
            context = ThresholdContext()
        if feedback_stats is None:
            feedback_stats = FeedbackStats()

        return compute_effective_threshold(
            element_type=element_type,
            config=self.threshold_config,
            context=context,
            feedback_stats=feedback_stats,
        )

    def _create_unmatched_elements(
        self,
        unmatched_text: List[TextElement],
        unmatched_visual: List[VisualElement],
        image_id: str,
    ) -> List[UnmatchedElement]:
        """Create UnmatchedElement list from unmatched elements.

        Args:
            unmatched_text: Text elements without match
            unmatched_visual: Visual elements without match
            image_id: Image identifier

        Returns:
            List of UnmatchedElement
        """
        unmatched: List[UnmatchedElement] = []

        for text_elem in unmatched_text:
            unmatched.append(UnmatchedElement(
                id=f"{image_id}-unmatched-text-{text_elem.id}",
                source="text",
                element_id=text_elem.id,
                content=text_elem.content,
                bbox=text_elem.bbox,
                reason="No matching visual element found",
            ))

        for visual_elem in unmatched_visual:
            unmatched.append(UnmatchedElement(
                id=f"{image_id}-unmatched-visual-{visual_elem.id}",
                source="visual",
                element_id=visual_elem.id,
                content=visual_elem.semantic_label,
                bbox=visual_elem.bbox,
                reason="No matching text element found",
            ))

        return unmatched

    def _compute_overall_alignment_score(
        self,
        matched_pairs: List[MatchedPair],
        inconsistencies: List[Inconsistency],
        unmatched_count: int,
        total_elements: int,
    ) -> float:
        """Compute overall alignment score.

        Args:
            matched_pairs: All matched pairs
            inconsistencies: All inconsistencies
            unmatched_count: Number of unmatched elements
            total_elements: Total number of elements

        Returns:
            Overall score (0.0-1.0)
        """
        if total_elements == 0:
            return 0.0

        # Base score from matched pairs
        if matched_pairs:
            avg_consistency = sum(p.consistency_score for p in matched_pairs) / len(matched_pairs)
        else:
            avg_consistency = 0.0

        # Penalty for unmatched elements
        unmatched_penalty = unmatched_count / max(total_elements, 1) * 0.3

        # Penalty for inconsistencies
        blocker_count = sum(1 for i in inconsistencies if i.severity == ReviewSeverity.BLOCKER)
        high_count = sum(1 for i in inconsistencies if i.severity == ReviewSeverity.HIGH)

        inconsistency_penalty = (blocker_count * 0.2) + (high_count * 0.1)

        # Calculate final score
        score = avg_consistency - unmatched_penalty - inconsistency_penalty

        return max(0.0, min(1.0, score))

    def align(
        self,
        text_spec: TextSpec,
        vision_spec: VisionSpec,
        context: Optional[ThresholdContext] = None,
        feedback_stats: Optional[FeedbackStats] = None,
    ) -> AlignmentReport:
        """Perform alignment between text and visual specifications.

        Args:
            text_spec: Stage B output
            vision_spec: Stage C output
            context: Optional threshold context
            feedback_stats: Optional feedback statistics

        Returns:
            AlignmentReport with alignment results
        """
        start_time = time.time()
        image_id = text_spec.image_id

        logger.info(f"Starting alignment for {image_id}")

        # Get effective thresholds
        alignment_threshold = self._get_effective_threshold(
            "alignment_match", context, feedback_stats
        )
        inconsistency_threshold = self._get_effective_threshold(
            "inconsistency", context, feedback_stats
        )

        # Step 1: Match text and visual elements
        matched_pairs = self.matcher.match(
            text_spec=text_spec,
            vision_spec=vision_spec,
            image_id=image_id,
            base_threshold=alignment_threshold,
        )

        logger.debug(f"Found {len(matched_pairs)} matched pairs")

        # Get unmatched elements
        unmatched_text, unmatched_visual = self.matcher.get_unmatched(
            text_spec, vision_spec, matched_pairs
        )

        # Step 2: Check consistency
        self.consistency_checker.check_all(matched_pairs)

        # Step 3: Detect inconsistencies
        inconsistencies = self.inconsistency_detector.detect_all(
            matched_pairs=matched_pairs,
            unmatched_text=unmatched_text,
            unmatched_visual=unmatched_visual,
            image_id=image_id,
        )

        logger.debug(f"Detected {len(inconsistencies)} inconsistencies")

        # Step 4: Create unmatched elements list
        unmatched_elements = self._create_unmatched_elements(
            unmatched_text, unmatched_visual, image_id
        )

        # Step 5: Compute overall scores
        total_text = len(text_spec.equations) + len(text_spec.line_segments)
        total_visual = len(vision_spec.merged_output.elements)
        total_elements = total_text + total_visual

        overall_alignment_score = self._compute_overall_alignment_score(
            matched_pairs=matched_pairs,
            inconsistencies=inconsistencies,
            unmatched_count=len(unmatched_elements),
            total_elements=total_elements,
        )

        overall_confidence = self.consistency_checker.compute_overall_score(matched_pairs)

        # Step 6: Build statistics
        statistics = AlignmentStatistics(
            total_text_elements=total_text,
            total_visual_elements=total_visual,
            matched_pairs=len(matched_pairs),
            inconsistencies_found=len(inconsistencies),
            unmatched_text=len(unmatched_text),
            unmatched_visual=len(unmatched_visual),
            pairs_above_threshold=len([p for p in matched_pairs if p.threshold_passed]),
            pairs_below_threshold=len([p for p in matched_pairs if not p.threshold_passed]),
        )

        if matched_pairs:
            scores = [p.consistency_score for p in matched_pairs]
            statistics.avg_consistency_score = sum(scores) / len(scores)
            statistics.min_consistency_score = min(scores)
            statistics.max_consistency_score = max(scores)

        # Step 7: Create provenance
        processing_time_ms = (time.time() - start_time) * 1000

        provenance = Provenance(
            stage=PipelineStage.ALIGNMENT,
            model="alignment-engine-v2",
            processing_time_ms=processing_time_ms,
        )

        # Step 8: Build AlignmentReport
        report = AlignmentReport(
            image_id=image_id,
            text_spec_id=text_spec.image_id,
            vision_spec_id=vision_spec.image_id,
            provenance=provenance,
            matched_pairs=matched_pairs,
            inconsistencies=inconsistencies,
            unmatched_elements=unmatched_elements,
            statistics=statistics,
            threshold_config_version="2.0.0",
            base_alignment_threshold=alignment_threshold,
            base_inconsistency_threshold=inconsistency_threshold,
            overall_alignment_score=overall_alignment_score,
            overall_confidence=overall_confidence,
            processing_time_ms=processing_time_ms,
        )

        logger.info(
            f"Alignment complete for {image_id}: "
            f"score={overall_alignment_score:.2f}, "
            f"pairs={len(matched_pairs)}, "
            f"inconsistencies={len(inconsistencies)}"
        )

        return report


# =============================================================================
# Convenience Functions
# =============================================================================

def create_alignment_engine(
    config: Optional[AlignmentEngineConfig] = None,
    threshold_config: Optional[ThresholdConfig] = None,
) -> AlignmentEngine:
    """Factory function to create alignment engine.

    Args:
        config: Optional engine configuration
        threshold_config: Optional threshold configuration

    Returns:
        Configured AlignmentEngine instance
    """
    return AlignmentEngine(config, threshold_config)


def align_text_and_vision(
    text_spec: TextSpec,
    vision_spec: VisionSpec,
    config: Optional[AlignmentEngineConfig] = None,
) -> AlignmentReport:
    """Convenience function to perform alignment.

    Args:
        text_spec: Stage B output
        vision_spec: Stage C output
        config: Optional engine configuration

    Returns:
        AlignmentReport
    """
    engine = AlignmentEngine(config)
    return engine.align(text_spec, vision_spec)


# =============================================================================
# Export
# =============================================================================

__all__ = [
    "AlignmentEngineConfig",
    "AlignmentEngine",
    "create_alignment_engine",
    "align_text_and_vision",
]
