"""
Consistency Checker for Stage D (Alignment).

Validates consistency between matched text and visual elements:
- Equation-graph consistency (e.g., y=x² matches parabola)
- Coordinate consistency (text coordinates match visual positions)
- Label consistency (text labels match visual labels)

Schema Version: 2.0.0
"""

import logging
import re
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from ..schemas import (
    MatchedPair,
    MatchType,
    ReviewMetadata,
    ReviewSeverity,
)

logger = logging.getLogger(__name__)


# =============================================================================
# Configuration
# =============================================================================

@dataclass
class ConsistencyConfig:
    """Configuration for consistency checker."""
    # Equation-graph thresholds
    equation_graph_strict: float = 0.9  # Very strict for blocker
    equation_graph_normal: float = 0.7  # Normal threshold

    # Coordinate thresholds
    coordinate_tolerance_px: float = 10.0  # Pixel tolerance
    coordinate_tolerance_rel: float = 0.1  # Relative tolerance (10%)

    # Label thresholds
    label_exact_bonus: float = 0.2  # Bonus for exact match

    # Weighting
    spatial_weight: float = 0.3
    semantic_weight: float = 0.7


# =============================================================================
# Consistency Calculators
# =============================================================================

class EquationGraphConsistency:
    """Check consistency between equations and graph elements."""

    # Function type mapping
    EQUATION_TO_CURVE = {
        "linear": ["linear", "line", "straight"],
        "quadratic": ["parabola", "quadratic", "u-shaped"],
        "cubic": ["cubic", "s-shaped"],
        "sine": ["sine", "sinusoidal", "wave"],
        "cosine": ["cosine", "sinusoidal", "wave"],
        "exponential": ["exponential", "exp", "growth"],
        "logarithmic": ["logarithm", "log", "ln"],
    }

    def infer_equation_type(self, latex: str) -> Optional[str]:
        """Infer equation type from LaTeX.

        Args:
            latex: LaTeX equation string

        Returns:
            Equation type or None
        """
        if not latex:
            return None

        latex_lower = latex.lower()

        # Check patterns
        if re.search(r"x\^3|x³", latex):
            return "cubic"
        if re.search(r"x\^2|x²", latex):
            return "quadratic"
        if re.search(r"\\sin|sin\s*\(", latex_lower):
            return "sine"
        if re.search(r"\\cos|cos\s*\(", latex_lower):
            return "cosine"
        if re.search(r"e\^|\\exp", latex):
            return "exponential"
        if re.search(r"\\log|\\ln|log\s*\(|ln\s*\(", latex_lower):
            return "logarithmic"
        if re.search(r"y\s*=\s*[+-]?\d*\.?\d*\s*x(?:\s*[+-]\s*\d+)?$", latex):
            return "linear"

        return None

    def check_consistency(
        self,
        equation_latex: str,
        curve_label: str,
    ) -> float:
        """Check if equation matches curve type.

        Args:
            equation_latex: LaTeX equation
            curve_label: Semantic label of curve

        Returns:
            Consistency score (0.0-1.0)
        """
        eq_type = self.infer_equation_type(equation_latex)
        if not eq_type:
            return 0.5  # Uncertain

        curve_lower = curve_label.lower()

        # Check if curve matches expected types
        expected_curves = self.EQUATION_TO_CURVE.get(eq_type, [])
        for expected in expected_curves:
            if expected in curve_lower:
                return 0.95

        # Partial match (generic function)
        if "function" in curve_lower or "curve" in curve_lower:
            return 0.7

        return 0.3  # Mismatch


class CoordinateConsistency:
    """Check consistency of coordinate references."""

    def __init__(self, config: ConsistencyConfig):
        self.config = config

    def extract_coordinates(self, text: str) -> Optional[Tuple[float, float]]:
        """Extract (x, y) coordinates from text.

        Args:
            text: Text that might contain coordinates

        Returns:
            (x, y) tuple or None
        """
        # Pattern: (x, y), [x, y], x=1 y=2, etc.
        patterns = [
            r"\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)",
            r"\[\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\]",
            r"x\s*=\s*(-?\d+\.?\d*)\s*,?\s*y\s*=\s*(-?\d+\.?\d*)",
        ]

        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                try:
                    return (float(match.group(1)), float(match.group(2)))
                except ValueError:
                    continue

        return None

    def check_consistency(
        self,
        text_coords: Optional[Tuple[float, float]],
        visual_coords: Optional[Dict[str, float]],
    ) -> float:
        """Check if text coordinates match visual coordinates.

        Args:
            text_coords: Coordinates extracted from text
            visual_coords: Coordinates from visual element

        Returns:
            Consistency score (0.0-1.0)
        """
        if not text_coords or not visual_coords:
            return 0.5  # Cannot verify

        if "x" not in visual_coords or "y" not in visual_coords:
            return 0.5

        tx, ty = text_coords
        vx, vy = visual_coords["x"], visual_coords["y"]

        # Calculate differences
        dx = abs(tx - vx)
        dy = abs(ty - vy)

        # Check against tolerances
        rel_x = dx / max(abs(vx), 1.0)
        rel_y = dy / max(abs(vy), 1.0)

        if dx <= self.config.coordinate_tolerance_px and dy <= self.config.coordinate_tolerance_px:
            return 0.95  # Pixel-level match

        if rel_x <= self.config.coordinate_tolerance_rel and rel_y <= self.config.coordinate_tolerance_rel:
            return 0.85  # Relative tolerance match

        # Some match
        if rel_x <= 0.3 and rel_y <= 0.3:
            return 0.6

        return 0.2  # Significant mismatch


class LabelConsistency:
    """Check consistency of labels."""

    def __init__(self, config: ConsistencyConfig):
        self.config = config

    def normalize_label(self, label: str) -> str:
        """Normalize label for comparison.

        Args:
            label: Raw label text

        Returns:
            Normalized label
        """
        # Remove whitespace, convert to uppercase
        return re.sub(r"\s+", "", label).upper()

    def check_consistency(
        self,
        text_label: str,
        visual_label: str,
    ) -> float:
        """Check if text label matches visual label.

        Args:
            text_label: Label from text
            visual_label: Label from visual element

        Returns:
            Consistency score (0.0-1.0)
        """
        if not text_label or not visual_label:
            return 0.5

        norm_text = self.normalize_label(text_label)
        norm_visual = self.normalize_label(visual_label)

        # Exact match
        if norm_text == norm_visual:
            return 1.0 + self.config.label_exact_bonus

        # Substring match
        if norm_text in norm_visual or norm_visual in norm_text:
            return 0.85

        # First character match (for point labels)
        if len(norm_text) >= 1 and len(norm_visual) >= 1:
            if norm_text[0] == norm_visual[0]:
                return 0.7

        return 0.2


# =============================================================================
# Consistency Checker
# =============================================================================

class ConsistencyChecker:
    """Main consistency checker for matched pairs.

    Validates that matched text and visual elements are semantically
    consistent with each other.

    Usage:
        config = ConsistencyConfig()
        checker = ConsistencyChecker(config)

        updated_pairs = checker.check_all(matched_pairs)
    """

    def __init__(self, config: Optional[ConsistencyConfig] = None):
        """Initialize checker.

        Args:
            config: Consistency configuration
        """
        self.config = config or ConsistencyConfig()
        self.eq_graph = EquationGraphConsistency()
        self.coords = CoordinateConsistency(self.config)
        self.labels = LabelConsistency(self.config)

    def check_pair(self, pair: MatchedPair) -> float:
        """Check consistency for a single matched pair.

        Args:
            pair: Matched pair to check

        Returns:
            Consistency score (0.0-1.0)
        """
        scores: List[Tuple[float, float]] = []  # (score, weight)

        # Use existing score as baseline
        scores.append((pair.consistency_score, 0.3))

        match_type = pair.match_type
        text_elem = pair.text_element
        visual_elem = pair.visual_element

        # Equation to graph
        if match_type == MatchType.EQUATION_TO_GRAPH:
            if text_elem.latex:
                eq_score = self.eq_graph.check_consistency(
                    text_elem.latex,
                    visual_elem.semantic_label
                )
                scores.append((eq_score, self.config.semantic_weight))

        # Label matching
        elif match_type in (MatchType.LABEL_TO_POINT, MatchType.AXIS_LABEL):
            label_score = self.labels.check_consistency(
                text_elem.content,
                visual_elem.semantic_label
            )
            scores.append((label_score, self.config.semantic_weight))

        # Coordinate matching
        elif match_type == MatchType.COORDINATE_TO_POINT:
            text_coords = self.coords.extract_coordinates(text_elem.content)
            # Get coordinates from visual if available
            visual_coords = None  # Would need to extract from interpretation
            coord_score = self.coords.check_consistency(text_coords, visual_coords)
            scores.append((coord_score, self.config.semantic_weight))

        # Spatial consistency (if both have bbox)
        if text_elem.bbox and visual_elem.bbox:
            # Already captured in match score, use as additional signal
            if pair.spatial_overlap is not None:
                scores.append((pair.spatial_overlap, self.config.spatial_weight))

        # Calculate weighted average
        if not scores:
            return 0.5

        total_weight = sum(w for _, w in scores)
        weighted_sum = sum(s * w for s, w in scores)

        return min(weighted_sum / total_weight, 1.0)

    def check_all(
        self,
        matched_pairs: List[MatchedPair],
        update_in_place: bool = True,
    ) -> List[MatchedPair]:
        """Check consistency for all matched pairs.

        Args:
            matched_pairs: Pairs to check
            update_in_place: If True, update pair's consistency_score

        Returns:
            Updated matched pairs
        """
        for pair in matched_pairs:
            new_score = self.check_pair(pair)

            if update_in_place:
                # Update consistency score using object.__setattr__
                # to bypass validate_assignment and avoid recursion
                object.__setattr__(pair, "consistency_score", new_score)

                # Re-evaluate threshold
                if new_score < pair.applied_threshold:
                    object.__setattr__(pair, "threshold_passed", False)
                    object.__setattr__(pair.review, "review_required", True)

                    if new_score < 0.4:
                        object.__setattr__(pair.review, "review_severity", ReviewSeverity.HIGH)
                    else:
                        object.__setattr__(pair.review, "review_severity", ReviewSeverity.MEDIUM)

                    object.__setattr__(
                        pair.review,
                        "review_reason",
                        f"Consistency score {new_score:.2f} below "
                        f"threshold {pair.applied_threshold:.2f}"
                    )

            logger.debug(
                f"Pair {pair.id}: score updated to {new_score:.2f} "
                f"(passed={pair.threshold_passed})"
            )

        return matched_pairs

    def compute_overall_score(self, matched_pairs: List[MatchedPair]) -> float:
        """Compute overall alignment consistency score.

        Args:
            matched_pairs: All matched pairs

        Returns:
            Overall score (0.0-1.0)
        """
        if not matched_pairs:
            return 0.0

        scores = [p.consistency_score for p in matched_pairs]
        return sum(scores) / len(scores)


# =============================================================================
# Export
# =============================================================================

__all__ = [
    "ConsistencyConfig",
    "EquationGraphConsistency",
    "CoordinateConsistency",
    "LabelConsistency",
    "ConsistencyChecker",
]
