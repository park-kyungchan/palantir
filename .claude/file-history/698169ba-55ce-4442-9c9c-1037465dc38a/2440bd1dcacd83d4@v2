#!/bin/bash
# Post-Task-Output Hook for L1/L2 Validation
#
# File: .claude/hooks/task-governance/post-task-output.sh
# Version: 2.3.0 (Progressive Disclosure)
#
# Triggered: After Task() returns
# Purpose:
#   1. Capture Agent ID for resume support
#   2. Log L1 summary with priority for later reference
#   3. Validate Progressive Disclosure compliance
#   4. Validate L1 format and L2 storage
#
# Exit codes:
#   0 - Validation passed (always - don't block execution)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Read JSON from stdin (PostToolUse provides full context)
INPUT=$(cat)

# Extract fields from input JSON
if command -v jq &>/dev/null; then
    TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // ""')
    AGENT_ID=$(echo "$INPUT" | jq -r '.tool_result.agent_id // ""')
    OUTPUT=$(echo "$INPUT" | jq -r '.tool_result.output // ""')
    SUBAGENT_TYPE=$(echo "$INPUT" | jq -r '.tool_input.subagent_type // "general-purpose"')
else
    # Fallback to environment variables
    TOOL_NAME="${TOOL_NAME:-Task}"
    AGENT_ID=""
    OUTPUT="${TOOL_OUTPUT:-}"
    SUBAGENT_TYPE="${TOOL_INPUT_SUBAGENT_TYPE:-general-purpose}"
fi

# Only process Task tool results
if [[ "$TOOL_NAME" != "Task" ]]; then
    echo '{}'
    exit 0
fi

# Log directories
mkdir -p .agent/logs 2>/dev/null || true
mkdir -p .agent/outputs 2>/dev/null || true

log_event() {
    local status="$1"
    local message="$2"
    echo "$(date -Iseconds) | POST_TASK | $SUBAGENT_TYPE | $status | $message" >> .agent/logs/l1l2_hooks.log 2>/dev/null || true
}

# Extract L1 Progressive Disclosure fields from output
extract_l1_field() {
    local output="$1"
    local field="$2"
    local default="${3:-}"
    echo "$output" | grep -oP "${field}:\\s*\\K[^\\n]+" | head -1 | tr -d "'" | tr -d '"' || echo "$default"
}

# Capture Agent ID and L1 fields for task execution log
log_task_execution() {
    local log_file=".agent/logs/task_execution.log"

    local task_id=$(extract_l1_field "$OUTPUT" "taskId" "unknown")
    local priority=$(extract_l1_field "$OUTPUT" "priority" "UNKNOWN")
    local status=$(extract_l1_field "$OUTPUT" "status" "unknown")
    local findings_count=$(extract_l1_field "$OUTPUT" "findingsCount" "0")
    local critical_count=$(extract_l1_field "$OUTPUT" "criticalCount" "0")

    cat >> "$log_file" <<EOF
---
timestamp: $(date -Iseconds)
agent_id: $AGENT_ID
task_id: $task_id
subagent_type: $SUBAGENT_TYPE
priority: $priority
status: $status
findings_count: $findings_count
critical_count: $critical_count
---
EOF
}

# Validation functions
validate_l1_format() {
    local output="$1"

    # Check for summary field
    if ! echo "$output" | grep -q "summary:"; then
        echo "FAIL: Missing 'summary' field in L1"
        return 1
    fi

    # Check for l2Index field
    if ! echo "$output" | grep -q "l2Index:"; then
        echo "FAIL: Missing 'l2Index' field in L1"
        return 1
    fi

    # Check for taskId field
    if ! echo "$output" | grep -q "taskId:"; then
        echo "FAIL: Missing 'taskId' field in L1"
        return 1
    fi

    # Check summary length (rough check - extract between quotes)
    local summary=$(echo "$output" | grep "summary:" | head -1 | sed 's/.*summary:[[:space:]]*//' | sed 's/"//g' | head -c 300)
    local summary_len=${#summary}
    if [[ $summary_len -gt 200 ]]; then
        echo "WARN: Summary exceeds 200 characters ($summary_len chars)"
        # Don't fail, just warn
    fi

    echo "PASS: L1 format validated"
    return 0
}

# V2.3.0: Validate Progressive Disclosure fields
validate_progressive_disclosure() {
    local output="$1"

    # Check for priority field (V2.3.0 required)
    if ! echo "$output" | grep -q "priority:"; then
        echo "WARN: Missing 'priority' field (V2.3.0 Progressive Disclosure)"
        return 0  # Warn but don't fail for backward compatibility
    fi

    local priority=$(extract_l1_field "$output" "priority" "")
    if [[ ! "$priority" =~ ^(CRITICAL|HIGH|MEDIUM|LOW)$ ]]; then
        echo "WARN: Invalid priority value: '$priority' (expected: CRITICAL|HIGH|MEDIUM|LOW)"
        return 0
    fi

    # Check recommendedRead for CRITICAL/HIGH priority
    if [[ "$priority" == "CRITICAL" || "$priority" == "HIGH" ]]; then
        if ! echo "$output" | grep -q "recommendedRead:"; then
            echo "WARN: Missing 'recommendedRead' for $priority priority task"
            return 0
        fi
    fi

    # Check l2Index has tokens estimates
    if echo "$output" | grep -q "l2Index:"; then
        if ! echo "$output" | grep -q "tokens:"; then
            echo "WARN: l2Index missing 'tokens' estimates (V2.3.0)"
            return 0
        fi
    fi

    echo "PASS: Progressive Disclosure fields validated"
    return 0
}

validate_l2_exists() {
  local output="$1"

  # Extract l2Path if present
  local l2_path=$(echo "$output" | grep "l2Path:" | head -1 | sed 's/.*l2Path:[[:space:]]*//' | sed 's/"//g' | tr -d "'")

  if [[ -z "$l2_path" ]]; then
    # Try to construct from agentType and taskId
    local agent_type=$(echo "$output" | grep "agentType:" | head -1 | sed 's/.*agentType:[[:space:]]*//' | sed 's/"//g' | tr -d "'")
    local task_id=$(echo "$output" | grep "taskId:" | head -1 | sed 's/.*taskId:[[:space:]]*//' | sed 's/"//g' | tr -d "'")

    if [[ -n "$agent_type" && -n "$task_id" ]]; then
      l2_path=".agent/outputs/${agent_type}/${task_id}.md"
    fi
  fi

  if [[ -z "$l2_path" ]]; then
    echo "WARN: Cannot determine L2 path"
    return 0  # Don't fail, L2 might be inline or not applicable
  fi

  if [[ -f "$l2_path" ]]; then
    echo "PASS: L2 file exists at $l2_path"
    return 0
  else
    echo "WARN: L2 file not found at $l2_path (may be created later)"
    return 0  # Don't fail, might be async
  fi
}

validate_anchor_consistency() {
  local output="$1"

  # Extract anchors from l2Index
  local anchors=$(echo "$output" | grep -E "anchor:" | sed 's/.*anchor:[[:space:]]*//' | sed 's/"//g' | tr -d "'" | tr '\n' ' ')

  if [[ -z "$anchors" ]]; then
    echo "PASS: No anchors to validate"
    return 0
  fi

  echo "PASS: Found anchors: $anchors"
  return 0
}

# Main validation
if [[ -z "$OUTPUT" ]]; then
    log_event "SKIP" "no_output"
    echo '{}'
    exit 0
fi

# Log task execution with Agent ID (for resume support)
log_task_execution

# Run validations
validate_l1_format "$OUTPUT"
L1_RESULT=$?

validate_progressive_disclosure "$OUTPUT"
PD_RESULT=$?

validate_l2_exists "$OUTPUT"
L2_RESULT=$?

validate_anchor_consistency "$OUTPUT"
ANCHOR_RESULT=$?

# Log results
if [[ $L1_RESULT -eq 0 && $L2_RESULT -eq 0 && $ANCHOR_RESULT -eq 0 && $PD_RESULT -eq 0 ]]; then
    log_event "PASS" "all_validations_passed"
else
    log_event "WARN" "validation_warnings"
fi

# Always return empty JSON and exit 0 (don't block execution)
echo '{}'
exit 0
