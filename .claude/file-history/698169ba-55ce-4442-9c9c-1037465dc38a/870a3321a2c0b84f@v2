#!/bin/bash
# L1/L2 Inject Hook - PreToolUse
#
# Version: 2.2.0
# Purpose:
#   1. Inject run_in_background=true for all Task() calls (updatedInput)
#   2. Inject L1/L2 output format prompt (additionalContext)
#
# Trigger: PreToolUse on Task tool
# Dependencies: jq (preferred) or python3 (fallback)
#
# Native Capabilities Used:
#   - updatedInput (V2.1.9): Modify tool parameters
#   - additionalContext (V2.1.9): Inject context to subagent prompt

set -euo pipefail

# JSON helper: use jq if available, else python3
json_get() {
    local json="$1"
    local path="$2"
    local default="${3:-}"

    if command -v jq &>/dev/null; then
        echo "$json" | jq -r "$path // \"$default\""
    else
        echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
path = '$path'.strip('.')
result = data
for key in path.split('.'):
    if key and isinstance(result, dict):
        result = result.get(key, '$default')
print(result if result else '$default')
"
    fi
}

json_stringify() {
    local text="$1"
    if command -v jq &>/dev/null; then
        echo "$text" | jq -Rs .
    else
        python3 -c "import json; print(json.dumps('''$text'''))"
    fi
}

json_add_field() {
    local json="$1"
    local field="$2"
    local value="$3"

    if command -v jq &>/dev/null; then
        echo "$json" | jq -c ". + {\"$field\": $value}"
    else
        # Convert JSON boolean/null to Python equivalent
        local py_value="$value"
        [[ "$value" == "true" ]] && py_value="True"
        [[ "$value" == "false" ]] && py_value="False"
        [[ "$value" == "null" ]] && py_value="None"

        echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
data['$field'] = $py_value
print(json.dumps(data))
"
    fi
}

# Read JSON from stdin
INPUT=$(cat)

# Extract tool name - only process Task tool
TOOL_NAME=$(json_get "$INPUT" ".tool_name" "")
if [[ "$TOOL_NAME" != "Task" ]]; then
    echo '{"hookSpecificOutput":{"permissionDecision":"allow"}}'
    exit 0
fi

# Extract current tool_input
if command -v jq &>/dev/null; then
    CURRENT_INPUT=$(echo "$INPUT" | jq -c '.tool_input // {}')
else
    CURRENT_INPUT=$(echo "$INPUT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(json.dumps(d.get('tool_input',{})))")
fi

# Check if already set to background
ALREADY_BACKGROUND=$(json_get "$CURRENT_INPUT" ".run_in_background" "false")

# L1/L2 Format Prompt (injected via additionalContext)
L1L2_PROMPT='## L1/L2 Output Format (MANDATORY)

Your output MUST follow this structure:

### L1 Section (Return to Main Agent - MAX 500 TOKENS)
```yaml
taskId: {auto-generate unique id}
agentType: {Explore|Plan|general-purpose}
summary: |
  1-2 sentence summary (max 200 chars)
status: success | partial | failed
findingsCount: {number}
criticalCount: {number}
l2Index:
  - anchor: "#section-name"
    lines: "start-end"
    description: "what this section contains"
l2Path: .agent/outputs/{agentType}/{taskId}.md
requiresL2Read: true | false
nextActionHint: "suggested next step"
```

### L2 Section (Write to File)
Write detailed output to: .agent/outputs/{agentType}/{taskId}.md
Use markdown anchors (## Section {#anchor}) matching l2Index.

CONSTRAINT: L1 MUST NOT EXCEED 500 TOKENS. Be concise.'

if [[ "$ALREADY_BACKGROUND" == "true" ]]; then
    # Already background - only add additionalContext
    ESCAPED_PROMPT=$(json_stringify "$L1L2_PROMPT")

    cat <<RESPONSE
{
  "hookSpecificOutput": {
    "permissionDecision": "allow",
    "additionalContext": $ESCAPED_PROMPT
  }
}
RESPONSE
    exit 0
fi

# Inject run_in_background=true + additionalContext
UPDATED_INPUT=$(json_add_field "$CURRENT_INPUT" "run_in_background" "true")
ESCAPED_PROMPT=$(json_stringify "$L1L2_PROMPT")

cat <<RESPONSE
{
  "hookSpecificOutput": {
    "permissionDecision": "allow",
    "updatedInput": $UPDATED_INPUT,
    "additionalContext": $ESCAPED_PROMPT
  }
}
RESPONSE
