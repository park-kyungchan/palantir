# Draft: L1/L2 Orchestrating Pattern 고도화

> **Version:** 1.0 | **Status:** IN_PROGRESS | **Date:** 2026-01-20
> **Auto-Compact Safe:** This file persists across context compaction

---

## INDEX

### 요구사항 요약
Main Agent의 Orchestrating-Role을 고도화하여, Subagent 위임 시 **프롬프트로 L1/L2 출력형식을 강제**하고, L1(Summary+Index)만으로 Orchestrating하며 필요 시 L2의 특정 부분만 참조하는 Loop 패턴 구현.

### Complexity
- **예상 복잡도:** large
- **영향 파일:** 10+개 ([상세](#file-analysis))
  - Skill/Command 프롬프트 템플릿
  - CLAUDE.md 오케스트레이션 규칙
  - Hook 고도화 (L2 저장 로직)

### Q&A 핵심
1. **Q:** Hook이 Native인가? → **A:** Hook API는 Native, 스크립트(force_background.py)는 Custom. 오해 해소.
2. **Q:** L2 저장 위치? → **A:** `.agent/outputs/`에 영구 저장 필수 (/tmp는 휘발성)
3. **Q:** L1/L2 형식? → **A:** Machine-Readable (YAML 기반, Anchor+Line Number 참조)

### 추천 접근법
1. **Phase 1:** L1/L2 출력 형식 표준 정의 (YAML Schema)
2. **Phase 2:** Subagent 프롬프트 템플릿에 형식 강제 삽입
3. **Phase 3:** PostToolUse Hook 고도화 (L2 영구 저장)
4. **Phase 4:** CLAUDE.md Orchestrating Loop 패턴 문서화
5. **Phase 5:** /plan → /execute 반복 패턴 구현

### 리스크
- L1 토큰 예산 초과 시 Orchestrating 품질 저하
- L2 저장 실패 시 참조 불가능
- 기존 output_schemas.py와의 호환성

### 다음 단계
`/plan` 실행 권장. Draft 참조: `--draft l1_l2_orchestrating_pattern` 또는 자동 감지.

---

## DETAIL: Q&A 전체 로그 {#qa-log}

### Round 1 (2026-01-20 10:30)
**Q:** `run_in_background=true` 기능은 프롬프트 입력사항인가?
**A:**
- 아니오. Main Agent가 `Task()` 호출 시 내부적으로 설정하는 시스템 파라미터
- Hook(`force_background.py`)이 PreToolUse 이벤트에서 자동 주입

### Round 2 (2026-01-20 10:35)
**Q:** `force_background.py`는 Claude의 Native Hook인가?
**A:**
- Hook 시스템(PreToolUse, PostToolUse 등 10개 이벤트)은 **Native API**
- `force_background.py`는 그 API를 통해 실행되는 **Custom Script**
- 즉, 시스템은 Native이고, 스크립트만 Custom

### Round 3 (2026-01-20 10:40)
**Q:** 요구사항의 핵심이 무엇인가?
**A:** Main Agent Orchestrating Loop:
1. Phase 분해 (Claude 추론)
2. `/plan` → `/execute` 반복
3. Agent 위임 시 **프롬프트로 L1/L2 출력형식 강제**
4. L1 = Summary + L2-Index (Main Agent 반환)
5. L2 = DETAIL (문서 저장)
6. Main Agent는 L1만으로 판단
7. 필요 시 L2의 **특정 부분만** 참조 (Index 활용)

### Round 4 (2026-01-20 10:45)
**Q:** L2 저장 위치? L1/L2 형식?
**A:**
- L2 저장: `.agent/outputs/` (영구 저장, Auto-Compact 후에도 유지)
- L1/L2 형식: Machine-Readable (YAML 기반)
- 참조 방식: Anchor + Line Number 병행

---

## DETAIL: 요구사항 상세 {#requirements}

### 기능 요구사항
- **FR1:** Subagent 프롬프트에 L1/L2 출력형식 강제 삽입
- **FR2:** L1은 Summary + L2-Index 구조로 500 tokens 이하
- **FR3:** L2는 `.agent/outputs/{task_id}.md`에 영구 저장
- **FR4:** Main Agent가 L1만으로 Orchestrating 수행
- **FR5:** 필요 시 L2의 특정 섹션만 `Read(offset, limit)`로 참조
- **FR6:** Phase 분해 → `/plan` → `/execute` → Loop 패턴

### 비기능 요구사항
- **NFR1:** L1 토큰 예산: 최대 500 tokens
- **NFR2:** L2 저장 성공률: 99.9%
- **NFR3:** Auto-Compact 후에도 L2 참조 가능

---

## DETAIL: 파일 분석 결과 {#file-analysis}

### 관련 파일 목록
| 파일 | 관련도 | 역할 |
|------|--------|------|
| `.claude/CLAUDE.md` | 높음 | Orchestrating 규칙 정의 |
| `.claude/hooks/l1l2/force_background.py` | 높음 | PreToolUse Hook |
| `.claude/hooks/l1l2/post-task-output.sh` | 높음 | PostToolUse Hook (L2 저장) |
| `lib/oda/planning/output_schemas.py` | 중간 | 기존 출력 스키마 |
| `.claude/commands/*.md` | 높음 | Command 프롬프트 템플릿 |
| `.claude/skills/*.md` | 높음 | Skill 프롬프트 템플릿 |
| `.claude/references/delegation-patterns.md` | 중간 | 위임 패턴 문서 |
| `.agent/outputs/` | 높음 | L2 저장 디렉토리 (신규 생성) |

### 패턴 분석
- 현재 `run_in_background=true` Hook 주입은 동작 중
- L2 저장 로직 부재 (현재 `/tmp/claude/`에만 저장)
- Subagent 프롬프트에 출력형식 강제 부재

---

## DETAIL: 리스크 분석 {#risk-analysis}

| 리스크 | 영향 | 완화 방안 |
|--------|------|----------|
| L1 토큰 초과 | High | 출력 스키마에 max_length 강제 |
| L2 저장 실패 | High | PostToolUse Hook에서 재시도 로직 |
| 기존 스키마 호환성 | Medium | output_schemas.py 확장 (breaking change 없이) |
| Auto-Compact 후 L2 참조 | Medium | `.agent/outputs/` 사용으로 해결 |

---

## DETAIL: L1/L2 출력 형식 설계 {#output-format}

### L1 형식 (Machine-Readable YAML)

```yaml
# L1 Output Schema (~500 tokens max)
summary: |
  1-2 sentence summary of task completion
status: success | partial | failed
findings_count: 5
critical_count: 1

# L2 Index for selective reading
l2_index:
  path: .agent/outputs/{task_id}.md
  sections:
    - anchor: "#findings"
      lines: "50-120"
      description: "Detailed findings with severity"
    - anchor: "#files-modified"
      lines: "122-150"
      description: "List of modified files"
    - anchor: "#verification"
      lines: "152-200"
      description: "Test and lint results"

# Quick reference for orchestrating decision
next_action_hint: "Run tests to verify changes"
requires_l2_read: false  # Main Agent can proceed with L1 only
```

### L2 형식 (Structured Markdown)

```markdown
# L2 Output: {task_description}

> **Task ID:** {task_id}
> **Generated:** {timestamp}
> **L1 Summary:** [See L1 section above]

---

## Findings {#findings}

### Finding 1 (CRITICAL)
- **File:** path/to/file.py:42
- **Description:** SQL injection vulnerability
- **Recommendation:** Use parameterized queries

### Finding 2 (HIGH)
...

---

## Files Modified {#files-modified}

| File | Action | Lines Changed |
|------|--------|---------------|
| src/api.py | Modified | +15, -3 |
| tests/test_api.py | Created | +45 |

---

## Verification Results {#verification}

### Tests
- pytest: PASS (42 tests)
- coverage: 85%

### Lint
- ruff: PASS (0 errors)
- mypy: PASS (0 errors)

---

## Raw Evidence {#evidence}

```yaml
files_viewed:
  - src/api.py
  - tests/test_api.py
lines_referenced:
  src/api.py: [42, 55, 78]
code_snippets: 3
```
```

---

## DETAIL: Orchestrating Loop 패턴 {#orchestrating-loop}

```
┌─────────────────────────────────────────────────────────┐
│                  Main Agent (Orchestrator)               │
│                                                         │
│  1. Receive User Request                               │
│  2. Decompose into Phases (Claude reasoning)           │
│  3. For each Phase:                                    │
│     ├── /plan (generate plan file)                     │
│     ├── /execute (delegate to Subagents)               │
│     │   ├── Task(prompt with L1/L2 format enforced)    │
│     │   ├── Subagent writes L1 (to Main) + L2 (to file)│
│     │   └── PostToolUse Hook saves L2 to .agent/outputs│
│     ├── Receive L1 only                                │
│     ├── Orchestrating decision based on L1             │
│     │   ├── If more detail needed:                     │
│     │   │   └── Read(L2_path, offset, limit) ← Index   │
│     │   └── Otherwise: proceed to next phase           │
│     └── Loop until phase complete                      │
│  4. Synthesize results                                 │
│  5. Return to User                                     │
└─────────────────────────────────────────────────────────┘
```

---

## Metadata

- Created: 2026-01-20 10:30
- Last Updated: 2026-01-20 10:50
- Q&A Rounds: 4
- Status: IN_PROGRESS
