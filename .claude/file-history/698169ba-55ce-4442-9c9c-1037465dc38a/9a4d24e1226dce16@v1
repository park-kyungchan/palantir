#!/bin/bash
# Task Governance Hook - PreToolUse
#
# File: .claude/hooks/task-governance/pre-task-inject.sh
# Version: 2.3.0 (Progressive Disclosure)
#
# Purpose:
#   1. Inject run_in_background=true for all Task() calls (updatedInput)
#   2. Inject model="opus" for all Task() calls (updatedInput)
#   3. Inject Progressive Disclosure output format (additionalContext)
#   4. Skip format injection for conversational agents (prompt-assistant)
#
# Trigger: PreToolUse on Task tool
# Dependencies: jq (preferred) or python3 (fallback)
#
# Native Capabilities Used:
#   - updatedInput (V2.1.9): Modify tool parameters (run_in_background, model)
#   - additionalContext (V2.1.9): Inject context to subagent prompt
#
# Decision Log:
#   - Round 6: model="opus" 추가
#   - Round 7: 대화형 에이전트(prompt-assistant) L1/L2 제외
#   - Round 19: Progressive Disclosure 필드 추가 (priority, recommendedRead, tokens)

set -euo pipefail

# JSON helper: use jq if available, else python3
json_get() {
    local json="$1"
    local path="$2"
    local default="${3:-}"

    if command -v jq &>/dev/null; then
        echo "$json" | jq -r "$path // \"$default\""
    else
        echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
path = '$path'.strip('.')
result = data
for key in path.split('.'):
    if key and isinstance(result, dict):
        result = result.get(key, '$default')
print(result if result else '$default')
"
    fi
}

json_stringify() {
    local text="$1"
    if command -v jq &>/dev/null; then
        echo "$text" | jq -Rs .
    else
        python3 -c "import json; print(json.dumps('''$text'''))"
    fi
}

json_add_field() {
    local json="$1"
    local field="$2"
    local value="$3"

    if command -v jq &>/dev/null; then
        echo "$json" | jq -c ". + {\"$field\": $value}"
    else
        # Convert JSON boolean/null to Python equivalent
        local py_value="$value"
        [[ "$value" == "true" ]] && py_value="True"
        [[ "$value" == "false" ]] && py_value="False"
        [[ "$value" == "null" ]] && py_value="None"

        echo "$json" | python3 -c "
import sys, json
data = json.load(sys.stdin)
data['$field'] = $py_value
print(json.dumps(data))
"
    fi
}

# Read JSON from stdin
INPUT=$(cat)

# Extract tool name - only process Task tool
TOOL_NAME=$(json_get "$INPUT" ".tool_name" "")
if [[ "$TOOL_NAME" != "Task" ]]; then
    echo '{"hookSpecificOutput":{"permissionDecision":"allow"}}'
    exit 0
fi

# Extract current tool_input
if command -v jq &>/dev/null; then
    CURRENT_INPUT=$(echo "$INPUT" | jq -c '.tool_input // {}')
else
    CURRENT_INPUT=$(echo "$INPUT" | python3 -c "import sys,json; d=json.load(sys.stdin); print(json.dumps(d.get('tool_input',{})))")
fi

# Check if already set to background
ALREADY_BACKGROUND=$(json_get "$CURRENT_INPUT" ".run_in_background" "false")

# Extract subagent_type for conditional L1/L2 injection (Round 7)
SUBAGENT_TYPE=$(json_get "$CURRENT_INPUT" ".subagent_type" "")

# Conversational agents that should NOT receive L1/L2 format
CONVERSATIONAL_AGENTS="prompt-assistant"

# L1/L2 Format Prompt V2.3.0 with Progressive Disclosure (injected via additionalContext)
L1L2_PROMPT='## L1/L2 Output Format V2.3.0 (MANDATORY - Progressive Disclosure)

Your output MUST follow this structure:

### L1 Section (Return to Main Agent - MAX 500 TOKENS)
```yaml
taskId: {auto-generate unique 8-char id}
agentType: {Explore|Plan|general-purpose}
summary: |
  1-2 sentence summary (max 200 chars)
status: success | partial | failed

# Progressive Disclosure Fields (REQUIRED)
priority: CRITICAL | HIGH | MEDIUM | LOW
recommendedRead:
  - anchor: "#anchor-name"
    reason: "Brief explanation why this should be read"

findingsCount: {number}
criticalCount: {number}

l2Index:
  - anchor: "#section-name"
    tokens: {estimated tokens for this section}
    priority: CRITICAL | HIGH | MEDIUM | LOW
    description: "what this section contains"

l2Path: .agent/outputs/{agentType}/{taskId}.md
requiresL2Read: true | false
nextActionHint: "suggested next step"
```

### L2 Section (Write to File)
Write detailed output to: .agent/outputs/{agentType}/{taskId}.md
Use markdown anchors (## Section {#anchor}) matching l2Index.
Include estimated token count per section.

### Priority Guidelines
- CRITICAL: criticalCount > 0 OR blocking issues found
- HIGH: status == partial OR major issues requiring attention
- MEDIUM: status == success with notable findings (findingsCount > 5)
- LOW: status == success with minimal findings

CONSTRAINT: L1 MUST NOT EXCEED 500 TOKENS. Be concise.'

# Check if this is a conversational agent (should skip L1/L2 format)
IS_CONVERSATIONAL="false"
for agent in $CONVERSATIONAL_AGENTS; do
    if [[ "$SUBAGENT_TYPE" == "$agent" ]]; then
        IS_CONVERSATIONAL="true"
        break
    fi
done

# Build updated input with run_in_background=true and model="opus" (Round 6)
UPDATED_INPUT="$CURRENT_INPUT"
if [[ "$ALREADY_BACKGROUND" != "true" ]]; then
    UPDATED_INPUT=$(json_add_field "$UPDATED_INPUT" "run_in_background" "true")
fi
# Add model="opus" for all Task() calls (Round 6 decision)
UPDATED_INPUT=$(json_add_field "$UPDATED_INPUT" "model" '"opus"')

# Conversational agents: skip L1/L2 format injection (Round 7)
if [[ "$IS_CONVERSATIONAL" == "true" ]]; then
    cat <<RESPONSE
{
  "hookSpecificOutput": {
    "permissionDecision": "allow",
    "updatedInput": $UPDATED_INPUT
  }
}
RESPONSE
    exit 0
fi

# Analysis agents: inject L1/L2 format with Progressive Disclosure
ESCAPED_PROMPT=$(json_stringify "$L1L2_PROMPT")

cat <<RESPONSE
{
  "hookSpecificOutput": {
    "permissionDecision": "allow",
    "updatedInput": $UPDATED_INPUT,
    "additionalContext": $ESCAPED_PROMPT
  }
}
RESPONSE
