#!/bin/bash
# Post-Task-Output Hook for L1/L2 Validation
#
# File: .claude/hooks/task-governance/post-task-output.sh
# Version: 2.3.0 (Progressive Disclosure)
#
# Triggered: After Task() returns
# Purpose:
#   1. Capture Agent ID for resume support
#   2. Log L1 summary with priority for later reference
#   3. Validate Progressive Disclosure compliance
#   4. Validate L1 format and L2 storage
#
# Exit codes:
#   0 - Validation passed (always - don't block execution)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Tool outputs
OUTPUT="${TOOL_OUTPUT:-}"
SUBAGENT_TYPE="${TOOL_INPUT_SUBAGENT_TYPE:-general-purpose}"

# Log directory
mkdir -p .agent/logs 2>/dev/null || true
mkdir -p .agent/outputs 2>/dev/null || true

log_event() {
  local status="$1"
  local message="$2"
  echo "$(date -Iseconds) | POST_TASK | $SUBAGENT_TYPE | $status | $message" >> .agent/logs/l1l2_hooks.log 2>/dev/null || true
}

# Validation functions
validate_l1_format() {
  local output="$1"

  # Check for summary field
  if ! echo "$output" | grep -q "summary:"; then
    echo "FAIL: Missing 'summary' field in L1"
    return 1
  fi

  # Check for l2Index field
  if ! echo "$output" | grep -q "l2Index:"; then
    echo "FAIL: Missing 'l2Index' field in L1"
    return 1
  fi

  # Check for taskId field
  if ! echo "$output" | grep -q "taskId:"; then
    echo "FAIL: Missing 'taskId' field in L1"
    return 1
  fi

  # Check summary length (rough check - extract between quotes)
  local summary=$(echo "$output" | grep "summary:" | head -1 | sed 's/.*summary:[[:space:]]*//' | sed 's/"//g' | head -c 300)
  local summary_len=${#summary}
  if [[ $summary_len -gt 200 ]]; then
    echo "WARN: Summary exceeds 200 characters ($summary_len chars)"
    # Don't fail, just warn
  fi

  echo "PASS: L1 format validated"
  return 0
}

validate_l2_exists() {
  local output="$1"

  # Extract l2Path if present
  local l2_path=$(echo "$output" | grep "l2Path:" | head -1 | sed 's/.*l2Path:[[:space:]]*//' | sed 's/"//g' | tr -d "'")

  if [[ -z "$l2_path" ]]; then
    # Try to construct from agentType and taskId
    local agent_type=$(echo "$output" | grep "agentType:" | head -1 | sed 's/.*agentType:[[:space:]]*//' | sed 's/"//g' | tr -d "'")
    local task_id=$(echo "$output" | grep "taskId:" | head -1 | sed 's/.*taskId:[[:space:]]*//' | sed 's/"//g' | tr -d "'")

    if [[ -n "$agent_type" && -n "$task_id" ]]; then
      l2_path=".agent/outputs/${agent_type}/${task_id}.md"
    fi
  fi

  if [[ -z "$l2_path" ]]; then
    echo "WARN: Cannot determine L2 path"
    return 0  # Don't fail, L2 might be inline or not applicable
  fi

  if [[ -f "$l2_path" ]]; then
    echo "PASS: L2 file exists at $l2_path"
    return 0
  else
    echo "WARN: L2 file not found at $l2_path (may be created later)"
    return 0  # Don't fail, might be async
  fi
}

validate_anchor_consistency() {
  local output="$1"

  # Extract anchors from l2Index
  local anchors=$(echo "$output" | grep -E "anchor:" | sed 's/.*anchor:[[:space:]]*//' | sed 's/"//g' | tr -d "'" | tr '\n' ' ')

  if [[ -z "$anchors" ]]; then
    echo "PASS: No anchors to validate"
    return 0
  fi

  echo "PASS: Found anchors: $anchors"
  return 0
}

# Main validation
if [[ -z "$OUTPUT" ]]; then
  log_event "SKIP" "no_output"
  exit 0
fi

# Run validations
echo "[L1/L2 Post-Task Validation]"
echo "Subagent Type: $SUBAGENT_TYPE"
echo "---"

validate_l1_format "$OUTPUT"
L1_RESULT=$?

validate_l2_exists "$OUTPUT"
L2_RESULT=$?

validate_anchor_consistency "$OUTPUT"
ANCHOR_RESULT=$?

# Log results
if [[ $L1_RESULT -eq 0 && $L2_RESULT -eq 0 && $ANCHOR_RESULT -eq 0 ]]; then
  log_event "PASS" "all_validations_passed"
  exit 0
else
  log_event "WARN" "validation_warnings"
  exit 0  # Don't block, just warn
fi
