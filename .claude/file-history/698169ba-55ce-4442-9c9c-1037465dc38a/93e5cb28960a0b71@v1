"""
ODA Structured Output Schemas (Refactored)
==========================================

Pydantic models for enforcing structured JSON output from subagents.
Core schemas only - validation utilities moved to separate module.
"""

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field


class Severity(str, Enum):
    """Finding severity levels."""

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class Finding(BaseModel):
    """A single finding from analysis."""

    file: str = Field(..., description="File path where finding occurred")
    line: Optional[int] = Field(default=None, ge=1, description="Line number")
    severity: Severity = Field(..., description="Finding severity level")
    description: str = Field(..., max_length=200, description="Brief description")
    category: Optional[str] = Field(default=None, max_length=50, description="Category")


class DependencyInfo(BaseModel):
    """Information about a code dependency."""

    name: str = Field(..., description="Dependency name or import path")
    type: str = Field(default="import", description="Type: import, file, external, internal")
    location: Optional[str] = Field(default=None, description="Usage location")


class ExploreOutput(BaseModel):
    """Structured output schema for Explore subagent. Token Budget: ~5K tokens."""

    summary: str = Field(..., max_length=200, description="One-sentence summary")
    files_analyzed: List[str] = Field(..., max_length=50, description="Analyzed file paths")
    patterns_found: List[str] = Field(default_factory=list, max_length=20, description="Patterns discovered")
    findings: List[Finding] = Field(..., max_length=20, description="Findings sorted by severity")
    dependencies: List[Union[str, DependencyInfo]] = Field(default_factory=list, max_length=30, description="Dependencies")
    metrics: Optional[Dict[str, Any]] = Field(default=None, description="Optional metrics")
    next_action_hint: str = Field(..., max_length=150, description="Suggested next action")


class PlanPhase(BaseModel):
    """A single phase in an implementation plan."""

    phase_number: int = Field(..., ge=1, le=20, description="Phase sequence number")
    name: str = Field(..., max_length=80, description="Phase name")
    description: Optional[str] = Field(default=None, max_length=200, description="Phase description")
    tasks: List[str] = Field(..., max_length=15, description="Tasks to complete")
    dependencies: List[int] = Field(default_factory=list, description="Dependent phase numbers")
    estimated_effort: str = Field(..., description="Effort: trivial, small, medium, large, xlarge")
    files_affected: List[str] = Field(default_factory=list, max_length=10, description="Files to modify")


class RiskItem(BaseModel):
    """A risk identified during planning."""

    description: str = Field(..., max_length=200, description="Risk description")
    severity: Severity = Field(default=Severity.MEDIUM, description="Risk severity")
    mitigation: Optional[str] = Field(default=None, max_length=200, description="Mitigation")


class PlanOutput(BaseModel):
    """Structured output schema for Plan subagent. Token Budget: ~10K tokens."""

    summary: str = Field(..., max_length=200, description="One-sentence plan summary")
    objective: Optional[str] = Field(default=None, max_length=300, description="Plan objective")
    total_phases: int = Field(..., ge=1, le=20, description="Total number of phases")
    phases: List[PlanPhase] = Field(..., max_length=10, description="Implementation phases")
    critical_files: List[str] = Field(default_factory=list, max_length=30, description="Files to modify")
    risks: List[Union[str, RiskItem]] = Field(default_factory=list, max_length=10, description="Identified risks")
    prerequisites: List[str] = Field(default_factory=list, max_length=10, description="Prerequisites")
    success_criteria: List[str] = Field(default_factory=list, max_length=5, description="Success criteria")
    next_action_hint: str = Field(..., max_length=150, description="Suggested next action")


class SynthesisOutput(BaseModel):
    """Structured output schema for L2 Synthesizer. Variable token budget."""

    summary: str = Field(..., max_length=300, description="Executive summary")
    total_agents: int = Field(..., ge=1, description="Number of L2 files synthesized")
    critical_findings: List[str] = Field(..., max_length=15, description="Critical findings (deduplicated)")
    cross_module_concerns: List[str] = Field(default_factory=list, max_length=10, description="Cross-module issues")
    consolidated_files: List[str] = Field(default_factory=list, max_length=50, description="All unique files")
    recommended_next_action: str = Field(..., max_length=150, description="Primary recommendation")
    additional_recommendations: List[str] = Field(default_factory=list, max_length=5, description="Secondary recommendations")


class ExecutionOutput(BaseModel):
    """Structured output schema for general-purpose execution. Token Budget: ~15K tokens."""

    summary: str = Field(..., max_length=200, description="One-sentence summary")
    status: str = Field(..., description="Status: success, partial, failed")
    files_created: List[str] = Field(default_factory=list, max_length=20, description="New files")
    files_modified: List[str] = Field(default_factory=list, max_length=30, description="Modified files")
    files_deleted: List[str] = Field(default_factory=list, max_length=10, description="Deleted files")
    verification_results: Dict[str, str] = Field(default_factory=dict, description="Verification results")
    errors: List[str] = Field(default_factory=list, max_length=10, description="Errors encountered")
    warnings: List[str] = Field(default_factory=list, max_length=10, description="Warnings")
    next_action_hint: str = Field(..., max_length=150, description="Suggested next action")


# =============================================================================
# L1/L2 Orchestrating Pattern Schemas (V2.2.0)
# =============================================================================


class L2IndexEntry(BaseModel):
    """Index entry pointing to a specific section in L2 output file.

    Enables selective reading of L2 content using Read(path, offset, limit).
    """

    anchor: str = Field(
        ...,
        pattern=r"^#[\w-]+$",
        max_length=50,
        description="Markdown anchor (e.g., '#findings')",
    )
    lines: str = Field(
        ...,
        pattern=r"^\d+-\d+$",
        max_length=15,
        description="Line range (e.g., '50-120')",
    )
    description: str = Field(..., max_length=80, description="Brief section description")


class L1OutputStatus(str, Enum):
    """L1 output status values."""

    SUCCESS = "success"
    PARTIAL = "partial"
    FAILED = "failed"


class L1Output(BaseModel):
    """Lightweight summary output for Main Agent orchestrating. Token Budget: ~500 tokens.

    This schema enforces minimal output that fits within the L1 budget while
    providing enough information for orchestrating decisions.

    Usage:
        - Subagents return L1Output to Main Agent
        - Full details written to L2 file at l2_path
        - Main Agent reads specific L2 sections via l2_index when needed
    """

    task_id: str = Field(..., max_length=50, description="Unique task identifier")
    agent_type: str = Field(..., max_length=30, description="Subagent type: Explore, Plan, general-purpose")
    summary: str = Field(..., max_length=200, description="One-sentence summary of task completion")
    status: L1OutputStatus = Field(..., description="Task completion status")
    findings_count: int = Field(default=0, ge=0, description="Total number of findings")
    critical_count: int = Field(default=0, ge=0, description="Number of critical findings")
    l2_index: List[L2IndexEntry] = Field(
        default_factory=list,
        max_length=10,
        description="Index entries for selective L2 reading",
    )
    l2_path: str = Field(..., max_length=150, description="Path to L2 detail file: .agent/outputs/{type}/{id}.md")
    next_action_hint: str = Field(..., max_length=150, description="Suggested next action for orchestrator")
    requires_l2_read: bool = Field(
        default=False,
        description="Whether Main Agent should read L2 sections for decision",
    )

    def get_line_range(self, anchor: str) -> tuple[int, int] | None:
        """Get line range for a specific anchor.

        Args:
            anchor: The anchor to look up (e.g., '#findings')

        Returns:
            Tuple of (start_line, end_line) or None if anchor not found
        """
        for entry in self.l2_index:
            if entry.anchor == anchor:
                start, end = entry.lines.split("-")
                return int(start), int(end)
        return None


# Schema registry for lookup by subagent type
SCHEMA_REGISTRY: Dict[str, type[BaseModel]] = {
    "explore": ExploreOutput,
    "plan": PlanOutput,
    "synthesis": SynthesisOutput,
    "execution": ExecutionOutput,
    "general_purpose": ExecutionOutput,
    "general-purpose": ExecutionOutput,
}


def get_schema(subagent_type: str) -> type[BaseModel]:
    """Get Pydantic schema class for a subagent type.

    Args:
        subagent_type: Type of subagent (e.g., 'explore', 'plan')

    Returns:
        Pydantic BaseModel subclass for the specified type

    Raises:
        ValueError: If subagent_type is not registered
    """
    normalized = subagent_type.lower().replace("-", "_").replace(" ", "_")
    if normalized not in SCHEMA_REGISTRY:
        available = ", ".join(sorted(set(SCHEMA_REGISTRY.keys())))
        raise ValueError(f"Unknown subagent type: '{subagent_type}'. Available: {available}")
    return SCHEMA_REGISTRY[normalized]


def get_json_schema(subagent_type: str) -> Dict[str, Any]:
    """Get JSON Schema for a subagent type.

    Args:
        subagent_type: Type of subagent (e.g., 'explore', 'plan')

    Returns:
        JSON Schema dictionary
    """
    schema_class = get_schema(subagent_type)
    return schema_class.model_json_schema()


__all__ = [
    "Severity",
    "Finding",
    "DependencyInfo",
    "ExploreOutput",
    "PlanPhase",
    "RiskItem",
    "PlanOutput",
    "SynthesisOutput",
    "ExecutionOutput",
    "SCHEMA_REGISTRY",
    "get_schema",
    "get_json_schema",
]
