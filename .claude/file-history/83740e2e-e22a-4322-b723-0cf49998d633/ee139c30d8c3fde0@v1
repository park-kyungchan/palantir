---
name: oda-plan
description: Transform user requirements into ODA-aligned implementation plan using 3-Stage Protocol. Use before any significant code changes.
allowed-tools: Read, Grep, Glob, Bash, TodoWrite
---

# ODA Planning Skill (3-Stage Protocol)

## Purpose
Convert user requirements into a governed, schema-first implementation plan.
Ensures all changes align with Ontology-Driven Architecture principles.

## Invocation
```
/oda-plan <요구사항>
```

## Protocol Flow

### Stage A: BLUEPRINT (Requirements Analysis)

**Goal:** Understand what needs to be built

**Actions:**
1. **Requirement Parsing**
   - Extract functional requirements
   - Identify non-functional constraints
   - Map to existing ObjectTypes

2. **Codebase Context**
   - Read relevant existing files
   - Identify integration points
   - Check for similar implementations

3. **Scope Definition**
   - Define boundaries (in-scope / out-of-scope)
   - Estimate complexity
   - Identify risks

**TodoWrite Integration:**
```
[x] Stage A: Parse requirements
[x] Stage A: Scan codebase
[x] Stage A: Define scope
[ ] Stage B: Design solution
[ ] Stage C: Validate plan
```

**Evidence Required:**
```yaml
files_viewed:
  - path/to/related/file1.py
  - path/to/related/file2.py
requirements:
  - "FR1: User can create tasks"
  - "FR2: Tasks have priorities"
  - "NFR1: Response time < 200ms"
complexity: medium
```

### Stage B: INTEGRATION TRACE (Solution Design)

**Goal:** Design the implementation approach

**Actions:**
1. **Schema Alignment**
   - Map requirements to ObjectTypes
   - Verify property types match
   - Check link cardinalities

2. **Action Design**
   - Define required Actions
   - Specify submission criteria
   - Plan side effects

3. **Phase Breakdown**
   ```markdown
   ### Phase 1: [Foundation]
   - Goal: Set up base structure
   - Files: [list]
   - Tests: [list]
   - Quality Gate: Build passes

   ### Phase 2: [Core Logic]
   - Goal: Implement main functionality
   - Files: [list]
   - Tests: [list]
   - Quality Gate: Tests pass

   ### Phase 3: [Integration]
   - Goal: Connect components
   - Files: [list]
   - Tests: [list]
   - Quality Gate: E2E passes
   ```

**Evidence Required:**
```yaml
imports_verified:
  - "from scripts.ontology.objects.task_types import Task"
  - "from scripts.ontology.actions import EditOperation"
signatures_matched:
  - "async def create_task(title: str, priority: TaskPriority) -> Task"
test_strategy: "Unit tests for each Action, integration test for workflow"
```

### Stage C: QUALITY GATE (Plan Validation)

**Goal:** Ensure plan is ready for execution

**Validation Checklist:**
- [ ] All ObjectTypes referenced exist in registry
- [ ] All Actions follow ODA patterns
- [ ] No blocked patterns in plan
- [ ] Evidence collected for all stages
- [ ] Risk mitigation defined

**Risk Assessment:**
| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Schema mismatch | Low | High | Verify against registry |
| Integration failure | Medium | Medium | Incremental phases |
| Performance issue | Low | Medium | Load test in Stage C |

## Output Format

```markdown
# ODA Implementation Plan

## 1. Requirements Summary
| ID | Type | Description | Priority |
|----|------|-------------|----------|
| FR1 | Functional | ... | HIGH |

## 2. Schema Mapping
| Requirement | ObjectType | Property/Link |
|-------------|------------|---------------|
| FR1 | Task | title, priority |

## 3. Action Definitions
```python
@register_action("task.create")
class CreateTaskAction(OntologyAction):
    async def apply_edits(self, params: CreateTaskParams) -> Task:
        ...
```

## 4. Implementation Phases

### Phase 1: [Name] (Complexity: X)
- **Goal:** ...
- **Files to Create/Modify:**
  - `path/to/file.py` - Description
- **Tests:**
  - `test_file.py::test_case`
- **Quality Gate:** Build + Unit tests

### Phase 2: [Name] (Complexity: X)
...

## 5. Risk Register
[Risk table]

## 6. Evidence
- files_viewed: [...]
- requirements_traced: [...]
- schema_validated: true

## 7. Approval Gate
- [ ] Stage A evidence complete
- [ ] Stage B design approved
- [ ] Stage C validation passed
- [ ] User approval received
```

## Integration with TodoWrite

This skill automatically creates and updates todos:

```python
# Auto-generated todos for plan execution
todos = [
    {"content": "Phase 1: [Name]", "status": "pending"},
    {"content": "Phase 2: [Name]", "status": "pending"},
    {"content": "Phase 3: [Name]", "status": "pending"},
    {"content": "Run tests", "status": "pending"},
    {"content": "Documentation", "status": "pending"},
]
```

## Anti-Hallucination Rule

**CRITICAL:** Plans without file evidence are INVALID.

Before completing any stage:
1. Read at least one relevant file
2. Document the file in `files_viewed`
3. Reference specific line numbers for claims

```python
if not stage_result.evidence.get("files_viewed"):
    raise AntiHallucinationError(
        f"Stage {stage.name} completed without reading any files"
    )
```

## Example Usage

```
User: /oda-plan 사용자가 Task에 태그를 추가할 수 있는 기능 구현

Claude: 3-Stage Planning Protocol을 시작합니다.

## Stage A: BLUEPRINT

### 요구사항 분석
- FR1: 사용자가 Task에 여러 태그를 추가할 수 있음
- FR2: 태그는 문자열 배열로 저장됨
- NFR1: 기존 Task API와 호환 유지

### 파일 스캔
[Read scripts/ontology/objects/task_types.py]

### Evidence
files_viewed:
  - scripts/ontology/objects/task_types.py (lines 57-124)
complexity: small (2 phases)

...
```
