"""
PriorityScorer for Human Review system.

Scores tasks to determine review priority based on:
- Confidence levels
- Element complexity
- Time constraints
- Business rules

Module Version: 2.0.0

v2.0.0 Changes:
- Added ThresholdConfig integration for dynamic priority thresholds
- Priority thresholds computed using 3-layer architecture (base → context → feedback)
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, Optional

from .models.task import ReviewTask, ReviewPriority
from ..schemas.threshold import (
    ThresholdConfig,
    ThresholdContext,
    FeedbackStats,
    compute_effective_threshold,
)


logger = logging.getLogger(__name__)


# =============================================================================
# Configuration
# =============================================================================

@dataclass
class PriorityScorerConfig:
    """Configuration for PriorityScorer."""
    # Score weights (must sum to 1.0)
    confidence_weight: float = 0.35
    complexity_weight: float = 0.25
    urgency_weight: float = 0.20
    business_weight: float = 0.20

    # Confidence scoring
    critical_confidence_threshold: float = 0.30
    high_confidence_threshold: float = 0.45
    medium_confidence_threshold: float = 0.55

    # Complexity factors
    complexity_element_types: Dict[str, float] = field(default_factory=lambda: {
        "equation": 0.8,
        "function": 0.8,
        "graph": 0.9,
        "geometry": 0.7,
        "label": 0.3,
        "annotation": 0.2,
    })

    # Urgency settings
    urgent_due_hours: int = 4
    high_due_hours: int = 12
    medium_due_hours: int = 24

    # Business rule multipliers
    escalation_multiplier: float = 1.5
    repeat_assignment_multiplier: float = 1.2

    def __post_init__(self):
        """Validate weights sum to 1.0."""
        total = (
            self.confidence_weight +
            self.complexity_weight +
            self.urgency_weight +
            self.business_weight
        )
        if abs(total - 1.0) > 0.01:
            raise ValueError(f"Weights must sum to 1.0, got {total}")


# =============================================================================
# PriorityScorer
# =============================================================================

class PriorityScorer:
    """Scores tasks to determine review priority.

    Combines multiple factors to produce a priority score:
    - Confidence gap (how far below threshold)
    - Element complexity (some types harder to verify)
    - Time urgency (due dates, queue age)
    - Business rules (escalations, repeat assignments)

    The scorer outputs a ReviewPriority enum value suitable
    for queue ordering.

    Usage:
        scorer = PriorityScorer(config)
        priority = scorer.score(task)
        task.priority = priority
    """

    def __init__(self, config: Optional[PriorityScorerConfig] = None):
        """Initialize scorer.

        Args:
            config: Scorer configuration
        """
        self.config = config or PriorityScorerConfig()

    def score(self, task: ReviewTask) -> ReviewPriority:
        """Score a task and return priority.

        Args:
            task: ReviewTask to score

        Returns:
            ReviewPriority
        """
        # Calculate component scores (0-1 scale, higher = more urgent)
        confidence_score = self._score_confidence(task)
        complexity_score = self._score_complexity(task)
        urgency_score = self._score_urgency(task)
        business_score = self._score_business(task)

        # Weighted sum
        total_score = (
            confidence_score * self.config.confidence_weight +
            complexity_score * self.config.complexity_weight +
            urgency_score * self.config.urgency_weight +
            business_score * self.config.business_weight
        )

        # Map to priority
        priority = self._map_score_to_priority(total_score)

        logger.debug(
            f"Task {task.task_id} scored: "
            f"confidence={confidence_score:.2f}, "
            f"complexity={complexity_score:.2f}, "
            f"urgency={urgency_score:.2f}, "
            f"business={business_score:.2f}, "
            f"total={total_score:.2f} -> {priority.value}"
        )

        return priority

    def _score_confidence(self, task: ReviewTask) -> float:
        """Score based on confidence level.

        Lower confidence = higher score (more urgent).
        """
        confidence = task.context.original_confidence

        if confidence <= self.config.critical_confidence_threshold:
            return 1.0
        elif confidence <= self.config.high_confidence_threshold:
            # Linear interpolation between critical and high
            range_size = (
                self.config.high_confidence_threshold -
                self.config.critical_confidence_threshold
            )
            position = confidence - self.config.critical_confidence_threshold
            return 1.0 - (position / range_size) * 0.25
        elif confidence <= self.config.medium_confidence_threshold:
            # Linear interpolation between high and medium
            range_size = (
                self.config.medium_confidence_threshold -
                self.config.high_confidence_threshold
            )
            position = confidence - self.config.high_confidence_threshold
            return 0.75 - (position / range_size) * 0.25
        else:
            # Above medium threshold
            return 0.5 * (1.0 - confidence)

    def _score_complexity(self, task: ReviewTask) -> float:
        """Score based on element complexity.

        More complex elements = higher score.
        """
        element_type = task.context.element_type.lower()

        # Get base complexity from config
        base_complexity = self.config.complexity_element_types.get(
            element_type, 0.5
        )

        # Adjust based on related elements
        related_count = len(task.context.related_elements)
        if related_count > 0:
            # More related elements = more complex
            related_factor = min(1.0, 0.5 + (related_count * 0.1))
            base_complexity = base_complexity * related_factor

        return min(1.0, base_complexity)

    def _score_urgency(self, task: ReviewTask) -> float:
        """Score based on time urgency.

        Closer to due date = higher score.
        """
        now = datetime.now(timezone.utc)

        if task.due_at is None:
            # No due date, check queue age instead
            age_hours = (now - task.created_at).total_seconds() / 3600
            if age_hours > self.config.medium_due_hours:
                return 0.7
            elif age_hours > self.config.high_due_hours:
                return 0.5
            else:
                return 0.3

        # Has due date
        time_left = (task.due_at - now).total_seconds() / 3600

        if time_left <= 0:
            # Overdue
            return 1.0
        elif time_left <= self.config.urgent_due_hours:
            return 0.9
        elif time_left <= self.config.high_due_hours:
            # Linear interpolation
            progress = (self.config.high_due_hours - time_left) / (
                self.config.high_due_hours - self.config.urgent_due_hours
            )
            return 0.7 + (progress * 0.2)
        elif time_left <= self.config.medium_due_hours:
            return 0.5
        else:
            return 0.3

    def _score_business(self, task: ReviewTask) -> float:
        """Score based on business rules.

        Escalations, repeat assignments, etc.
        """
        score = 0.0

        # Escalation check
        if task.metrics.escalation_count > 0:
            score += 0.4 * self.config.escalation_multiplier

        # Repeat assignment check
        if task.metrics.assignment_count > 1:
            score += 0.2 * (
                task.metrics.assignment_count *
                self.config.repeat_assignment_multiplier
            )

        # Severity from context
        if task.severity.value == "blocker":
            score += 0.4
        elif task.severity.value == "high":
            score += 0.2

        return min(1.0, score)

    def _map_score_to_priority(self, score: float) -> ReviewPriority:
        """Map numeric score to priority enum.

        Args:
            score: Score from 0-1

        Returns:
            ReviewPriority
        """
        if score >= 0.8:
            return ReviewPriority.CRITICAL
        elif score >= 0.6:
            return ReviewPriority.HIGH
        elif score >= 0.4:
            return ReviewPriority.MEDIUM
        else:
            return ReviewPriority.LOW

    # =========================================================================
    # Utility Methods
    # =========================================================================

    def explain_score(self, task: ReviewTask) -> Dict[str, Any]:
        """Get detailed explanation of scoring.

        Args:
            task: Task to explain

        Returns:
            Dict with score breakdown
        """
        confidence_score = self._score_confidence(task)
        complexity_score = self._score_complexity(task)
        urgency_score = self._score_urgency(task)
        business_score = self._score_business(task)

        total_score = (
            confidence_score * self.config.confidence_weight +
            complexity_score * self.config.complexity_weight +
            urgency_score * self.config.urgency_weight +
            business_score * self.config.business_weight
        )

        return {
            "task_id": task.task_id,
            "scores": {
                "confidence": {
                    "raw": confidence_score,
                    "weight": self.config.confidence_weight,
                    "weighted": confidence_score * self.config.confidence_weight,
                },
                "complexity": {
                    "raw": complexity_score,
                    "weight": self.config.complexity_weight,
                    "weighted": complexity_score * self.config.complexity_weight,
                },
                "urgency": {
                    "raw": urgency_score,
                    "weight": self.config.urgency_weight,
                    "weighted": urgency_score * self.config.urgency_weight,
                },
                "business": {
                    "raw": business_score,
                    "weight": self.config.business_weight,
                    "weighted": business_score * self.config.business_weight,
                },
            },
            "total_score": total_score,
            "priority": self._map_score_to_priority(total_score).value,
            "factors": {
                "original_confidence": task.context.original_confidence,
                "threshold_delta": task.context.threshold_delta,
                "element_type": task.context.element_type,
                "related_elements": len(task.context.related_elements),
                "escalation_count": task.metrics.escalation_count,
                "assignment_count": task.metrics.assignment_count,
            },
        }

    def recalculate_priority(self, task: ReviewTask) -> bool:
        """Recalculate and update task priority.

        Args:
            task: Task to update

        Returns:
            True if priority changed
        """
        old_priority = task.priority
        new_priority = self.score(task)

        if new_priority != old_priority:
            task.priority = new_priority
            return True
        return False


# =============================================================================
# Factory Function
# =============================================================================

def create_priority_scorer(
    config: Optional[PriorityScorerConfig] = None,
) -> PriorityScorer:
    """Create a PriorityScorer instance.

    Args:
        config: Optional configuration

    Returns:
        PriorityScorer instance
    """
    return PriorityScorer(config)


# =============================================================================
# Export
# =============================================================================

__all__ = [
    "PriorityScorerConfig",
    "PriorityScorer",
    "create_priority_scorer",
]
