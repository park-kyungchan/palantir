"""
ReviewTask model for Human Review system.

Represents a task queued for human review with:
- Priority and status tracking
- Context from pipeline stages
- Metrics for processing analytics

Module Version: 1.0.0
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import Field, model_validator

from ...schemas.common import (
    BBox,
    MathpixBaseModel,
    PipelineStage,
    ReviewSeverity,
    utc_now,
)


# =============================================================================
# Enums
# =============================================================================

class ReviewStatus(str, Enum):
    """Status of a review task."""
    PENDING = "pending"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    REJECTED = "rejected"
    EXPIRED = "expired"
    ESCALATED = "escalated"


class ReviewDecision(str, Enum):
    """Decision made by reviewer."""
    APPROVE = "approve"
    REJECT = "reject"
    MODIFY = "modify"
    ESCALATE = "escalate"
    SKIP = "skip"


class ReviewPriority(str, Enum):
    """Priority levels for review tasks."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


# =============================================================================
# Task Context
# =============================================================================

class TaskContext(MathpixBaseModel):
    """Context information for a review task.

    Contains data from pipeline stages to help
    the reviewer understand what needs review.
    """
    # Source information
    image_id: str = Field(..., description="Source image identifier")
    pipeline_stage: PipelineStage = Field(..., description="Stage that flagged for review")

    # Element information
    element_type: str = Field(..., description="Type of element (node, edge, match, etc.)")
    element_id: str = Field(..., description="ID of the element under review")
    element_content: Optional[str] = Field(default=None, description="Textual content if applicable")
    element_bbox: Optional[BBox] = Field(default=None, description="Bounding box if applicable")

    # Confidence information
    original_confidence: float = Field(..., ge=0.0, le=1.0)
    applied_threshold: float = Field(..., ge=0.0, le=1.0)
    threshold_delta: float = Field(default=0.0, description="confidence - threshold")

    # Additional context
    review_reason: str = Field(..., description="Why this element needs review")
    related_elements: List[str] = Field(default_factory=list, description="IDs of related elements")

    # Stage-specific context
    stage_context: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional context from the pipeline stage"
    )

    @model_validator(mode="after")
    def compute_delta(self) -> "TaskContext":
        """Compute threshold delta.

        Uses object.__setattr__ to bypass validate_assignment and avoid recursion.
        """
        object.__setattr__(
            self, "threshold_delta",
            self.original_confidence - self.applied_threshold
        )
        return self


class TaskMetrics(MathpixBaseModel):
    """Metrics for review task processing."""
    # Time metrics
    created_at: datetime = Field(default_factory=utc_now)
    assigned_at: Optional[datetime] = Field(default=None)
    started_at: Optional[datetime] = Field(default=None)
    completed_at: Optional[datetime] = Field(default=None)

    # Duration calculations
    queue_time_ms: Optional[float] = Field(default=None, description="Time from creation to assignment")
    review_time_ms: Optional[float] = Field(default=None, description="Time from start to completion")
    total_time_ms: Optional[float] = Field(default=None, description="Time from creation to completion")

    # Attempt tracking
    assignment_count: int = Field(default=0, description="Number of times assigned")
    escalation_count: int = Field(default=0, description="Number of times escalated")

    def record_assignment(self) -> None:
        """Record task assignment."""
        self.assigned_at = datetime.now(timezone.utc)
        self.assignment_count += 1
        if self.created_at:
            delta = (self.assigned_at - self.created_at).total_seconds() * 1000
            self.queue_time_ms = delta

    def record_start(self) -> None:
        """Record review start."""
        self.started_at = datetime.now(timezone.utc)

    def record_completion(self) -> None:
        """Record review completion."""
        self.completed_at = datetime.now(timezone.utc)
        if self.started_at:
            delta = (self.completed_at - self.started_at).total_seconds() * 1000
            self.review_time_ms = delta
        if self.created_at:
            delta = (self.completed_at - self.created_at).total_seconds() * 1000
            self.total_time_ms = delta

    def record_escalation(self) -> None:
        """Record task escalation."""
        self.escalation_count += 1


# =============================================================================
# Review Task
# =============================================================================

class ReviewTask(MathpixBaseModel):
    """A task queued for human review.

    Represents a single element that requires human verification,
    containing all context needed for the reviewer to make a decision.

    Usage:
        task = ReviewTask(
            task_id="task-123",
            priority=ReviewPriority.HIGH,
            context=TaskContext(
                image_id="img-456",
                pipeline_stage=PipelineStage.ALIGNMENT,
                element_type="matched_pair",
                element_id="pair-789",
                original_confidence=0.55,
                applied_threshold=0.60,
                review_reason="Below threshold"
            )
        )
    """
    # Identifiers
    task_id: str = Field(..., description="Unique task identifier")
    image_id: str = Field(..., description="Source image identifier")

    # Priority and status
    priority: ReviewPriority = Field(default=ReviewPriority.MEDIUM)
    status: ReviewStatus = Field(default=ReviewStatus.PENDING)
    severity: ReviewSeverity = Field(default=ReviewSeverity.MEDIUM)

    # Assignment
    assigned_to: Optional[str] = Field(default=None, description="Reviewer ID")
    assigned_queue: Optional[str] = Field(default=None, description="Queue name")

    # Context
    context: TaskContext = Field(..., description="Review context information")

    # Scheduling
    created_at: datetime = Field(default_factory=utc_now)
    due_at: Optional[datetime] = Field(default=None, description="Optional deadline")
    expires_at: Optional[datetime] = Field(default=None, description="Auto-expire time")

    # Metrics
    metrics: TaskMetrics = Field(default_factory=TaskMetrics)

    # Result
    decision: Optional[ReviewDecision] = Field(default=None)
    decision_reason: Optional[str] = Field(default=None)

    # Version tracking
    version: int = Field(default=1, description="Optimistic locking version")

    @model_validator(mode="after")
    def sync_image_id(self) -> "ReviewTask":
        """Ensure image_id is synced with context."""
        if self.context and hasattr(self.context, 'image_id'):
            if not self.image_id:
                self.image_id = self.context.image_id
        return self

    @property
    def is_overdue(self) -> bool:
        """Check if task is past due date."""
        if self.due_at is None:
            return False
        return datetime.now(timezone.utc) > self.due_at

    @property
    def is_expired(self) -> bool:
        """Check if task has expired."""
        if self.expires_at is None:
            return False
        return datetime.now(timezone.utc) > self.expires_at

    def assign(self, reviewer_id: str) -> None:
        """Assign task to a reviewer."""
        self.assigned_to = reviewer_id
        self.status = ReviewStatus.ASSIGNED
        self.metrics.record_assignment()
        self.version += 1

    def start(self) -> None:
        """Mark task as in progress."""
        self.status = ReviewStatus.IN_PROGRESS
        self.metrics.record_start()
        self.version += 1

    def complete(self, decision: ReviewDecision, reason: Optional[str] = None) -> None:
        """Complete the review."""
        self.status = ReviewStatus.COMPLETED
        self.decision = decision
        self.decision_reason = reason
        self.metrics.record_completion()
        self.version += 1

    def escalate(self, reason: str) -> None:
        """Escalate the task."""
        self.status = ReviewStatus.ESCALATED
        self.decision = ReviewDecision.ESCALATE
        self.decision_reason = reason
        self.metrics.record_escalation()
        self.assigned_to = None  # Unassign for reassignment
        self.version += 1

    def expire(self) -> None:
        """Mark task as expired."""
        self.status = ReviewStatus.EXPIRED
        self.version += 1


# =============================================================================
# Export
# =============================================================================

__all__ = [
    # Enums
    "ReviewStatus",
    "ReviewDecision",
    "ReviewPriority",
    # Models
    "TaskContext",
    "TaskMetrics",
    "ReviewTask",
]
