---
name: build
description: |
  Interactive Component Builder (Boris Cherny Pattern).
  Two modes: Concept Mode for research-driven builds, Direct Mode for Q&A component creation.
  V2.1.0: Claude Code V2.1.19 compatibility (once, SubagentStop, UserPromptSubmit, indexed args).
user-invocable: true
disable-model-invocation: false
context: standard
model: opus
version: "2.1.0"
argument-hint: ["concept"] | [agent|skill|hook] [--resume id]
---

# /build Skill - Interactive Component Builder

> **Version:** 2.1.0 | **Context:** standard | **Model:** opus | **Claude Code:** V2.1.19+

---

## Purpose

Enhanced builder with two modes:
1. **Concept Mode**: `/build "concept-name"` - Three-phase research, roadmap, and build
2. **Direct Mode**: `/build agent|skill|hook` - Traditional Q&A rounds

---

## Three-Phase Pattern Overview

```
┌───────────────────────────────────────────────────────────┐
│ /build "Progressive-Disclosure" (Concept Mode)            │
├───────────────────────────────────────────────────────────┤
│                                                           │
│ PHASE 0: RESEARCH (Delegated to build-research.md)        │
│   └─ Task(subagent_type="claude-code-guide")              │
│      └─ Discover all relevant capabilities                │
│      └─ Save to .agent/builds/{id}/research.json          │
│                                                           │
│ PHASE 1: ROADMAP (L1/L2/L3 Progressive Disclosure)        │
│   ├─ L1: Summary (500 tokens)                             │
│   │   "Found 12 capabilities across 3 categories"         │
│   ├─ L2: Index (complexity levels)                        │
│   │   Level 0/50/100 options                              │
│   └─ L3: Details (on-demand via Read)                     │
│                                                           │
│ PHASE 2: BUILD (Multi-round Selection)                    │
│   ├─ Round 1: Target complexity level (0/50/100)          │
│   ├─ Round 2-N: Feature selection (4 per round)           │
│   └─ Generate artifacts                                   │
│                                                           │
└───────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────┐
│ /build agent|skill|hook (Direct Mode)                     │
├───────────────────────────────────────────────────────────┤
│ Traditional Q&A rounds for component creation             │
│ (See Phase 3: Type Selection below)                       │
└───────────────────────────────────────────────────────────┘
```

---

## Initialization

Parse `$ARGUMENTS` to determine build mode:

```python
args = "$ARGUMENTS".strip()
build_mode = None
concept = None
component_type = None
resume_id = None

# Priority 1: Resume flag
if "--resume" in args:
    parts = args.split("--resume")
    resume_id = parts[1].strip().split()[0] if len(parts) > 1 else None
    build_mode = "resume"

# Priority 2: Concept mode (quoted string)
elif args.startswith('"') or args.startswith("'"):
    concept = args.strip('"').strip("'")
    build_mode = "concept"

# Priority 3: Direct mode (agent/skill/hook)
elif args.split()[0] in ["agent", "skill", "hook"] if args else False:
    component_type = args.split()[0]
    build_mode = "direct"

# Priority 4: No args → prompt selection
else:
    build_mode = "select"
```

### Build Mode Decision Tree

| Input | Mode | Next Phase |
|-------|------|------------|
| `--resume pd-a1b2` | resume | Load state from `.agent/builds/{id}/` |
| `"Progressive-Disclosure"` | concept | Phase 0: Research |
| `agent` | direct | Phase 3: Type Selection (skip to agent) |
| (empty) | select | Phase 3: Type Selection (prompt) |

---

## Phase 0: Research (Concept Mode Only)

**Triggered by:** `/build "concept-name"`

### 0.1 Delegate to build-research.md

```python
# Invoke build-research skill for Phase 0
# This skill:
# 1. Generates build_id (e.g., "pro-a1b2")
# 2. Delegates to claude-code-guide
# 3. Saves research.json
# 4. Returns L1 summary

# The skill handles all research logic internally
# Main Agent receives L1 summary with:
# - buildId
# - complexityOptions (Level 0/50/100)
# - l2Path for detailed research
```

### 0.2 Research Output (L1 Summary)

After build-research.md completes:

```yaml
buildId: "pro-a1b2"
concept: "Progressive-Disclosure"
summary: "Found 14 capabilities across 4 categories"
status: success
complexityOptions:
  - level: 0
    name: "Basic"
    capabilities: 4
  - level: 50
    name: "Recommended"
    capabilities: 9
  - level: 100
    name: "Full"
    capabilities: 14
l2Path: ".agent/builds/pro-a1b2/research.json"
nextActionHint: "Select complexity level"
```

→ Proceed to Phase 1: Roadmap

---

## Phase 1: Roadmap (Concept Mode Only)

**Triggered after:** Phase 0 completes with L1 summary

### 1.1 Complexity Level Selection

```
AskUserQuestion(
  questions=[{
    "question": "어떤 복잡도 레벨을 선택하시겠습니까?",
    "header": "Complexity",
    "options": [
      {"label": "Level 0 - Basic (4 capabilities)", "description": "Essential features: L1/L2 format, basic validation"},
      {"label": "Level 50 - Recommended (9 capabilities)", "description": "Production-ready: priority system, output preservation"},
      {"label": "Level 100 - Full (14 capabilities)", "description": "All features: context optimization, lazy loading"},
      {"label": "Custom - Manual Selection", "description": "Choose individual capabilities"}
    ],
    "multiSelect": false
  }]
)
```

### 1.2 Roadmap Presentation (Based on Selection)

After level selection, present the roadmap from research.json:

```markdown
## Build Roadmap: {concept}

**Build ID:** `{buildId}`
**Selected Level:** {level} ({name})
**Capabilities:** {count}

### Included Capabilities

| ID | Name | Category | Description |
|----|------|----------|-------------|
| S1 | pd-inject | skill | Core L1/L2 format injection |
| H1 | pre-task-inject | hook | Format enforcement |
| ... | ... | ... | ... |

### Dependencies Resolved
- [S1] → [S2], [H1] (automatically included)

### Next Steps
Proceed to Phase 2: Build to generate files?
```

### 1.3 Roadmap Confirmation

```
AskUserQuestion(
  questions=[{
    "question": "Roadmap을 확인하셨나요? 빌드를 진행하시겠습니까?",
    "header": "Confirm",
    "options": [
      {"label": "Yes, proceed to build", "description": "Generate files for selected capabilities"},
      {"label": "Change level", "description": "Select different complexity level"},
      {"label": "Custom selection", "description": "Manually add/remove capabilities"},
      {"label": "Save roadmap only", "description": "Exit without building"}
    ],
    "multiSelect": false
  }]
)
```

→ If "Yes", proceed to Phase 2: Build
→ If "Custom selection", proceed to multi-round capability selection

---

## Phase 2: Build (Concept Mode Multi-Round Selection)

**Triggered after:** Phase 1 confirmation

### 2.1 Capability Selection (If Custom or Level 50+)

For levels with many capabilities, batch into rounds (4 options per round):

**Round 1: Skills**
```
AskUserQuestion(
  questions=[{
    "question": "포함할 Skill을 선택하세요",
    "header": "Skills",
    "options": [
      {"label": "[S1] pd-inject (Required)", "description": "Core L1/L2 format injection"},
      {"label": "[S2] priority-handler", "description": "Priority-based reading strategy"},
      {"label": "[S3] token-estimator", "description": "Section token estimation"},
      {"label": "[S4] recommended-read", "description": "Auto-populate recommendedRead"}
    ],
    "multiSelect": true
  }]
)
```

**Round 2: Agents**
```
AskUserQuestion(
  questions=[{
    "question": "포함할 Agent를 선택하세요",
    "header": "Agents",
    "options": [
      {"label": "[A1] l1l2-validator", "description": "Validates L1/L2 output format"},
      {"label": "[A2] progressive-reader", "description": "Reads L2 sections on-demand"},
      {"label": "Skip agents", "description": "No agents needed"}
    ],
    "multiSelect": true
  }]
)
```

**Round 3: Hooks**
```
AskUserQuestion(
  questions=[{
    "question": "포함할 Hook을 선택하세요",
    "header": "Hooks",
    "options": [
      {"label": "[H1] pre-task-inject (Required)", "description": "Injects L1/L2 format"},
      {"label": "[H2] post-task-validate", "description": "Validates L1 compliance"},
      {"label": "[H3] priority-alert", "description": "CRITICAL priority notification"},
      {"label": "[H4] output-preserve", "description": "Preserves L2 files"}
    ],
    "multiSelect": true
  }]
)
```

### 2.2 Selection Persistence

Save selections to `.agent/builds/{buildId}/selection.json`:

```json
{
  "buildId": "pro-a1b2",
  "selectedLevel": 50,
  "selectedCapabilities": ["S1", "S2", "A1", "H1", "H2", "H3"],
  "rounds": [
    {"roundNumber": 1, "category": "skills", "selected": ["S1", "S2"]},
    {"roundNumber": 2, "category": "agents", "selected": ["A1"]},
    {"roundNumber": 3, "category": "hooks", "selected": ["H1", "H2", "H3"]}
  ],
  "status": "selection_complete",
  "timestamp": "2026-01-23T15:00:00Z"
}
```

### 2.3 File Generation

Generate files for selected capabilities:

```python
for capability in selected_capabilities:
    template = load_template(capability.category)
    content = render_template(template, capability)
    write_file(capability.output_path, content)

# Save artifacts list
artifacts = {
    "buildId": build_id,
    "generated_files": [
        {"path": ".claude/skills/pd-inject.md", "type": "skill"},
        {"path": ".claude/hooks/pre-task-inject.sh", "type": "hook"},
        ...
    ],
    "timestamp": datetime.now().isoformat()
}
save_json(f".agent/builds/{build_id}/artifacts.json", artifacts)
```

### 2.4 Build Complete Summary

```markdown
## Build Complete: {concept}

**Build ID:** `{buildId}`
**Generated Files:** {count}

### Files Created

| Type | Path | Status |
|------|------|--------|
| skill | .claude/skills/pd-inject.md | ✅ Created |
| hook | .claude/hooks/pre-task-inject.sh | ✅ Created |
| ... | ... | ... |

### Test Commands

```bash
# Test skill
/pd-inject "test input"

# Test hook (triggered automatically on Task tool)
```

### Resume Command
```
/build --resume {buildId}
```
```

---

## Phase 3: Type Selection (Direct Mode)

If `component_type` is None and `resume_name` is None:

```
AskUserQuestion(
  questions=[{
    "question": "어떤 컴포넌트를 생성하시겠습니까?",
    "header": "Type",
    "options": [
      {"label": "Agent (Recommended)", "description": "Specialized subagent with ODA governance"},
      {"label": "Skill", "description": "Reusable /command workflow"},
      {"label": "Hook", "description": "Event-driven script"}
    ],
    "multiSelect": false
  }]
)
```

---

## Phase 4: Q&A Execution (Direct Mode)

### Agent Builder (15 Rounds)

#### Rounds 1-3: Core Identity

**Round 1: Agent Name**
```
AskUserQuestion(
  questions=[
    {
      "question": "Agent 이름을 입력하세요 (예: security-validator, clarify-agent)",
      "header": "Name",
      "options": [
        {"label": "직접 입력", "description": "lowercase, hyphens. .claude/agents/{name}.md로 저장됩니다"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `name` (validation: `^[a-z][a-z0-9-]{0,63}$`)

**Round 2: Description**
```
AskUserQuestion(
  questions=[
    {
      "question": "Agent 설명을 입력하세요",
      "header": "Description",
      "options": [
        {"label": "직접 입력", "description": "Claude 자동 호출 트리거에 사용됩니다"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `description`

**Description Best Practices**
| 키워드 | 효과 |
|--------|------|
| "proactively" | 더 적극적인 자동 호출 |
| "when the user asks about..." | 특정 질문에 트리거 |
| "Use this agent for..." | 명확한 사용 사례 정의 |

**Round 3: Auto-Invocation Control**
```
AskUserQuestion(
  questions=[
    {
      "question": "Claude 자동 호출 정책을 선택하세요",
      "header": "Auto-invoke",
      "options": [
        {"label": "Enable (Recommended)", "description": "Claude가 description 매칭으로 자동 호출"},
        {"label": "Disable", "description": "Task(subagent_type='agent-name')으로만 호출 가능"},
        {"label": "Proactive", "description": "description에 'proactively' 추가. 더 적극적 자동 호출"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: disable-model-invocation preference

#### Rounds 4-6: Tool Configuration

**Round 4: Tool Access Pattern**
```
AskUserQuestion(
  questions=[
    {
      "question": "허용할 도구 패턴을 선택하세요",
      "header": "Tools",
      "options": [
        {"label": "Read-only (Recommended)", "description": "Read, Grep, Glob. 안전한 분석 전용"},
        {"label": "Standard", "description": "Read, Grep, Glob, Bash, Edit, Write. 일반 개발 작업"},
        {"label": "Full (Task 포함)", "description": "모든 도구. 다른 에이전트 호출 가능"},
        {"label": "Custom", "description": "개별 도구 선택"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Tool Access Presets**
| Preset | Tools | Use Case |
|--------|-------|----------|
| Read-only | Read, Grep, Glob | 코드 분석, 보안 검토 |
| Standard | + Bash, Edit, Write | 일반 개발 작업 |
| Full | + Task, WebSearch, TodoWrite | 오케스트레이션, 연구 |

**Round 5: Tool Restrictions (if Custom)**
```
AskUserQuestion(
  questions=[
    {
      "question": "도구 제한 방식을 선택하세요",
      "header": "Restriction",
      "options": [
        {"label": "Allow List", "description": "allowedTools: 허용할 도구만 명시"},
        {"label": "Deny List", "description": "disallowedTools: 차단할 도구만 명시"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Round 6: Tool Selection (if Custom)**
```
AskUserQuestion(
  questions=[
    {
      "question": "허용/차단할 도구를 선택하세요 (1/2: 기본 도구)",
      "header": "Basic Tools",
      "options": [
        {"label": "Read", "description": "파일 읽기"},
        {"label": "Grep", "description": "패턴 검색"},
        {"label": "Glob", "description": "파일 찾기"},
        {"label": "Edit", "description": "파일 편집"},
        {"label": "Write", "description": "파일 생성"},
        {"label": "Bash", "description": "셸 명령 실행"},
        {"label": "More Tools...", "description": "추가 도구 보기"}
      ],
      "multiSelect": true
    }
  ]
)
```
→ If "More Tools..." selected:
```
AskUserQuestion(
  questions=[
    {
      "question": "추가 도구를 선택하세요 (2/2)",
      "header": "Advanced Tools",
      "options": [
        {"label": "Task", "description": "서브에이전트 위임"},
        {"label": "AskUserQuestion", "description": "사용자 질문/확인"},
        {"label": "WebSearch", "description": "웹 검색"},
        {"label": "WebFetch", "description": "웹 콘텐츠 가져오기"},
        {"label": "NotebookEdit", "description": "Jupyter 노트북 편집"},
        {"label": "TaskCreate/Update/List/Get", "description": "Native Task System (V2.1.16+)"}
      ],
      "multiSelect": true
    }
  ]
)
```

**Tool Categories Reference (V2.0 → V2.1.19)**
| Category | Tools | Description |
|----------|-------|-------------|
| **File Ops** | Read, Write, Edit | 파일 읽기/쓰기/편집 |
| **Search** | Grep, Glob | 패턴/파일 검색 |
| **Execution** | Bash | 셸 명령 실행 |
| **Delegation** | Task | 서브에이전트 위임 |
| **User** | AskUserQuestion | 사용자 상호작용 |
| **Web** | WebSearch, WebFetch | 웹 검색/콘텐츠 |
| **Notebook** | NotebookEdit | Jupyter 노트북 |
| **Task System** | TaskCreate, TaskUpdate, TaskList, TaskGet | Native Task (V2.1.16+) |
| **Deprecated** | TodoWrite | → TaskCreate로 대체 |

#### Rounds 7-9: Context & Subagent Configuration

**Round 7: Subagent Type**
```
AskUserQuestion(
  questions=[
    {
      "question": "에이전트를 어떤 서브에이전트 타입으로 등록하시겠습니까?",
      "header": "Type",
      "options": [
        {"label": "Custom (새 타입)", "description": "Task(subagent_type='agent-name')으로 호출"},
        {"label": "Explore Extension", "description": "Explore 에이전트의 확장 기능"},
        {"label": "Plan Extension", "description": "Plan 에이전트의 확장 기능"},
        {"label": "general-purpose", "description": "범용 에이전트로 등록"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Subagent Types Reference**
| Type | Context | Use Case |
|------|---------|----------|
| Explore | 빈 컨텍스트 | 코드베이스 탐색, 구조 분석 |
| Plan | 빈 컨텍스트 | 구현 계획, 설계 결정 |
| general-purpose | 현재 컨텍스트 복사 | 복잡한 다단계 작업 |
| Custom | 설정에 따름 | 특수 목적 에이전트 |

**Round 8: Mode**
```
AskUserQuestion(
  questions=[
    {
      "question": "실행 모드를 선택하세요",
      "header": "Mode",
      "options": [
        {"label": "default (Recommended)", "description": "표준 권한으로 실행"},
        {"label": "acceptEdits", "description": "Edit/Write 자동 승인"},
        {"label": "bypassPermissions", "description": "모든 권한 우회 (위험)"},
        {"label": "plan", "description": "계획 모드 (실행 전 승인 필요)"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Round 9: Integration Points**
```
AskUserQuestion(
  questions=[
    {
      "question": "다른 에이전트/스킬과의 연동을 설정하세요",
      "header": "Integration",
      "options": [
        {"label": "None", "description": "독립 실행"},
        {"label": "claude-code-guide", "description": "문서 검색 위임"},
        {"label": "Explore", "description": "코드 탐색 위임"},
        {"label": "Custom", "description": "직접 지정"}
      ],
      "multiSelect": true
    }
  ]
)
```

#### Rounds 10-12: Model & Execution

**Round 10: Model Selection**
```
AskUserQuestion(
  questions=[
    {
      "question": "사용할 모델을 선택하세요",
      "header": "Model",
      "options": [
        {"label": "haiku (Recommended)", "description": "빠른 응답, 단순 분석. 비용 효율적"},
        {"label": "sonnet", "description": "균형잡힌 성능. 복잡한 분석"},
        {"label": "opus", "description": "최대 품질. 복잡한 조율/계획"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `model`

**Model Selection Guide**
| Model | Tokens/Response | Best For |
|-------|-----------------|----------|
| haiku | ~2K | 간단한 검증, 빠른 분석 |
| sonnet | ~4K | 복잡한 분석, 코드 생성 |
| opus | ~8K | 아키텍처 설계, 복잡한 조율 |

**Round 11: Max Turns**
```
AskUserQuestion(
  questions=[
    {
      "question": "최대 실행 턴 수를 설정하세요",
      "header": "Max Turns",
      "options": [
        {"label": "10 (Default)", "description": "일반적인 작업에 충분"},
        {"label": "25", "description": "복잡한 다단계 작업"},
        {"label": "50", "description": "매우 복잡한 작업 (주의 필요)"},
        {"label": "Unlimited", "description": "제한 없음 (권장하지 않음)"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Round 12: Background Execution**
```
AskUserQuestion(
  questions=[
    {
      "question": "백그라운드 실행을 지원하시겠습니까?",
      "header": "Background",
      "options": [
        {"label": "No (Recommended)", "description": "동기 실행. 결과 즉시 반환"},
        {"label": "Yes", "description": "run_in_background=True 옵션 지원. 병렬 실행 가능"}
      ],
      "multiSelect": false
    }
  ]
)
```

#### Rounds 13-15: Output & Governance

**Round 13: Output Format**
```
AskUserQuestion(
  questions=[
    {
      "question": "출력 형식을 선택하세요",
      "header": "Output",
      "options": [
        {"label": "L1/L2/L3 (Recommended)", "description": "Progressive Disclosure. 토큰 효율적, 구조화된 출력"},
        {"label": "Conversational", "description": "자유 형식 응답"},
        {"label": "YAML", "description": "구조화된 YAML 출력"},
        {"label": "Custom", "description": "직접 정의"}
      ],
      "multiSelect": false
    }
  ]
)
```

**L1/L2/L3 Format Example**
```yaml
taskId: {8-char-id}
agentType: {agent-name}
summary: "1-2 sentence summary"
status: success | partial | failed
priority: CRITICAL | HIGH | MEDIUM | LOW
l2Index:
  - anchor: "#section"
    tokens: 500
    description: "section content"
l2Path: .agent/outputs/{agent}/{taskId}.md
nextActionHint: "suggested next step"
```

**Round 14: Skills Integration**
```
AskUserQuestion(
  questions=[
    {
      "question": "에이전트가 사전 로드할 스킬을 선택하세요",
      "header": "Skills",
      "options": [
        {"label": "None", "description": "스킬 사전 로드 없음"},
        {"label": "pd-analyzer", "description": "L1/L2/L3 분석 패턴"},
        {"label": "pd-injector", "description": "동적 컨텍스트 주입"},
        {"label": "Custom", "description": "직접 지정"}
      ],
      "multiSelect": true
    }
  ]
)
```

**Round 15: Hook Integration**
```
AskUserQuestion(
  questions=[
    {
      "question": "연동할 Hook 이벤트를 선택하세요",
      "header": "Hooks",
      "options": [
        {"label": "None", "description": "Hook 연동 없음"},
        {"label": "PreToolUse", "description": "에이전트 도구 실행 전 검증"},
        {"label": "PostToolUse", "description": "에이전트 도구 실행 후 로깅"},
        {"label": "SubagentStop", "description": "에이전트 종료 조건 제어"}
      ],
      "multiSelect": true
    }
  ]
)
```

**SubagentStop Hook Example**
```json
{
  "hooks": {
    "SubagentStop": [{
      "type": "command",
      "command": ".claude/hooks/agent-stop-condition.sh",
      "matcher": "{agent-name}"
    }]
  }
}
```

---

### Skill Builder (12 Rounds)

#### Rounds 1-3: Identity & Access Control

**Round 1: Name & Description**
```
AskUserQuestion(
  questions=[
    {
      "question": "스킬 이름을 입력하세요 (예: commit-push-pr, explore-l1l2l3)",
      "header": "Name",
      "options": [
        {"label": "직접 입력", "description": "lowercase, hyphens. /name 형식으로 호출됩니다"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `name` (validation: `^[a-z][a-z0-9-]{0,63}$`)

**Round 2: User Invocability**
```
AskUserQuestion(
  questions=[
    {
      "question": "사용자가 /name 형식으로 직접 호출할 수 있게 하시겠습니까?",
      "header": "Invocable",
      "options": [
        {"label": "Yes (Recommended)", "description": "user-invocable: true → 사용자가 /skill-name으로 호출 가능"},
        {"label": "No (Internal Only)", "description": "user-invocable: false → 다른 스킬/에이전트만 호출 가능"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `user-invocable`

**Round 3: Model Auto-Invocation**
```
AskUserQuestion(
  questions=[
    {
      "question": "Claude가 description 매칭으로 자동 호출할 수 있게 하시겠습니까?",
      "header": "Auto-Invoke",
      "options": [
        {"label": "Allow (Recommended)", "description": "disable-model-invocation: false → Claude가 적절할 때 자동 호출"},
        {"label": "Block", "description": "disable-model-invocation: true → Git 작업 등 민감한 스킬에 권장"},
        {"label": "Proactive", "description": "description에 'proactively' 포함 → 더 적극적 자동 호출"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `disable-model-invocation`

**Access Control Matrix (Reference)**
| Pattern | user-invocable | disable-model-invocation | Use Case |
|---------|---------------|-------------------------|----------|
| P1: User-Only | true | true | Git, orchestration |
| P2: Model-Only | false | false | Internal helpers |
| P3: Hybrid | true | false | General tools |
| P4: Disabled | false | true | Experimental |

#### Rounds 4-6: Execution Context

**Round 4: Context Mode**
```
AskUserQuestion(
  questions=[
    {
      "question": "실행 컨텍스트를 선택하세요",
      "header": "Context",
      "options": [
        {"label": "standard (Recommended)", "description": "메인 에이전트 컨텍스트에서 실행. 사용자와 직접 상호작용"},
        {"label": "fork", "description": "격리된 서브에이전트 컨텍스트. 토큰 효율성 4x 향상, 컨텍스트 오염 방지"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `context`

**Round 5: Subagent Type (if fork)**
```
AskUserQuestion(
  questions=[
    {
      "question": "fork 컨텍스트에서 사용할 서브에이전트 타입을 선택하세요",
      "header": "Agent",
      "options": [
        {"label": "Explore", "description": "빈 컨텍스트에서 코드베이스 분석. Read, Grep, Glob 전용"},
        {"label": "Plan", "description": "빈 컨텍스트에서 구현 계획 수립. 설계 결정 위임"},
        {"label": "general-purpose", "description": "현재 컨텍스트 복사본. 모든 도구 접근, 병렬 작업"},
        {"label": "claude-code-guide", "description": "PE 기법/문서 검색. WebSearch, WebFetch 접근"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `agent` (only if context: fork)

**Round 6: Model Selection**
```
AskUserQuestion(
  questions=[
    {
      "question": "사용할 모델을 선택하세요",
      "header": "Model",
      "options": [
        {"label": "haiku", "description": "빠른 응답, 단순 분석. 비용 효율적"},
        {"label": "sonnet (Recommended)", "description": "균형잡힌 성능. 대부분의 작업에 적합"},
        {"label": "opus", "description": "최대 품질. 복잡한 조율/계획에 권장"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `model`

#### Rounds 7-9: Tool Configuration

**Round 7: Allowed Tools**
```
AskUserQuestion(
  questions=[
    {
      "question": "허용할 도구를 선택하세요",
      "header": "Tools",
      "options": [
        {"label": "Read-only", "description": "Read, Grep, Glob. 안전한 분석 전용"},
        {"label": "Standard (Recommended)", "description": "Read, Grep, Glob, Edit, Write, Bash"},
        {"label": "Full", "description": "모든 도구 (Task, WebSearch, AskUserQuestion 등)"},
        {"label": "Custom", "description": "개별 도구 선택"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ If Custom: show multiSelect with all tools (see Agent Builder Round 6 for full list)

**Tool Presets Reference**
| Preset | Included Tools | Use Case |
|--------|---------------|----------|
| Read-only | Read, Grep, Glob | 분석, 코드 리뷰 |
| Standard | + Edit, Write, Bash | 일반 개발 작업 |
| Full | + Task, WebSearch, WebFetch, AskUserQuestion, NotebookEdit, TaskCreate/Update/List/Get | 오케스트레이션, 연구, 상호작용 |

**Round 8: Argument Hint & Indexed Access**
```
AskUserQuestion(
  questions=[
    {
      "question": "인수 힌트를 설정하시겠습니까? (Optional)",
      "header": "Arguments",
      "options": [
        {"label": "None", "description": "인수 없음"},
        {"label": "[file-path]", "description": "파일 경로 입력"},
        {"label": "[commit message]", "description": "커밋 메시지 입력"},
        {"label": "Custom", "description": "직접 입력"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `argument-hint`

**Indexed Argument Access (V2.1.19+)**
```bash
# 스킬 내부에서 인수 접근:
# /my-skill --resume session-123
# → $0 = "--resume", $1 = "session-123"

# 예시: /clarify --resume my-slug
if [[ "$0" == "--resume" ]]; then
    SLUG="$1"
    RESUME_MODE=true
fi
```

**Round 9: Skill-Level Hooks (V2.1.19+)**
```
AskUserQuestion(
  questions=[
    {
      "question": "스킬 레벨 Hook을 설정하시겠습니까?",
      "header": "Skill Hooks",
      "options": [
        {"label": "None", "description": "Hook 없음"},
        {"label": "Stop (Recommended)", "description": "스킬 완료 시 정리/로깅 실행"},
        {"label": "PreToolUse", "description": "스킬 내 특정 도구 실행 전 검증"},
        {"label": "PostToolUse", "description": "스킬 내 특정 도구 실행 후 로깅"},
        {"label": "Multiple", "description": "여러 Hook 조합"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ If Stop or Multiple selected:
```
AskUserQuestion(
  questions=[
    {
      "question": "Stop Hook 옵션을 설정하세요",
      "header": "Stop Options",
      "options": [
        {"label": "once: true (Recommended)", "description": "세션당 한 번만 실행"},
        {"label": "once: false", "description": "매번 실행"},
        {"label": "timeout: 120s", "description": "긴 처리에 적합"},
        {"label": "timeout: 60s (Default)", "description": "기본 타임아웃"}
      ],
      "multiSelect": true
    }
  ]
)
```

**Skill-Level Hooks YAML Format**
```yaml
# SKILL.md frontmatter
hooks:
  Stop:
    - type: command
      command: "/path/to/finalize.sh"
      timeout: 120000  # ms
      once: true       # V2.1.19+: 세션당 한 번만
  PreToolUse:
    - matcher: "AskUserQuestion"
      hooks:
        - type: command
          command: "/path/to/validate-qa.sh"
```
→ Collect: skill-level hooks configuration

#### Rounds 10-12: Advanced Features

**Round 10: Dynamic Context Injection**
```
AskUserQuestion(
  questions=[
    {
      "question": "동적 컨텍스트 주입(!`command` 구문)을 사용하시겠습니까?",
      "header": "Injection",
      "options": [
        {"label": "No (Recommended)", "description": "정적 컨텐츠만 사용"},
        {"label": "Yes", "description": "!`git status` 등 셸 명령 결과를 스킬 로드 시점에 주입"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: dynamic injection preference

**Round 11: Output Format**
```
AskUserQuestion(
  questions=[
    {
      "question": "출력 형식을 선택하세요",
      "header": "Output",
      "options": [
        {"label": "Conversational", "description": "자유 형식 응답"},
        {"label": "L1/L2/L3 (Recommended for fork)", "description": "Progressive Disclosure 형식. 토큰 효율적"},
        {"label": "YAML", "description": "구조화된 YAML 출력"},
        {"label": "Custom", "description": "직접 정의"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: output format preference

**Round 12: Version**
```
AskUserQuestion(
  questions=[
    {
      "question": "초기 버전을 설정하세요",
      "header": "Version",
      "options": [
        {"label": "1.0.0 (Recommended)", "description": "첫 안정 버전"},
        {"label": "0.1.0", "description": "초기 개발 버전"},
        {"label": "Custom", "description": "직접 입력"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `version`

---

### Hook Builder (14 Rounds)

#### Rounds 1-3: Identity & Event Type

**Round 1: Hook Name**
```
AskUserQuestion(
  questions=[
    {
      "question": "Hook 이름을 입력하세요 (예: security-validator, pre-commit-check)",
      "header": "Name",
      "options": [
        {"label": "직접 입력", "description": "lowercase, hyphens. 파일명: {name}.sh 또는 {name}.py"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: hook file name

**Round 2: Event Type**
```
AskUserQuestion(
  questions=[
    {
      "question": "어떤 이벤트에 Hook을 트리거하시겠습니까?",
      "header": "Event",
      "options": [
        {"label": "PreToolUse (Recommended)", "description": "도구 실행 전. 입력 검증/수정, 권한 제어"},
        {"label": "PostToolUse", "description": "도구 실행 후. 출력 변환, 로깅"},
        {"label": "SessionStart", "description": "세션 시작 시 초기화. 컨텍스트 로드"},
        {"label": "SessionEnd", "description": "세션 종료 시 정리. 로그 저장"},
        {"label": "More Events...", "description": "추가 이벤트 옵션 보기"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ If "More Events..." selected:
```
AskUserQuestion(
  questions=[
    {
      "question": "추가 이벤트를 선택하세요",
      "header": "More Events",
      "options": [
        {"label": "PreCompact", "description": "컨텍스트 압축 전. 상태 저장"},
        {"label": "PermissionRequest", "description": "권한 요청 시. 자동 승인/거부"},
        {"label": "Notification", "description": "비동기 알림. 메인 플로우 비차단"},
        {"label": "Stop", "description": "에이전트 종료 조건 제어"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ If V2.1+ events needed:
```
AskUserQuestion(
  questions=[
    {
      "question": "V2.1+ 신규 이벤트를 선택하세요",
      "header": "V2.1+ Events",
      "options": [
        {"label": "SubagentStop (V2.1.16+)", "description": "서브에이전트 종료 시 정리"},
        {"label": "UserPromptSubmit (V2.1.19+)", "description": "사용자 입력 전 검증"},
        {"label": "SubagentStart (V2.1.16+)", "description": "서브에이전트 시작 시 초기화"},
        {"label": "PostToolUseFailure (V2.1.0+)", "description": "도구 실행 실패 시 처리"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: event type

**Event Types Reference (V2.0 → V2.1.19 Complete)**
| Event | Blocking | Use Cases | Since |
|-------|----------|-----------|-------|
| **V2.0 기본** | | | |
| PreToolUse | Yes | 입력 검증, 권한 제어, 컨텍스트 주입 | V2.0 |
| PostToolUse | Yes | 출력 변환, 로깅, 캐싱 | V2.0 |
| SessionStart | No | 세션 초기화, 환경 설정 | V2.0 |
| SessionEnd | No | 세션 정리, 로그 저장 | V2.0 |
| PreCompact | Yes | 컨텍스트 압축 전 상태 저장 | V2.0 |
| PermissionRequest | Yes | 권한 요청 자동화 | V2.0 |
| Notification | No | Slack 알림, 대시보드 업데이트 | V2.0 |
| Stop | N/A | 자동 종료 조건 | V2.0 |
| **V2.1+ 신규** | | | |
| SubagentStart | No | 서브에이전트 시작 시 초기화 | V2.1.16 |
| SubagentStop | Yes | 서브에이전트 종료 후 정리, 결과 수집 | V2.1.16 |
| PostToolUseFailure | Yes | 도구 실행 실패 시 에러 처리 | V2.1.0 |
| UserPromptSubmit | Yes | 사용자 입력 검증, 자동 컨텍스트 추가 | V2.1.19 |

**Event Categories**
- **Lifecycle**: SessionStart, SessionEnd, PreCompact
- **Tool**: PreToolUse, PostToolUse, PostToolUseFailure
- **Permission**: PermissionRequest
- **Subagent**: SubagentStart, SubagentStop
- **User**: UserPromptSubmit
- **Control**: Stop, Notification

**Round 3: Language**
```
AskUserQuestion(
  questions=[
    {
      "question": "Hook 스크립트 언어를 선택하세요",
      "header": "Language",
      "options": [
        {"label": "Bash (Recommended)", "description": "빠른 실행, 간단한 로직. jq로 JSON 처리"},
        {"label": "Python", "description": "복잡한 로직, 외부 라이브러리 사용"},
        {"label": "Node.js", "description": "JavaScript 기반 로직"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: script language

#### Rounds 4-6: Trigger Configuration

**Round 4: Matcher Pattern**
```
AskUserQuestion(
  questions=[
    {
      "question": "어떤 도구/이벤트에 매칭하시겠습니까?",
      "header": "Matcher",
      "options": [
        {"label": "All Tools (*)", "description": "모든 도구 실행에 트리거"},
        {"label": "Specific Tool", "description": "Bash, Read, Edit 등 특정 도구에만 트리거"},
        {"label": "Pattern Match", "description": "정규식 패턴 매칭 (예: Edit:*.py)"},
        {"label": "Custom", "description": "직접 입력"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ If Specific Tool, show multiSelect:
```
AskUserQuestion(
  questions=[
    {
      "question": "트리거할 도구를 선택하세요",
      "header": "Tools",
      "options": [
        {"label": "Bash", "description": "셸 명령 실행 전/후"},
        {"label": "Edit", "description": "파일 편집 전/후"},
        {"label": "Write", "description": "파일 생성 전/후"},
        {"label": "Read", "description": "파일 읽기 전/후"}
      ],
      "multiSelect": true
    }
  ]
)
```

**Round 5: Timeout**
```
AskUserQuestion(
  questions=[
    {
      "question": "Hook 실행 타임아웃을 설정하세요",
      "header": "Timeout",
      "options": [
        {"label": "60s (Default)", "description": "PreToolUse/PostToolUse 기본값"},
        {"label": "120s", "description": "복잡한 검증 로직에 권장"},
        {"label": "10s (Notification)", "description": "Notification 이벤트 기본값"},
        {"label": "Custom", "description": "직접 입력 (초 단위)"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `timeout_ms`

**Round 5.5: Once Parameter (V2.1.16+)**
```
AskUserQuestion(
  questions=[
    {
      "question": "Hook을 세션당 한 번만 실행하시겠습니까?",
      "header": "Once",
      "options": [
        {"label": "No (Default)", "description": "once: false. 매번 트리거될 때마다 실행"},
        {"label": "Yes (Recommended for init)", "description": "once: true. 세션당 첫 번째 트리거에만 실행"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `once`

**`once: true` Use Cases**
| Scenario | Example |
|----------|---------|
| 초기화 Hook | 세션 시작 시 컨텍스트 로드 (한 번만) |
| 정리 Hook | 스킬 완료 후 YAML finalize (한 번만) |
| 알림 Hook | 첫 번째 오류에만 Slack 알림 |

**Round 6: Hook Type**
```
AskUserQuestion(
  questions=[
    {
      "question": "Hook 타입을 선택하세요",
      "header": "Type",
      "options": [
        {"label": "command (Recommended)", "description": "셸 명령어 직접 실행. 빠르고 간단"},
        {"label": "prompt", "description": "프롬프트 주입. AI 컨텍스트 수정"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: hook type

#### Rounds 7-10: Input/Output Configuration

**Round 7: Input Fields (자동 제공)**
```
PreToolUse Input (자동 제공):
- session_id: 현재 세션 ID
- tool_name: 호출되는 도구명
- tool_input: 도구 입력 JSON
- transcript_so_far: 현재까지의 대화 내용

PostToolUse Input (자동 제공):
- tool_response: 도구 실행 결과
- tool_status: success/error
```

**Round 8: Permission Decision (PreToolUse only)**
```
AskUserQuestion(
  questions=[
    {
      "question": "권한 제어 로직을 어떻게 설정하시겠습니까?",
      "header": "Permission",
      "options": [
        {"label": "Always Allow", "description": "permissionDecision: allow. 검증 목적으로만 사용"},
        {"label": "Conditional", "description": "조건에 따라 allow/deny 결정"},
        {"label": "Require Approval", "description": "permissionDecision: requireApproval. 사용자 확인 요청"},
        {"label": "Block Pattern", "description": "특정 패턴 자동 거부 (예: rm -rf)"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Permission Decision Values**
| Decision | Effect |
|----------|--------|
| `allow` | 도구 실행 허용 |
| `deny` | 도구 실행 차단 |
| `requireApproval` | 사용자 확인 후 결정 |

**Round 9: Input Modification**
```
AskUserQuestion(
  questions=[
    {
      "question": "도구 입력을 수정하시겠습니까? (PreToolUse only)",
      "header": "Modify Input",
      "options": [
        {"label": "No (Recommended)", "description": "입력 변경 없이 검증만 수행"},
        {"label": "Yes", "description": "updatedInput으로 도구 입력 수정 가능"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `updatedInput` usage

**Round 10: Context Injection**
```
AskUserQuestion(
  questions=[
    {
      "question": "추가 컨텍스트를 주입하시겠습니까?",
      "header": "Context",
      "options": [
        {"label": "No", "description": "컨텍스트 주입 없음"},
        {"label": "System Reminder", "description": "additionalContext로 시스템 알림 주입"},
        {"label": "User Message", "description": "도구 결과에 추가 정보 첨부"}
      ],
      "multiSelect": false
    }
  ]
)
```
→ Collect: `additionalContext` preference

**Output Fields Reference**
```yaml
hookSpecificOutput:
  # PreToolUse
  permissionDecision: "allow" | "deny" | "requireApproval"
  updatedInput: {}      # 수정된 도구 입력
  additionalContext:    # 추가 컨텍스트
    prefix: ""
    suffix: ""

  # PostToolUse
  updatedResult: {}     # 수정된 도구 출력
```

#### Rounds 11-14: Advanced Configuration

**Round 11: Environment Variables**
```
AskUserQuestion(
  questions=[
    {
      "question": "환경 변수를 사용하시겠습니까?",
      "header": "Env Vars",
      "options": [
        {"label": "No", "description": "환경 변수 사용 안함"},
        {"label": "PROJECT_ROOT", "description": "현재 프로젝트 루트 경로"},
        {"label": "CLAUDE_SESSION_ID (V2.1.0+)", "description": "현재 Claude 세션 ID. 크로스-세션 추적용"},
        {"label": "Custom", "description": "직접 정의"}
      ],
      "multiSelect": true
    }
  ]
)
```

**Environment Variables Reference (V2.1.19)**
| Variable | Description | Use Case |
|----------|-------------|----------|
| `${CLAUDE_SESSION_ID}` | 현재 Claude 세션 고유 ID | 로그 연결, 트랜스크립트 추적 |
| `${PROJECT_ROOT}` | 프로젝트 루트 경로 | 상대 경로 계산 |
| `${CLAUDE_TASK_LIST_ID}` | 현재 Task List ID | Task System 연동 |

**Session ID 활용 예시**
```bash
#!/bin/bash
# Hook 스크립트에서 세션 추적

SESSION_ID="${CLAUDE_SESSION_ID:-unknown}"
LOG_FILE=".agent/logs/hook-${SESSION_ID}.log"

echo "[$(date -Iseconds)] Hook executed" >> "$LOG_FILE"
```

```yaml
# YAML 로그에서 세션 연결
metadata:
  id: "clarify_my-request_20260124"
  session_id: "${CLAUDE_SESSION_ID}"  # 메인 세션과 연결
```

**Round 12: Logging Configuration**
```
AskUserQuestion(
  questions=[
    {
      "question": "로깅 설정을 선택하세요",
      "header": "Logging",
      "options": [
        {"label": "None", "description": "로깅 없음"},
        {"label": "Standard (.agent/logs/)", "description": ".agent/logs/{hook-name}.log에 기록"},
        {"label": "Audit Trail", "description": ".agent/logs/audit.log에 감사 로그 기록"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Round 13: Blocking Behavior**
```
AskUserQuestion(
  questions=[
    {
      "question": "Hook 실패 시 동작을 선택하세요",
      "header": "On Failure",
      "options": [
        {"label": "Continue (Recommended)", "description": "Hook 실패해도 도구 실행 진행"},
        {"label": "Block", "description": "Hook 실패 시 도구 실행 중단"},
        {"label": "Warn", "description": "경고 메시지 표시 후 진행"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Round 14: Settings Registration**
```
AskUserQuestion(
  questions=[
    {
      "question": "settings.json에 자동 등록하시겠습니까?",
      "header": "Register",
      "options": [
        {"label": "Yes (Recommended)", "description": ".claude/settings.json hooks 배열에 자동 추가"},
        {"label": "No (Manual)", "description": "수동으로 등록. 설정 파일 위치 안내"}
      ],
      "multiSelect": false
    }
  ]
)
```

**Settings.json Hook Entry Format**
```json
{
  "hooks": {
    "{EventType}": [
      {
        "type": "command",
        "command": ".claude/hooks/{name}.sh",
        "matcher": "{matcher}",
        "timeout": {timeout_ms}
      }
    ]
  }
}
```

---

## Phase 5: Draft Generation

After all rounds, generate draft file:

```markdown
# Build Draft: {type} - {name}

## INDEX
- Type: {Agent | Skill | Hook}
- Name: {collected_name}
- Status: READY_FOR_GENERATION
- Rounds Completed: {N}/{total}

## Collected Fields
| Field | Value | Round |
|-------|-------|-------|
{field_table}

## Generated Preview
```{yaml_or_code}
{template_with_values}
```

## Target Path
{output_path}

## Test Command
{test_command}
```

Save to: `.agent/plans/create_drafts/{type}_{name}.md`

---

## Phase 6: Confirmation & Generation

```
AskUserQuestion(
  questions=[{
    "question": "생성된 미리보기를 확인하셨나요? 파일을 생성하시겠습니까?",
    "header": "Confirm",
    "options": [
      {"label": "Yes, generate", "description": "파일 생성 진행"},
      {"label": "Edit fields", "description": "Q&A 다시 진행"},
      {"label": "Save draft only", "description": "드래프트만 저장"}
    ],
    "multiSelect": false
  }]
)
```

On "Yes, generate":
1. Write file to target path
2. Update settings.json if Hook (add to hooks array)
3. Show success message with test command

---

## Templates Reference

### Agent Template
```yaml
---
name: {name}
description: {description}
tools: {tools}
oda_context:
  role: {role}
  stage_access: {stages}
  evidence_required: {bool}
  governance_mode: {mode}
model: {model}
context: {context}
---

# {Name} Agent

## Purpose
{description}

## Behavior
{behavior_rules}
```

### Skill Template
```yaml
---
name: {name}
description: {description}
user-invocable: {bool}
disable-model-invocation: {bool}
allowed-tools: {tools}
context: {context}
agent: {agent_type}
model: {model}
version: "1.0.0"
---

# /{name} Command

## Purpose
{description}

## Execution Flow
1. {step}
```

### Hook Template (Bash)
```bash
#!/bin/bash
# {name} - {event_type}
# Trigger: {event_type} on {matcher}

set -euo pipefail
INPUT=$(cat)
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // ""')

# Logic
{logic}

echo '{"hookSpecificOutput":{"permissionDecision":"{decision}"}}'
```

### Hook Template (Python)
```python
#!/usr/bin/env python3
"""
{name} - {event_type}
Trigger: {event_type} on {matcher}
"""
import sys, json

def main():
    data = json.load(sys.stdin)
    # Logic
    {logic}
    print(json.dumps({"hookSpecificOutput": {"permissionDecision": "{decision}"}}))

if __name__ == "__main__":
    main()
```

---

## Error Handling

| Error | Action |
|-------|--------|
| Invalid name format | Re-prompt with validation hint |
| Draft not found (resume) | List available drafts |
| File already exists | Ask overwrite confirmation |
| Settings.json parse error | Manual hook registration hint |

---

## State Persistence

Draft auto-saves after each round:
- Location: `.agent/plans/create_drafts/{type}_{name}.md`
- Format: Markdown with YAML frontmatter
- Resume: `/build --resume {type}_{name}`

---

## Integration Points

| System | Integration |
|--------|-------------|
| /plan | Draft handoff for complex builds |
| settings.json | Hook auto-registration |
| ODA Registry | Agent registration (future) |
| Template System | Base templates for all types |
