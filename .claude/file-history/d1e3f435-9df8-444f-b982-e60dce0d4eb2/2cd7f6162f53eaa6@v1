---
name: synthesis
description: |
  Traceability matrix, quality validation, completion decision.
user-invocable: true
disable-model-invocation: false
context: standard
model: opus
version: "1.0.0"
argument-hint: "[--strict | --lenient]"
---

# /synthesis - Traceability & Quality Validation

> **Version:** 1.0
> **Role:** Cross-reference requirements â†” deliverables, validate quality, decide COMPLETE or ITERATE
> **Architecture:** Hybrid (Native Task System + File-Based Analysis)

---

## 1. Purpose

**Synthesis Agent** that:
1. Reads original requirements from `/clarify` logs
2. Reads collected deliverables from `/collect` report
3. Builds traceability matrix (requirements â†” deliverables)
4. Validates quality (consistency, completeness, coherence)
5. Makes COMPLETE or ITERATE decision

---

## 2. Invocation

### User Syntax

```bash
# Standard synthesis (80% threshold)
/synthesis

# Strict mode (95% threshold)
/synthesis --strict

# Lenient mode (60% threshold)
/synthesis --lenient

# Dry run (analysis only, no decision)
/synthesis --dry-run
```

### Arguments

- `$0`: Mode flag (`--strict`, `--lenient`, `--dry-run`)

---

## 3. Execution Protocol

### 3.1 Phase 1: Read Requirements

```javascript
function readRequirements() {
  // 1. Find latest clarify log
  clarifyLogs = Glob(".agent/plans/clarify_*.md")

  if (clarifyLogs.length === 0) {
    console.log("âš ï¸  No /clarify logs found")
    return { requirements: [], source: null }
  }

  // Sort by date (newest first)
  clarifyLogs.sort((a, b) => {
    let dateA = extractDateFromFilename(a)
    let dateB = extractDateFromFilename(b)
    return dateB - dateA
  })

  latestLog = clarifyLogs[0]
  console.log(`ğŸ“‹ Reading requirements from: ${latestLog}`)

  // 2. Parse requirements
  content = Read(latestLog)
  requirements = parseRequirements(content)

  /*
  Output structure:
  [
    { id: "REQ-001", description: "User authentication", priority: "P0", category: "feature" },
    { id: "REQ-002", description: "Input validation", priority: "P1", category: "security" },
    ...
  ]
  */

  return {
    requirements: requirements,
    source: latestLog,
    totalCount: requirements.length,
    p0Count: requirements.filter(r => r.priority === "P0").length,
    p1Count: requirements.filter(r => r.priority === "P1").length
  }
}
```

### 3.2 Phase 2: Read Collection Report

```javascript
function readCollectionReport() {
  reportPath = ".agent/outputs/collection_report.md"

  if (!fileExists(reportPath)) {
    console.log("âš ï¸  Collection report not found. Run /collect first.")
    return { deliverables: [], taskSummaries: [], source: null }
  }

  console.log(`ğŸ“¦ Reading collection report: ${reportPath}`)

  content = Read(reportPath)

  // 1. Parse task summaries
  taskSummaries = parseTaskSummaries(content)

  // 2. Extract all deliverables
  deliverables = []
  for (task of taskSummaries) {
    for (d of task.deliverables) {
      deliverables.push({
        item: d,
        taskId: task.taskId,
        taskSubject: task.subject,
        owner: task.owner
      })
    }
  }

  // 3. Parse completion stats
  stats = parseCompletionStats(content)

  return {
    deliverables: deliverables,
    taskSummaries: taskSummaries,
    source: reportPath,
    stats: stats
  }
}
```

### 3.3 Phase 3: Build Traceability Matrix

```javascript
function buildTraceabilityMatrix(requirements, deliverables) {
  matrix = []

  for (req of requirements) {
    // Find matching deliverables
    matches = findMatchingDeliverables(req, deliverables)

    let status = "missing"
    let coverage = 0

    if (matches.full.length > 0) {
      status = "covered"
      coverage = 100
    } else if (matches.partial.length > 0) {
      status = "partial"
      coverage = 50
    }

    matrix.push({
      requirementId: req.id,
      requirement: req.description,
      priority: req.priority,
      status: status,
      deliverables: matches.full.concat(matches.partial),
      coverage: coverage,
      notes: generateNotes(status, matches)
    })
  }

  // Calculate overall coverage
  totalCoverage = matrix.reduce((sum, m) => sum + m.coverage, 0) / matrix.length
  coveredCount = matrix.filter(m => m.status === "covered").length
  partialCount = matrix.filter(m => m.status === "partial").length
  missingCount = matrix.filter(m => m.status === "missing").length

  return {
    matrix: matrix,
    stats: {
      totalRequirements: requirements.length,
      covered: coveredCount,
      partial: partialCount,
      missing: missingCount,
      overallCoverage: totalCoverage.toFixed(1) + "%"
    }
  }
}
```

### 3.4 Phase 4: Validate Quality

```javascript
function validateQuality(matrix, deliverables) {
  checks = {
    consistency: { passed: true, issues: [] },
    completeness: { passed: true, issues: [] },
    coherence: { passed: true, issues: [] }
  }

  // === Consistency Check ===
  // Look for conflicting implementations

  // Check for duplicate deliverables (same file, different tasks)
  deliverableFiles = {}
  for (d of deliverables) {
    if (deliverableFiles[d.item]) {
      checks.consistency.issues.push({
        type: "duplicate",
        description: `File "${d.item}" modified by multiple tasks`,
        severity: "warning"
      })
    }
    deliverableFiles[d.item] = d.taskId
  }

  // Check for conflicting patterns (heuristic)
  if (checks.consistency.issues.filter(i => i.severity === "critical").length > 0) {
    checks.consistency.passed = false
  }

  // === Completeness Check ===
  // All P0 requirements should be covered

  p0Missing = matrix.matrix.filter(m =>
    m.priority === "P0" && m.status === "missing"
  )

  if (p0Missing.length > 0) {
    checks.completeness.passed = false
    for (m of p0Missing) {
      checks.completeness.issues.push({
        type: "p0_missing",
        description: `P0 requirement not addressed: ${m.requirement}`,
        requirementId: m.requirementId,
        severity: "critical"
      })
    }
  }

  // Check for missing tests (heuristic - look for test files)
  hasTests = deliverables.some(d =>
    d.item.includes("test") || d.item.includes(".spec.") || d.item.includes(".test.")
  )

  if (!hasTests) {
    checks.completeness.issues.push({
      type: "no_tests",
      description: "No test files found in deliverables",
      severity: "warning"
    })
  }

  // === Coherence Check ===
  // Components should work together

  // Check for orphan deliverables (deliverables that don't map to any requirement)
  orphans = findOrphanDeliverables(deliverables, matrix.matrix)
  if (orphans.length > 0) {
    for (o of orphans) {
      checks.coherence.issues.push({
        type: "orphan",
        description: `Deliverable "${o.item}" doesn't map to any requirement`,
        severity: "info"
      })
    }
  }

  // Calculate overall validation result
  criticalIssues = [
    ...checks.consistency.issues,
    ...checks.completeness.issues,
    ...checks.coherence.issues
  ].filter(i => i.severity === "critical")

  return {
    consistency: checks.consistency,
    completeness: checks.completeness,
    coherence: checks.coherence,
    overallPassed: criticalIssues.length === 0,
    criticalIssueCount: criticalIssues.length,
    warningCount: [
      ...checks.consistency.issues,
      ...checks.completeness.issues,
      ...checks.coherence.issues
    ].filter(i => i.severity === "warning").length
  }
}
```

### 3.5 Phase 5: Make Decision

```javascript
function makeDecision(matrixResult, validationResult, options) {
  coverage = parseFloat(matrixResult.stats.overallCoverage)

  // Determine threshold based on mode
  let threshold = 80  // default
  if (options.mode === "strict") {
    threshold = 95
  } else if (options.mode === "lenient") {
    threshold = 60
  }

  // Decision logic
  let decision, rationale, nextAction, gaps

  if (coverage >= threshold && validationResult.criticalIssueCount === 0 && validationResult.overallPassed) {
    decision = "COMPLETE"
    rationale = [
      `Coverage: ${matrixResult.stats.overallCoverage} (above ${threshold}% threshold)`,
      `Critical Issues: 0`,
      `Quality Validation: PASSED`
    ]
    nextAction = "/commit-push-pr"
    gaps = []
  }
  else if (coverage >= (threshold - 20) && validationResult.criticalIssueCount === 0) {
    decision = "COMPLETE_WITH_WARNINGS"
    rationale = [
      `Coverage: ${matrixResult.stats.overallCoverage} (slightly below ${threshold}% threshold)`,
      `Critical Issues: 0`,
      `Quality Validation: PASSED with warnings`,
      `Warnings: ${validationResult.warningCount}`
    ]
    nextAction = "/commit-push-pr --with-warnings"
    gaps = matrixResult.matrix.filter(m => m.status !== "covered")
  }
  else {
    decision = "ITERATE"

    // Gather gaps
    gaps = matrixResult.matrix.filter(m => m.status === "missing" || m.status === "partial")

    rationale = [
      `Coverage: ${matrixResult.stats.overallCoverage} (below ${threshold}% threshold)`,
      `Critical Issues: ${validationResult.criticalIssueCount}`,
      `Quality Validation: ${validationResult.overallPassed ? 'PASSED' : 'FAILED'}`,
      `Missing Requirements: ${matrixResult.stats.missing}`,
      `Partial Requirements: ${matrixResult.stats.partial}`
    ]

    // Generate clarify prompt
    gapDescriptions = gaps.map(g => g.requirement).slice(0, 3).join(", ")
    nextAction = `/clarify "Address gaps: ${gapDescriptions}"`
  }

  return {
    decision: decision,
    threshold: threshold,
    coverage: coverage,
    rationale: rationale,
    nextAction: nextAction,
    gaps: gaps
  }
}
```

### 3.6 Phase 6: Generate Synthesis Report

```javascript
function generateSynthesisReport(requirementsResult, collectionResult, matrixResult, validationResult, decisionResult, options) {
  let now = new Date().toISOString()

  let reportContent = `# Synthesis Report

> Generated: ${now}
> Mode: ${options.mode || "standard"}
> Threshold: ${decisionResult.threshold}%

---

## Summary

| Metric | Value |
|--------|-------|
| Requirements Source | ${requirementsResult.source || 'N/A'} |
| Collection Source | ${collectionResult.source || 'N/A'} |
| Total Requirements | ${requirementsResult.totalCount} |
| P0 Requirements | ${requirementsResult.p0Count} |
| P1 Requirements | ${requirementsResult.p1Count} |
| Total Deliverables | ${collectionResult.deliverables.length} |
| **Coverage** | **${matrixResult.stats.overallCoverage}** |

---

## Traceability Matrix

| Requirement | Priority | Status | Deliverable(s) | Notes |
|-------------|----------|--------|----------------|-------|
${matrixResult.matrix.map(m => {
  let statusIcon = m.status === "covered" ? "âœ…" : m.status === "partial" ? "âš ï¸" : "âŒ"
  let deliverablesList = m.deliverables.length > 0
    ? m.deliverables.map(d => d.item).join(", ")
    : "-"
  return `| ${m.requirementId}: ${m.requirement.substring(0, 40)}... | ${m.priority} | ${statusIcon} ${m.status} | ${deliverablesList} | ${m.notes || '-'} |`
}).join('\n')}

**Coverage Summary:**
- âœ… Covered: ${matrixResult.stats.covered}
- âš ï¸ Partial: ${matrixResult.stats.partial}
- âŒ Missing: ${matrixResult.stats.missing}

---

## Quality Validation

### Consistency Check ${validationResult.consistency.passed ? 'âœ…' : 'âŒ'}

${validationResult.consistency.issues.length > 0 ?
  validationResult.consistency.issues.map(i => `- [${i.severity}] ${i.description}`).join('\n')
  : '- No issues detected'}

### Completeness Check ${validationResult.completeness.passed ? 'âœ…' : 'âŒ'}

${validationResult.completeness.issues.length > 0 ?
  validationResult.completeness.issues.map(i => `- [${i.severity}] ${i.description}`).join('\n')
  : '- All requirements addressed'}

### Coherence Check ${validationResult.coherence.passed ? 'âœ…' : 'âŒ'}

${validationResult.coherence.issues.length > 0 ?
  validationResult.coherence.issues.map(i => `- [${i.severity}] ${i.description}`).join('\n')
  : '- Components integrate properly'}

**Overall Validation:** ${validationResult.overallPassed ? 'âœ… PASSED' : 'âŒ FAILED'}
- Critical Issues: ${validationResult.criticalIssueCount}
- Warnings: ${validationResult.warningCount}

---

## Decision

${getDecisionBlock(decisionResult)}

---

## Synthesis Metadata

\`\`\`yaml
synthesizedAt: "${now}"
mode: "${options.mode || 'standard'}"
threshold: ${decisionResult.threshold}
coverage: ${decisionResult.coverage}
decision: "${decisionResult.decision}"
criticalIssues: ${validationResult.criticalIssueCount}
\`\`\`
`

  // Ensure output directory exists
  outputDir = ".agent/outputs/synthesis"
  Bash(`mkdir -p ${outputDir}`)

  // Write report
  reportPath = `${outputDir}/synthesis_report.md`
  Write({
    file_path: reportPath,
    content: reportContent
  })

  console.log(`âœ… Synthesis report generated: ${reportPath}`)

  return {
    path: reportPath,
    decision: decisionResult.decision
  }
}
```

### 3.7 Helper: getDecisionBlock

```javascript
function getDecisionBlock(decisionResult) {
  if (decisionResult.decision === "COMPLETE") {
    return `**Status: COMPLETE** âœ…

**Rationale:**
${decisionResult.rationale.map(r => `- ${r}`).join('\n')}

**Next Action:**
\`\`\`bash
${decisionResult.nextAction}
\`\`\``
  }

  if (decisionResult.decision === "COMPLETE_WITH_WARNINGS") {
    return `**Status: COMPLETE WITH WARNINGS** âš ï¸

**Rationale:**
${decisionResult.rationale.map(r => `- ${r}`).join('\n')}

**Gaps (non-critical):**
${decisionResult.gaps.map(g => `- ${g.requirementId}: ${g.requirement}`).join('\n')}

**Next Action:**
\`\`\`bash
${decisionResult.nextAction}
\`\`\`

Consider addressing warnings in a follow-up iteration.`
  }

  // ITERATE
  return `**Status: ITERATE** ğŸ”„

**Rationale:**
${decisionResult.rationale.map(r => `- ${r}`).join('\n')}

**Gaps to Address:**
${decisionResult.gaps.map((g, i) => `${i + 1}. ${g.requirementId}: ${g.requirement}`).join('\n')}

**Next Action:**
\`\`\`bash
${decisionResult.nextAction}
\`\`\`

Return to /clarify to refine requirements and address gaps.`
}
```

### 3.8 Helper Functions

```javascript
function parseRequirements(content) {
  requirements = []
  lines = content.split('\n')

  let reqId = 1
  for (line of lines) {
    // Look for requirement patterns
    // Pattern 1: "- REQ-001: Description"
    // Pattern 2: "- [P0] Description"
    // Pattern 3: "## Requirement: Description"

    if (line.match(/^\s*[-*]\s*(REQ-\d+|R\d+):/i)) {
      match = line.match(/^\s*[-*]\s*(REQ-\d+|R\d+):\s*(.+)/i)
      if (match) {
        requirements.push({
          id: match[1].toUpperCase(),
          description: match[2].trim(),
          priority: extractPriority(line) || "P1",
          category: extractCategory(match[2])
        })
      }
    }
    else if (line.match(/^\s*[-*]\s*\[(P\d)\]/i)) {
      match = line.match(/^\s*[-*]\s*\[(P\d)\]\s*(.+)/i)
      if (match) {
        requirements.push({
          id: `REQ-${String(reqId++).padStart(3, '0')}`,
          description: match[2].trim(),
          priority: match[1].toUpperCase(),
          category: extractCategory(match[2])
        })
      }
    }
    else if (line.match(/^##\s*(Requirement|ìš”êµ¬ì‚¬í•­):\s*/i)) {
      match = line.match(/^##\s*(Requirement|ìš”êµ¬ì‚¬í•­):\s*(.+)/i)
      if (match) {
        requirements.push({
          id: `REQ-${String(reqId++).padStart(3, '0')}`,
          description: match[2].trim(),
          priority: "P1",
          category: extractCategory(match[2])
        })
      }
    }
  }

  return requirements
}

function findMatchingDeliverables(requirement, deliverables) {
  full = []
  partial = []

  // Keyword matching (simple heuristic)
  keywords = requirement.description.toLowerCase().split(/\s+/).filter(w => w.length > 3)

  for (d of deliverables) {
    matchScore = 0
    itemLower = d.item.toLowerCase()
    taskLower = (d.taskSubject || "").toLowerCase()

    for (kw of keywords) {
      if (itemLower.includes(kw) || taskLower.includes(kw)) {
        matchScore++
      }
    }

    // Threshold for matching
    matchPercentage = (matchScore / keywords.length) * 100

    if (matchPercentage >= 50) {
      full.push(d)
    } else if (matchPercentage >= 25) {
      partial.push(d)
    }
  }

  return { full, partial }
}

function findOrphanDeliverables(deliverables, matrix) {
  orphans = []

  for (d of deliverables) {
    isOrphan = true

    for (m of matrix) {
      if (m.deliverables.some(md => md.item === d.item)) {
        isOrphan = false
        break
      }
    }

    if (isOrphan) {
      orphans.push(d)
    }
  }

  return orphans
}

function extractPriority(text) {
  match = text.match(/\b(P0|P1|P2|P3)\b/i)
  return match ? match[1].toUpperCase() : null
}

function extractCategory(text) {
  categories = ["feature", "security", "performance", "ux", "infrastructure", "testing"]
  textLower = text.toLowerCase()

  for (cat of categories) {
    if (textLower.includes(cat)) return cat
  }
  return "feature"
}
```

---

## 4. Main Execution Flow

```javascript
async function synthesis(args) {
  console.log("ğŸ” Starting synthesis...")

  // 1. Parse arguments
  let options = parseArgs(args)
  // options: { mode: "standard" | "strict" | "lenient", dryRun: false }

  console.log(`Mode: ${options.mode || 'standard'} | Dry Run: ${options.dryRun}`)

  // 2. Read requirements from /clarify log
  console.log("\nğŸ“‹ Reading requirements...")
  requirementsResult = readRequirements()

  if (requirementsResult.requirements.length === 0) {
    console.log("âŒ No requirements found. Run /clarify first.")
    return { status: "error", reason: "No requirements" }
  }

  console.log(`  Found ${requirementsResult.totalCount} requirements (P0: ${requirementsResult.p0Count}, P1: ${requirementsResult.p1Count})`)

  // 3. Read collection report
  console.log("\nğŸ“¦ Reading collection report...")
  collectionResult = readCollectionReport()

  if (!collectionResult.source) {
    console.log("âŒ Collection report not found. Run /collect first.")
    return { status: "error", reason: "No collection report" }
  }

  console.log(`  Found ${collectionResult.deliverables.length} deliverables`)

  // 4. Build traceability matrix
  console.log("\nğŸ“Š Building traceability matrix...")
  matrixResult = buildTraceabilityMatrix(
    requirementsResult.requirements,
    collectionResult.deliverables
  )

  console.log(`
Matrix Summary:
  âœ… Covered: ${matrixResult.stats.covered}
  âš ï¸  Partial: ${matrixResult.stats.partial}
  âŒ Missing: ${matrixResult.stats.missing}
  ğŸ“ˆ Coverage: ${matrixResult.stats.overallCoverage}
`)

  // 5. Validate quality
  console.log("ğŸ”¬ Validating quality...")
  validationResult = validateQuality(matrixResult, collectionResult.deliverables)

  console.log(`
Quality Check:
  Consistency: ${validationResult.consistency.passed ? 'âœ…' : 'âŒ'}
  Completeness: ${validationResult.completeness.passed ? 'âœ…' : 'âŒ'}
  Coherence: ${validationResult.coherence.passed ? 'âœ…' : 'âŒ'}
  Critical Issues: ${validationResult.criticalIssueCount}
`)

  // 6. Make decision
  console.log("âš–ï¸  Making decision...")
  decisionResult = makeDecision(matrixResult, validationResult, options)

  // 7. Generate report (unless dry run)
  if (!options.dryRun) {
    console.log("\nğŸ“ Generating synthesis report...")
    report = generateSynthesisReport(
      requirementsResult,
      collectionResult,
      matrixResult,
      validationResult,
      decisionResult,
      options
    )
  }

  // 8. Final output
  let decisionIcon = decisionResult.decision === "COMPLETE" ? "âœ…" :
                     decisionResult.decision === "COMPLETE_WITH_WARNINGS" ? "âš ï¸" : "ğŸ”„"

  console.log(`
=== Synthesis Complete ===

Decision: ${decisionIcon} ${decisionResult.decision}
Coverage: ${matrixResult.stats.overallCoverage}
Threshold: ${decisionResult.threshold}%

${decisionResult.rationale.map(r => `  - ${r}`).join('\n')}

Next Action:
  ${decisionResult.nextAction}

${!options.dryRun ? `Report: ${report.path}` : '(Dry run - no report generated)'}
`)

  return {
    status: "success",
    decision: decisionResult.decision,
    coverage: matrixResult.stats.overallCoverage,
    nextAction: decisionResult.nextAction,
    reportPath: options.dryRun ? null : report.path
  }
}
```

---

## 5. Error Handling

| Error | Detection | Recovery |
|-------|-----------|----------|
| **No clarify logs** | Glob returns empty | Prompt user to run /clarify first |
| **No collection report** | File not found | Prompt user to run /collect first |
| **Empty requirements** | Parse returns 0 | Show "No parseable requirements" |
| **Parse error** | Malformed content | Skip problematic sections, warn user |
| **Report write failure** | Permission error | Output to stdout instead |

---

## 6. Example Usage

### Example 1: Complete Success

```bash
/synthesis
```

**Output:**
```
ğŸ” Starting synthesis...
Mode: standard | Dry Run: false

ğŸ“‹ Reading requirements...
  Found 5 requirements (P0: 2, P1: 3)

ğŸ“¦ Reading collection report...
  Found 8 deliverables

ğŸ“Š Building traceability matrix...

Matrix Summary:
  âœ… Covered: 4
  âš ï¸  Partial: 1
  âŒ Missing: 0
  ğŸ“ˆ Coverage: 90.0%

ğŸ”¬ Validating quality...

Quality Check:
  Consistency: âœ…
  Completeness: âœ…
  Coherence: âœ…
  Critical Issues: 0

âš–ï¸  Making decision...

ğŸ“ Generating synthesis report...
âœ… Synthesis report generated: .agent/outputs/synthesis/synthesis_report.md

=== Synthesis Complete ===

Decision: âœ… COMPLETE
Coverage: 90.0%
Threshold: 80%

  - Coverage: 90.0% (above 80% threshold)
  - Critical Issues: 0
  - Quality Validation: PASSED

Next Action:
  /commit-push-pr

Report: .agent/outputs/synthesis/synthesis_report.md
```

### Example 2: Iterate Required

```bash
/synthesis
```

**Output:**
```
ğŸ” Starting synthesis...
Mode: standard | Dry Run: false

ğŸ“‹ Reading requirements...
  Found 5 requirements (P0: 2, P1: 3)

ğŸ“¦ Reading collection report...
  Found 3 deliverables

ğŸ“Š Building traceability matrix...

Matrix Summary:
  âœ… Covered: 2
  âš ï¸  Partial: 1
  âŒ Missing: 2
  ğŸ“ˆ Coverage: 50.0%

ğŸ”¬ Validating quality...

Quality Check:
  Consistency: âœ…
  Completeness: âŒ
  Coherence: âœ…
  Critical Issues: 1

âš–ï¸  Making decision...

ğŸ“ Generating synthesis report...
âœ… Synthesis report generated: .agent/outputs/synthesis/synthesis_report.md

=== Synthesis Complete ===

Decision: ğŸ”„ ITERATE
Coverage: 50.0%
Threshold: 80%

  - Coverage: 50.0% (below 80% threshold)
  - Critical Issues: 1
  - Quality Validation: FAILED
  - Missing Requirements: 2
  - Partial Requirements: 1

Next Action:
  /clarify "Address gaps: Error handling, Input validation"

Report: .agent/outputs/synthesis/synthesis_report.md
```

### Example 3: Strict Mode

```bash
/synthesis --strict
```

**Output:**
```
ğŸ” Starting synthesis...
Mode: strict | Dry Run: false

...

=== Synthesis Complete ===

Decision: ğŸ”„ ITERATE
Coverage: 90.0%
Threshold: 95%  # Strict mode requires 95%

  - Coverage: 90.0% (below 95% threshold)
  ...
```

---

## 7. Integration Points

### 7.1 Pipeline Position

```
/clarify â†’ /orchestrate â†’ /assign â†’ Workers â†’ /collect â†’ /synthesis â†’ /commit-push-pr
                                                            â†‘
                                                      [THIS SKILL]
                                                            â”‚
                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                        â”‚                                       â”‚
                                    COMPLETE                                ITERATE
                                        â”‚                                       â”‚
                                        â–¼                                       â–¼
                              /commit-push-pr                              /clarify
```

### 7.2 Input Dependencies

| Source | File | Purpose |
|--------|------|---------|
| /clarify | `.agent/plans/clarify_*.md` | Original requirements |
| /collect | `.agent/outputs/collection_report.md` | Aggregated deliverables |

### 7.3 Output

| Destination | File | Purpose |
|-------------|------|---------|
| /commit-push-pr | `.agent/outputs/synthesis/synthesis_report.md` | Completion evidence |
| /clarify | Gaps list | Iteration guidance |

---

## 8. Testing Checklist

- [ ] No clarify logs found scenario
- [ ] No collection report scenario
- [ ] All requirements covered (COMPLETE)
- [ ] Partial coverage (COMPLETE_WITH_WARNINGS)
- [ ] Low coverage (ITERATE)
- [ ] Critical issues detected
- [ ] --strict mode threshold
- [ ] --lenient mode threshold
- [ ] --dry-run mode
- [ ] Traceability matrix accuracy
- [ ] Quality validation (consistency)
- [ ] Quality validation (completeness)
- [ ] Quality validation (coherence)
- [ ] Report generation
- [ ] Decision rationale clarity

---

## 9. Performance Targets

| Operation | Target | Actual |
|-----------|--------|--------|
| Read requirements | <500ms | TBD |
| Read collection | <500ms | TBD |
| Build matrix | <1s | TBD |
| Quality validation | <2s | TBD |
| Report generation | <500ms | TBD |
| Total /synthesis | <5s | TBD |

---

## 10. Future Enhancements

1. **AI-powered matching:** Use embeddings for requirement-deliverable matching
2. **Diff analysis:** Compare current vs previous synthesis runs
3. **Auto-fix suggestions:** Generate specific code fixes for gaps
4. **Confidence scores:** Add confidence percentage to each matrix entry
5. **Historical tracking:** Track coverage trend over iterations

---

**End of Skill Documentation**
