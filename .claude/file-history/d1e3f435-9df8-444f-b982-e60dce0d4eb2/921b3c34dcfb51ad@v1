---
name: collect
description: |
  Aggregate worker results, verify completion, detect blockers.
user-invocable: true
disable-model-invocation: false
context: standard
model: sonnet
version: "1.0.0"
argument-hint: "[--all | --phase <phase-id>]"
---

# /collect - Result Aggregation & Completion Verification

> **Version:** 1.0
> **Role:** Aggregate worker results, verify completion, detect blockers
> **Architecture:** Hybrid (Native Task System + File-Based Reports)

---

## 1. Purpose

**Collection Agent** that:
1. Verifies all assigned tasks are completed via `TaskList`
2. Aggregates worker outputs from `.agent/outputs/Worker/`
3. Detects blockers and pending tasks
4. Generates a collection report for `/synthesis`

---

## 2. Invocation

### User Syntax

```bash
# Collect all tasks
/collect
/collect --all

# Collect specific phase
/collect --phase p1

# Force collection even with pending tasks
/collect --force
```

### Arguments

- `$0`: Mode flag (`--all`, `--phase`, `--force`)
- `$1`: Phase ID (when using `--phase`)

---

## 3. Execution Protocol

### 3.1 Phase 1: Verify All Complete

```javascript
function verifyAllComplete() {
  // 1. Get all tasks from Native Task System
  allTasks = TaskList()

  // 2. Categorize by status
  completed = allTasks.filter(t => t.status === "completed")
  inProgress = allTasks.filter(t => t.status === "in_progress")
  pending = allTasks.filter(t => t.status === "pending")

  // 3. Calculate completion percentage
  totalTasks = allTasks.length
  completionRate = (completed.length / totalTasks) * 100

  // 4. Return summary
  return {
    complete: pending.length === 0 && inProgress.length === 0,
    stats: {
      total: totalTasks,
      completed: completed.length,
      inProgress: inProgress.length,
      pending: pending.length,
      completionRate: completionRate.toFixed(1) + "%"
    },
    tasks: {
      completed: completed,
      inProgress: inProgress,
      pending: pending
    }
  }
}
```

### 3.2 Phase 2: Aggregate Outputs

```javascript
function aggregateOutputs() {
  // 1. Find all worker output files
  outputFiles = Glob(".agent/outputs/Worker/*.md")

  if (outputFiles.length === 0) {
    console.log("âš ï¸  No worker outputs found")
    return { outputs: [], warnings: ["No worker outputs in .agent/outputs/Worker/"] }
  }

  // 2. Parse each output file
  aggregated = []

  for (file of outputFiles) {
    content = Read(file)

    // Extract L1 summary (first section)
    l1Summary = extractL1Summary(content)

    // Extract metadata
    metadata = extractMetadata(content)

    aggregated.push({
      file: file,
      phaseId: metadata.phaseId || extractPhaseFromFilename(file),
      taskId: metadata.taskId || null,
      owner: metadata.owner || null,
      summary: l1Summary,
      completedAt: metadata.completedAt || null,
      deliverables: extractDeliverables(content)
    })
  }

  // 3. Sort by phase order
  aggregated.sort((a, b) => {
    let phaseA = parseInt(a.phaseId.replace(/\D/g, '')) || 0
    let phaseB = parseInt(b.phaseId.replace(/\D/g, '')) || 0
    return phaseA - phaseB
  })

  return {
    outputs: aggregated,
    warnings: []
  }
}
```

### 3.3 Phase 3: Detect Blockers

```javascript
function detectBlockers(verificationResult) {
  blockers = []

  // 1. Check for in-progress tasks that might be stuck
  for (task of verificationResult.tasks.inProgress) {
    taskDetail = TaskGet({taskId: task.id})

    // Check if task has been in_progress for too long (heuristic)
    blockers.push({
      type: "in_progress",
      taskId: task.id,
      subject: task.subject,
      owner: task.owner,
      recommendation: "Check worker status or reassign"
    })
  }

  // 2. Check for pending tasks that are unblocked but not started
  for (task of verificationResult.tasks.pending) {
    taskDetail = TaskGet({taskId: task.id})

    // If no blockers, this task should have been started
    if (!taskDetail.blockedBy || taskDetail.blockedBy.length === 0) {
      blockers.push({
        type: "unstarted",
        taskId: task.id,
        subject: task.subject,
        owner: task.owner || "unassigned",
        recommendation: task.owner ? "Notify worker to start" : "Assign to a worker"
      })
    } else {
      // Check if blockers are completed
      allBlockersComplete = true
      for (blockerId of taskDetail.blockedBy) {
        blocker = TaskGet({taskId: blockerId})
        if (blocker.status !== "completed") {
          allBlockersComplete = false
        }
      }

      if (allBlockersComplete) {
        blockers.push({
          type: "ready_but_pending",
          taskId: task.id,
          subject: task.subject,
          owner: task.owner || "unassigned",
          recommendation: "All blockers complete - ready to start"
        })
      }
    }
  }

  // 3. Check for circular dependencies (if implemented in Native Task)
  // This is typically caught during orchestration, but double-check

  return {
    hasBlockers: blockers.length > 0,
    blockers: blockers,
    criticalCount: blockers.filter(b => b.type === "in_progress").length
  }
}
```

### 3.4 Phase 4: Generate Report

```javascript
function generateReport(verification, aggregation, blockerDetection, options) {
  let now = new Date().toISOString()

  let reportContent = `# Collection Report

> Generated: ${now}
> Mode: ${options.mode || "all"}

---

## Summary

| Metric | Count |
|--------|-------|
| Total Tasks | ${verification.stats.total} |
| Completed | ${verification.stats.completed} |
| In Progress | ${verification.stats.inProgress} |
| Pending | ${verification.stats.pending} |
| **Completion Rate** | **${verification.stats.completionRate}** |

---

## Task Status

| Task ID | Subject | Status | Owner |
|---------|---------|--------|-------|
${verification.tasks.completed.map(t => `| #${t.id} | ${t.subject} | âœ… completed | ${t.owner || '-'} |`).join('\n')}
${verification.tasks.inProgress.map(t => `| #${t.id} | ${t.subject} | ðŸ”„ in_progress | ${t.owner || '-'} |`).join('\n')}
${verification.tasks.pending.map(t => `| #${t.id} | ${t.subject} | â¸ï¸ pending | ${t.owner || '-'} |`).join('\n')}

---

## Aggregated Outputs

${aggregation.outputs.length > 0 ? aggregation.outputs.map(out => `
### ${out.phaseId}: ${out.summary.title || 'Untitled'}

**File:** \`${out.file}\`
**Owner:** ${out.owner || 'Unknown'}
**Completed:** ${out.completedAt || 'N/A'}

${out.summary.content || '(No L1 summary available)'}

**Deliverables:**
${out.deliverables.length > 0 ? out.deliverables.map(d => `- ${d}`).join('\n') : '- (None specified)'}
`).join('\n---\n') : `
*No worker outputs found in .agent/outputs/Worker/*
`}

---

## Blockers

${blockerDetection.hasBlockers ? `
âš ï¸ **${blockerDetection.blockers.length} blocker(s) detected**

| Type | Task ID | Subject | Recommendation |
|------|---------|---------|----------------|
${blockerDetection.blockers.map(b => `| ${b.type} | #${b.taskId} | ${b.subject} | ${b.recommendation} |`).join('\n')}
` : `
âœ… No blockers detected
`}

---

## Recommended Next Action

${getRecommendation(verification, blockerDetection)}

---

## Collection Metadata

\`\`\`yaml
collectedAt: "${now}"
mode: "${options.mode || 'all'}"
taskListId: "${process.env.CLAUDE_CODE_TASK_LIST_ID || 'default'}"
outputsProcessed: ${aggregation.outputs.length}
\`\`\`
`

  // Write report
  reportPath = ".agent/outputs/collection_report.md"
  Write({
    file_path: reportPath,
    content: reportContent
  })

  console.log(`âœ… Collection report generated: ${reportPath}`)

  return {
    path: reportPath,
    allComplete: verification.complete,
    recommendation: getRecommendation(verification, blockerDetection)
  }
}
```

### 3.5 Helper: getRecommendation

```javascript
function getRecommendation(verification, blockerDetection) {
  // Priority 1: All complete â†’ Synthesis
  if (verification.complete) {
    return `- [x] \`/synthesis\` - All tasks complete, proceed to validation`
  }

  // Priority 2: Critical blockers â†’ Address them
  if (blockerDetection.criticalCount > 0) {
    return `- [ ] **Address Blockers** - ${blockerDetection.criticalCount} task(s) stuck in progress
- [ ] Check worker status for in-progress tasks
- [ ] Consider reassignment if worker is unresponsive`
  }

  // Priority 3: Has pending tasks â†’ Wait
  if (verification.stats.pending > 0) {
    return `- [ ] **Wait** - ${verification.stats.pending} task(s) still pending
- [ ] Check \`/workers\` for status
- [ ] Run \`/collect\` again when more tasks complete`
  }

  // Priority 4: In progress only â†’ Monitor
  if (verification.stats.inProgress > 0) {
    return `- [ ] **Monitor** - ${verification.stats.inProgress} task(s) in progress
- [ ] Workers are actively working
- [ ] Run \`/collect\` again when tasks complete`
  }

  return `- [ ] Unknown state - check TaskList manually`
}
```

### 3.6 Helper: extractL1Summary

```javascript
function extractL1Summary(content) {
  // Extract first heading and paragraph as L1 summary
  lines = content.split('\n')

  let title = null
  let summaryLines = []
  let inSummary = false

  for (line of lines) {
    // Find first heading
    if (!title && line.startsWith('# ')) {
      title = line.replace('# ', '').trim()
      inSummary = true
      continue
    }

    // Collect summary until next heading or separator
    if (inSummary) {
      if (line.startsWith('#') || line.startsWith('---')) {
        break
      }
      if (line.trim()) {
        summaryLines.push(line.trim())
      }
    }
  }

  return {
    title: title,
    content: summaryLines.join(' ').substring(0, 500) // Limit to 500 chars
  }
}
```

### 3.7 Helper: extractDeliverables

```javascript
function extractDeliverables(content) {
  deliverables = []

  // Look for "Deliverables" or "Output" section
  lines = content.split('\n')
  inDeliverables = false

  for (line of lines) {
    if (line.toLowerCase().includes('deliverable') ||
        line.toLowerCase().includes('output:') ||
        line.toLowerCase().includes('created:')) {
      inDeliverables = true
      continue
    }

    if (inDeliverables) {
      if (line.startsWith('#') || line.startsWith('---')) {
        break
      }
      if (line.trim().startsWith('- ') || line.trim().startsWith('* ')) {
        deliverables.push(line.trim().replace(/^[-*]\s*/, ''))
      }
    }
  }

  return deliverables
}
```

---

## 4. Main Execution Flow

```javascript
async function collect(args) {
  console.log("ðŸ”„ Starting collection...")

  // 1. Parse arguments
  let options = parseArgs(args)
  // options: { mode: "all" | "phase", phaseId: null | "p1", force: false }

  // 2. Verify completion
  console.log("ðŸ“Š Checking task status...")
  verification = verifyAllComplete()

  console.log(`
Task Status:
  âœ… Completed: ${verification.stats.completed}
  ðŸ”„ In Progress: ${verification.stats.inProgress}
  â¸ï¸  Pending: ${verification.stats.pending}
  ðŸ“ˆ Completion: ${verification.stats.completionRate}
`)

  // 3. Check if we should proceed
  if (!verification.complete && !options.force) {
    console.log("âš ï¸  Not all tasks complete. Use --force to collect anyway.")

    // Still detect blockers to help user
    blockerDetection = detectBlockers(verification)
    if (blockerDetection.hasBlockers) {
      console.log("\nBlockers detected:")
      for (b of blockerDetection.blockers) {
        console.log(`  - Task #${b.taskId}: ${b.recommendation}`)
      }
    }

    // Ask user if they want to continue
    if (!options.force) {
      proceed = askUser("Generate partial collection report? (y/n)")
      if (!proceed) {
        return { status: "aborted", reason: "Tasks incomplete" }
      }
    }
  }

  // 4. Aggregate outputs
  console.log("\nðŸ“¦ Aggregating worker outputs...")
  aggregation = aggregateOutputs()
  console.log(`  Found ${aggregation.outputs.length} output file(s)`)

  // 5. Detect blockers
  console.log("\nðŸ” Detecting blockers...")
  blockerDetection = detectBlockers(verification)
  if (blockerDetection.hasBlockers) {
    console.log(`  âš ï¸  ${blockerDetection.blockers.length} blocker(s) found`)
  } else {
    console.log(`  âœ… No blockers`)
  }

  // 6. Generate report
  console.log("\nðŸ“ Generating collection report...")
  report = generateReport(verification, aggregation, blockerDetection, options)

  // 7. Final output
  console.log(`
=== Collection Complete ===

Report: ${report.path}
Status: ${report.allComplete ? 'âœ… All tasks complete' : 'â³ Partial collection'}

${report.recommendation}

Next: ${report.allComplete ? '/synthesis' : 'Wait for pending tasks or /collect --force'}
`)

  return {
    status: "success",
    reportPath: report.path,
    allComplete: report.allComplete,
    stats: verification.stats
  }
}
```

---

## 5. Error Handling

| Error | Detection | Recovery |
|-------|-----------|----------|
| **No tasks found** | TaskList returns empty | Show "No tasks to collect" message |
| **Worker output missing** | File not in expected location | Warn, include in blockers list |
| **Parse error** | Malformed output file | Skip file, add to warnings |
| **Report write failure** | Permission/path issue | Fall back to stdout |
| **Interrupted collection** | Network/timeout | Allow --resume flag |

---

## 6. Example Usage

### Example 1: All Tasks Complete

```bash
/collect
```

**Output:**
```
ðŸ”„ Starting collection...

ðŸ“Š Checking task status...

Task Status:
  âœ… Completed: 3
  ðŸ”„ In Progress: 0
  â¸ï¸  Pending: 0
  ðŸ“ˆ Completion: 100.0%

ðŸ“¦ Aggregating worker outputs...
  Found 3 output file(s)

ðŸ” Detecting blockers...
  âœ… No blockers

ðŸ“ Generating collection report...
âœ… Collection report generated: .agent/outputs/collection_report.md

=== Collection Complete ===

Report: .agent/outputs/collection_report.md
Status: âœ… All tasks complete

- [x] `/synthesis` - All tasks complete, proceed to validation

Next: /synthesis
```

### Example 2: Partial Completion

```bash
/collect
```

**Output:**
```
ðŸ”„ Starting collection...

ðŸ“Š Checking task status...

Task Status:
  âœ… Completed: 1
  ðŸ”„ In Progress: 1
  â¸ï¸  Pending: 1
  ðŸ“ˆ Completion: 33.3%

âš ï¸  Not all tasks complete. Use --force to collect anyway.

Blockers detected:
  - Task #2: Check worker status or reassign
  - Task #3: Waiting for Task #2

Generate partial collection report? (y/n): n
```

### Example 3: Force Collection

```bash
/collect --force
```

**Output:**
```
ðŸ”„ Starting collection...

ðŸ“Š Checking task status...
...

ðŸ“¦ Aggregating worker outputs...
  Found 1 output file(s)
  âš ï¸  Missing outputs for: Task #2, Task #3

ðŸ“ Generating collection report...
âœ… Collection report generated: .agent/outputs/collection_report.md

=== Collection Complete ===

Report: .agent/outputs/collection_report.md
Status: â³ Partial collection

- [ ] **Wait** - 2 task(s) still pending
- [ ] Check `/workers` for status

Next: Wait for pending tasks or /collect --force
```

---

## 7. Generated Report Example

The collection report at `.agent/outputs/collection_report.md`:

```markdown
# Collection Report

> Generated: 2026-01-24T18:30:00Z
> Mode: all

---

## Summary

| Metric | Count |
|--------|-------|
| Total Tasks | 3 |
| Completed | 3 |
| In Progress | 0 |
| Pending | 0 |
| **Completion Rate** | **100.0%** |

---

## Task Status

| Task ID | Subject | Status | Owner |
|---------|---------|--------|-------|
| #1 | Setup session registry | âœ… completed | terminal-b |
| #2 | Implement prompt generation | âœ… completed | terminal-c |
| #3 | Add lifecycle management | âœ… completed | terminal-d |

---

## Aggregated Outputs

### phase1: Session Registry Implementation

**File:** `.agent/outputs/Worker/phase1-session-registry.md`
**Owner:** terminal-b
**Completed:** 2026-01-24T17:45:00Z

Implemented session registry with in-memory storage and file persistence.

**Deliverables:**
- .claude/session/registry.ts
- .claude/session/types.ts

---

### phase2: Prompt Generation System

**File:** `.agent/outputs/Worker/phase2-prompt-generation.md`
**Owner:** terminal-c
**Completed:** 2026-01-24T18:00:00Z

Created prompt file generator with YAML template support.

**Deliverables:**
- .agent/prompts/generator.ts
- .agent/prompts/templates/

---

## Blockers

âœ… No blockers detected

---

## Recommended Next Action

- [x] `/synthesis` - All tasks complete, proceed to validation
```

---

## 8. Integration Points

### 8.1 With /assign

```bash
# After assigning tasks
/assign auto
# Workers complete their tasks...
/collect
```

### 8.2 With /synthesis

```bash
/collect
# â†’ Generates collection_report.md

/synthesis
# â†’ Reads collection_report.md
# â†’ Cross-references with original requirements
```

### 8.3 With /workers

```bash
/workers          # Check worker status
/collect          # Collect results
```

---

## 9. Testing Checklist

- [ ] All tasks completed scenario
- [ ] Partial completion (some pending)
- [ ] Some tasks in_progress
- [ ] No worker outputs found
- [ ] Malformed worker output file
- [ ] --force flag behavior
- [ ] --phase flag (single phase collection)
- [ ] Report generation success
- [ ] Blocker detection accuracy
- [ ] Recommendation logic correctness

---

## 10. Performance Targets

| Operation | Target | Actual |
|-----------|--------|--------|
| TaskList call | <500ms | TBD |
| Output aggregation | <1s | TBD |
| Report generation | <500ms | TBD |
| Total /collect | <3s | TBD |

---

**End of Skill Documentation**
