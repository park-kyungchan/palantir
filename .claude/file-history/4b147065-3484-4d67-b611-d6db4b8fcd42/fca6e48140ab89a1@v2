"""
Orion ODA v3.0 - Context Budget Manager
=======================================

V2.1.7 Enhancement: Effective Context Window Management

This module manages context window budget for Main Agent delegations,
implementing the V2.1.7 fix for effective context window calculation
(reserving space for max output tokens).

Key Features:
- Effective Context Window: Full window - Max Output Tokens
- ULTRATHINK MODE: Maximized output budgets for deep analysis
- Dynamic Budget Adjustment: Based on current context usage
- Agent ID Registry: Resume support for Auto-Compact recovery
- Pre-Delegation Checks: Prevent context overflow

Usage:
    manager = ContextBudgetManager(mode=ThinkingMode.ULTRATHINK)

    decision = manager.check_before_delegation(estimated_output=10000)
    if decision == DelegationDecision.PROCEED:
        result = Task(subagent_type="Explore", prompt="...")
        manager.register_agent(result.agent_id, "Explore", "Task description")
"""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


class ThinkingMode(str, Enum):
    """Claude thinking modes with different output configurations."""
    STANDARD = "standard"          # Default mode
    EXTENDED = "extended"          # Extended thinking
    ULTRATHINK = "ultrathink"      # Maximum output, deep analysis


class DelegationDecision(str, Enum):
    """Decision for whether to proceed with task delegation."""
    PROCEED = "proceed"            # Safe to delegate
    REDUCE_SCOPE = "reduce_scope"  # Delegate with reduced budget
    DEFER = "defer"                # Wait for context recovery
    ABORT = "abort"                # Do not delegate, context critical


@dataclass
class ContextWindow:
    """
    Context window configuration.

    V2.1.7 Fix: Uses effective context window (full - max_output)
    instead of full context window for budget calculations.
    """
    # Claude model context windows (as of 2026, Opus 4.5)
    full_window: int = 200_000      # Total context window tokens
    max_output_tokens: int = 64_000  # Maximum output (Opus 4.5 limit)

    # Mode-specific output reservations (V2.1.7 aligned with Opus 4.5 limits)
    standard_output: int = 8_000     # Standard mode output
    extended_output: int = 16_000    # Extended thinking output
    ultrathink_output: int = 64_000  # ULTRATHINK mode output (Opus 4.5 max)

    @property
    def effective_window(self) -> int:
        """
        Calculate effective context window.

        V2.1.7 Fix: Reserves space for max output tokens.
        """
        return self.full_window - self.max_output_tokens

    def get_effective_for_mode(self, mode: ThinkingMode) -> int:
        """Get effective context window for specific thinking mode."""
        output_reservation = {
            ThinkingMode.STANDARD: self.standard_output,
            ThinkingMode.EXTENDED: self.extended_output,
            ThinkingMode.ULTRATHINK: self.ultrathink_output,
        }
        return self.full_window - output_reservation.get(mode, self.standard_output)


@dataclass
class SubagentBudget:
    """
    Subagent output budgets per thinking mode.

    ULTRATHINK MODE: Maximized budgets for comprehensive analysis.
    """
    # Standard mode budgets (conservative)
    standard_explore: int = 5_000
    standard_plan: int = 10_000
    standard_general: int = 15_000

    # Extended mode budgets (balanced)
    extended_explore: int = 8_000
    extended_plan: int = 16_000
    extended_general: int = 24_000

    # ULTRATHINK mode budgets (maximized)
    ultrathink_explore: int = 15_000
    ultrathink_plan: int = 25_000
    ultrathink_general: int = 32_000  # Maximum allowed

    def get_budget(
        self,
        subagent_type: str,
        mode: ThinkingMode = ThinkingMode.STANDARD
    ) -> int:
        """Get budget for subagent type and thinking mode."""
        budgets = {
            ThinkingMode.STANDARD: {
                "Explore": self.standard_explore,
                "Plan": self.standard_plan,
                "general-purpose": self.standard_general,
            },
            ThinkingMode.EXTENDED: {
                "Explore": self.extended_explore,
                "Plan": self.extended_plan,
                "general-purpose": self.extended_general,
            },
            ThinkingMode.ULTRATHINK: {
                "Explore": self.ultrathink_explore,
                "Plan": self.ultrathink_plan,
                "general-purpose": self.ultrathink_general,
            },
        }

        mode_budgets = budgets.get(mode, budgets[ThinkingMode.STANDARD])
        return mode_budgets.get(subagent_type, mode_budgets["general-purpose"])


@dataclass
class AgentRecord:
    """Record of a delegated agent for resume support."""
    agent_id: str
    subagent_type: str
    description: str
    created_at: str
    status: str = "running"  # running, completed, failed, resumable
    output_tokens_used: int = 0
    resumable: bool = True

    def to_dict(self) -> Dict[str, Any]:
        return {
            "agent_id": self.agent_id,
            "subagent_type": self.subagent_type,
            "description": self.description,
            "created_at": self.created_at,
            "status": self.status,
            "output_tokens_used": self.output_tokens_used,
            "resumable": self.resumable,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AgentRecord":
        return cls(**data)


@dataclass
class BudgetReport:
    """Report of current context budget status."""
    thinking_mode: ThinkingMode
    full_window: int
    effective_window: int
    estimated_usage: float  # 0-1 scale
    remaining_tokens: int
    recommended_budget: int
    decision: DelegationDecision
    warnings: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "thinking_mode": self.thinking_mode.value,
            "full_window": self.full_window,
            "effective_window": self.effective_window,
            "estimated_usage": round(self.estimated_usage, 3),
            "remaining_tokens": self.remaining_tokens,
            "recommended_budget": self.recommended_budget,
            "decision": self.decision.value,
            "warnings": self.warnings,
        }


class ContextBudgetManager:
    """
    Main Agent Context Budget Manager.

    Manages context window budget for subagent delegations,
    implements V2.1.7 effective context window calculation,
    and supports ULTRATHINK MODE for maximized token usage.

    Key Responsibilities:
    1. Pre-delegation context checks
    2. Dynamic budget adjustment based on usage
    3. Agent ID registry for resume support
    4. Effective context window calculation (V2.1.7 fix)

    Usage:
        manager = ContextBudgetManager(mode=ThinkingMode.ULTRATHINK)

        # Check before delegating
        decision = manager.check_before_delegation(
            subagent_type="Explore",
            estimated_scope_size=50
        )

        if decision == DelegationDecision.PROCEED:
            result = Task(...)
            manager.register_agent(result.agent_id, ...)
    """

    # Usage thresholds for delegation decisions
    CRITICAL_USAGE = 0.85    # Abort delegations
    HIGH_USAGE = 0.70        # Reduce scope
    MODERATE_USAGE = 0.50    # Proceed with caution

    # Estimated tokens per tool call (heuristic)
    TOKENS_PER_TOOL_CALL = 1500  # ~1.5% of 100K context

    def __init__(
        self,
        mode: ThinkingMode = ThinkingMode.STANDARD,
        context_window: Optional[ContextWindow] = None,
        subagent_budget: Optional[SubagentBudget] = None,
        registry_path: Optional[str] = None,
    ):
        """
        Initialize ContextBudgetManager.

        Args:
            mode: Thinking mode (STANDARD, EXTENDED, ULTRATHINK)
            context_window: Custom context window config
            subagent_budget: Custom subagent budget config
            registry_path: Path to persist agent registry
        """
        self.mode = mode
        self.context_window = context_window or ContextWindow()
        self.subagent_budget = subagent_budget or SubagentBudget()

        # Agent registry for resume support
        self.agent_registry: Dict[str, AgentRecord] = {}

        # Registry persistence path
        self.registry_path = registry_path or os.path.join(
            os.path.expanduser("~"),
            ".agent",
            "registry",
            "agent_registry.json"
        )

        # Load existing registry if available
        self._load_registry()

        # Track tool calls for context estimation
        self._tool_call_count = 0
        self._session_start = datetime.now(timezone.utc)

        logger.info(
            f"ContextBudgetManager initialized: mode={mode.value}, "
            f"effective_window={self.get_effective_window():,}"
        )

    def get_effective_window(self) -> int:
        """
        Get effective context window for current thinking mode.

        V2.1.7 Fix: Properly reserves space for max output tokens.
        """
        return self.context_window.get_effective_for_mode(self.mode)

    def get_budget_for_subagent(self, subagent_type: str) -> int:
        """Get recommended budget for subagent type in current mode."""
        return self.subagent_budget.get_budget(subagent_type, self.mode)

    def estimate_context_usage(self) -> float:
        """
        Estimate current context usage (0-1 scale).

        Uses tool call count as heuristic since direct token
        counting is not available.
        """
        estimated_tokens = self._tool_call_count * self.TOKENS_PER_TOOL_CALL
        effective_window = self.get_effective_window()

        return min(1.0, estimated_tokens / effective_window)

    def estimate_remaining_tokens(self) -> int:
        """Estimate remaining tokens in effective context window."""
        usage = self.estimate_context_usage()
        effective_window = self.get_effective_window()

        return int(effective_window * (1 - usage))

    def record_tool_call(self, tool_name: str = "unknown"):
        """Record a tool call for context estimation."""
        self._tool_call_count += 1
        logger.debug(f"Tool call recorded: {tool_name}, total={self._tool_call_count}")

    def check_before_delegation(
        self,
        subagent_type: str = "Explore",
        estimated_scope_size: int = 10,
        custom_budget: Optional[int] = None,
    ) -> DelegationDecision:
        """
        Check if delegation should proceed based on context status.

        Args:
            subagent_type: Type of subagent to delegate to
            estimated_scope_size: Estimated number of files in scope
            custom_budget: Override default budget

        Returns:
            DelegationDecision indicating how to proceed
        """
        usage = self.estimate_context_usage()
        remaining = self.estimate_remaining_tokens()
        budget = custom_budget or self.get_budget_for_subagent(subagent_type)

        # Check if delegation would exceed remaining context
        if budget > remaining:
            logger.warning(
                f"Budget {budget:,} exceeds remaining tokens {remaining:,}"
            )
            return DelegationDecision.ABORT

        # Decision based on usage thresholds
        if usage >= self.CRITICAL_USAGE:
            logger.warning(f"Critical context usage: {usage:.1%}")
            return DelegationDecision.ABORT

        elif usage >= self.HIGH_USAGE:
            logger.info(f"High context usage: {usage:.1%}, reducing scope")
            return DelegationDecision.REDUCE_SCOPE

        elif usage >= self.MODERATE_USAGE:
            logger.info(f"Moderate context usage: {usage:.1%}")
            return DelegationDecision.PROCEED

        else:
            return DelegationDecision.PROCEED

    def get_budget_report(
        self,
        subagent_type: str = "Explore"
    ) -> BudgetReport:
        """Generate comprehensive budget status report."""
        usage = self.estimate_context_usage()
        remaining = self.estimate_remaining_tokens()
        budget = self.get_budget_for_subagent(subagent_type)
        decision = self.check_before_delegation(subagent_type)

        warnings = []

        if usage >= self.CRITICAL_USAGE:
            warnings.append("⚠️ CRITICAL: Context window nearly exhausted")
        elif usage >= self.HIGH_USAGE:
            warnings.append("⚠️ HIGH: Consider reducing task scope")

        if budget > remaining:
            warnings.append(f"⚠️ Budget {budget:,} exceeds remaining {remaining:,}")

        if len(self.agent_registry) > 5:
            warnings.append(f"⚠️ {len(self.agent_registry)} agents in registry")

        return BudgetReport(
            thinking_mode=self.mode,
            full_window=self.context_window.full_window,
            effective_window=self.get_effective_window(),
            estimated_usage=usage,
            remaining_tokens=remaining,
            recommended_budget=min(budget, remaining),
            decision=decision,
            warnings=warnings,
        )

    def get_dynamic_budget(
        self,
        subagent_type: str,
        usage_override: Optional[float] = None,
    ) -> int:
        """
        Get dynamically adjusted budget based on context usage.

        Reduces budget as context fills up to ensure completion.

        Args:
            subagent_type: Type of subagent
            usage_override: Override estimated usage (for testing)

        Returns:
            Adjusted token budget
        """
        base_budget = self.get_budget_for_subagent(subagent_type)
        usage = usage_override if usage_override is not None else self.estimate_context_usage()

        # Dynamic scaling based on usage
        if usage >= self.CRITICAL_USAGE:
            return int(base_budget * 0.25)  # 75% reduction
        elif usage >= self.HIGH_USAGE:
            return int(base_budget * 0.50)  # 50% reduction
        elif usage >= self.MODERATE_USAGE:
            return int(base_budget * 0.75)  # 25% reduction
        else:
            return base_budget  # Full budget

    # ─────────────────────────────────────────────────────────────────────
    # Agent Registry Management (Resume Support)
    # ─────────────────────────────────────────────────────────────────────

    def register_agent(
        self,
        agent_id: str,
        subagent_type: str,
        description: str,
        output_tokens: int = 0,
    ) -> AgentRecord:
        """
        Register a delegated agent for resume support.

        V2.1.x Feature: Enables resumption after Auto-Compact.

        Args:
            agent_id: Agent ID from Task result
            subagent_type: Type of subagent
            description: Task description
            output_tokens: Tokens used by agent output

        Returns:
            Created AgentRecord
        """
        record = AgentRecord(
            agent_id=agent_id,
            subagent_type=subagent_type,
            description=description,
            created_at=datetime.now(timezone.utc).isoformat(),
            output_tokens_used=output_tokens,
        )

        self.agent_registry[agent_id] = record
        self._save_registry()

        logger.info(f"Agent registered: {agent_id} ({subagent_type})")
        return record

    def mark_agent_completed(self, agent_id: str, output_tokens: int = 0):
        """Mark an agent as completed."""
        if agent_id in self.agent_registry:
            self.agent_registry[agent_id].status = "completed"
            self.agent_registry[agent_id].output_tokens_used = output_tokens
            self.agent_registry[agent_id].resumable = False
            self._save_registry()

    def mark_agent_failed(self, agent_id: str, resumable: bool = True):
        """Mark an agent as failed, optionally allowing resume."""
        if agent_id in self.agent_registry:
            self.agent_registry[agent_id].status = "failed"
            self.agent_registry[agent_id].resumable = resumable
            self._save_registry()

    def get_resumable_agents(self) -> List[AgentRecord]:
        """Get list of agents that can be resumed."""
        return [
            record for record in self.agent_registry.values()
            if record.resumable and record.status in ("running", "failed")
        ]

    def get_agent(self, agent_id: str) -> Optional[AgentRecord]:
        """Get agent record by ID."""
        return self.agent_registry.get(agent_id)

    def cleanup_old_agents(self, max_age_hours: int = 1):
        """Remove agents older than max_age_hours."""
        cutoff = datetime.now(timezone.utc)
        removed = []

        for agent_id, record in list(self.agent_registry.items()):
            try:
                created = datetime.fromisoformat(record.created_at.replace('Z', '+00:00'))
                age_hours = (cutoff - created).total_seconds() / 3600

                if age_hours > max_age_hours:
                    del self.agent_registry[agent_id]
                    removed.append(agent_id)
            except Exception as e:
                logger.warning(f"Error checking agent age: {e}")

        if removed:
            self._save_registry()
            logger.info(f"Cleaned up {len(removed)} old agents")

        return removed

    def _load_registry(self):
        """Load agent registry from disk."""
        if os.path.exists(self.registry_path):
            try:
                with open(self.registry_path, 'r') as f:
                    data = json.load(f)
                    self.agent_registry = {
                        k: AgentRecord.from_dict(v)
                        for k, v in data.get("agents", {}).items()
                    }
                    logger.debug(f"Loaded {len(self.agent_registry)} agents from registry")
            except Exception as e:
                logger.warning(f"Failed to load agent registry: {e}")

    def _save_registry(self):
        """Save agent registry to disk."""
        try:
            os.makedirs(os.path.dirname(self.registry_path), exist_ok=True)

            data = {
                "agents": {k: v.to_dict() for k, v in self.agent_registry.items()},
                "updated_at": datetime.now(timezone.utc).isoformat(),
                "mode": self.mode.value,
            }

            with open(self.registry_path, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.warning(f"Failed to save agent registry: {e}")

    # ─────────────────────────────────────────────────────────────────────
    # Mode Management
    # ─────────────────────────────────────────────────────────────────────

    def set_mode(self, mode: ThinkingMode):
        """Change thinking mode."""
        old_mode = self.mode
        self.mode = mode
        logger.info(f"Thinking mode changed: {old_mode.value} -> {mode.value}")

    def get_mode_info(self) -> Dict[str, Any]:
        """Get information about current thinking mode."""
        return {
            "mode": self.mode.value,
            "effective_window": self.get_effective_window(),
            "budgets": {
                "Explore": self.get_budget_for_subagent("Explore"),
                "Plan": self.get_budget_for_subagent("Plan"),
                "general-purpose": self.get_budget_for_subagent("general-purpose"),
            },
            "description": {
                ThinkingMode.STANDARD: "Conservative budgets, standard analysis",
                ThinkingMode.EXTENDED: "Balanced budgets, deeper analysis",
                ThinkingMode.ULTRATHINK: "Maximum budgets, comprehensive analysis",
            }[self.mode]
        }


# ─────────────────────────────────────────────────────────────────────────────
# Convenience Functions
# ─────────────────────────────────────────────────────────────────────────────

def check_context_before_task(
    subagent_type: str = "Explore",
    mode: ThinkingMode = ThinkingMode.STANDARD,
) -> Tuple[DelegationDecision, BudgetReport]:
    """
    Quick check before Task delegation.

    Usage:
        decision, report = check_context_before_task("Explore", ThinkingMode.ULTRATHINK)
        if decision == DelegationDecision.PROCEED:
            Task(...)
    """
    manager = ContextBudgetManager(mode=mode)
    decision = manager.check_before_delegation(subagent_type)
    report = manager.get_budget_report(subagent_type)
    return decision, report


def get_ultrathink_budget(subagent_type: str = "Explore") -> int:
    """Get budget for ULTRATHINK mode."""
    manager = ContextBudgetManager(mode=ThinkingMode.ULTRATHINK)
    return manager.get_budget_for_subagent(subagent_type)


# Module-level singleton for session-wide tracking
_session_manager: Optional[ContextBudgetManager] = None


def get_session_manager(mode: ThinkingMode = ThinkingMode.STANDARD) -> ContextBudgetManager:
    """Get or create session-wide ContextBudgetManager."""
    global _session_manager
    if _session_manager is None:
        _session_manager = ContextBudgetManager(mode=mode)
    return _session_manager


def reset_session_manager():
    """Reset session manager (for testing)."""
    global _session_manager
    _session_manager = None
