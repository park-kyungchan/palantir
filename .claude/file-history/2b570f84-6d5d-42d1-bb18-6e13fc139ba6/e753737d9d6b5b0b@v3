# =============================================================================
# Worker Task: Terminal-C - Enhanced Pipeline Skills
# =============================================================================
# Read this file AFTER reading _context.yaml
#
# Location: .agent/prompts/pending/worker-terminal-c-enhanced-pipeline.yaml
# Language: English (Machine-Readable)
# =============================================================================

assignedTo: "terminal-c"
orchestrator: "Terminal-A"
createdAt: "2026-01-24T20:55:00Z"

# =============================================================================
# CONTEXT REFERENCE
# =============================================================================
contextFile: ".agent/prompts/_context.yaml"
progressFile: ".agent/prompts/_progress.yaml"
planningDocument: ".agent/plans/enhanced_pipeline_skills_20260124.yaml"
researchDocument: ".agent/research/enhanced_pipeline_skills_20260124.md"

# =============================================================================
# ASSIGNED TASKS (in execution order)
# =============================================================================

tasks:
  # ---------------------------------------------------------------------------
  # Task 1: /planning skill (No dependencies - can start immediately)
  # ---------------------------------------------------------------------------
  - nativeTaskId: "17"
    phaseId: "phase2-planning-skill"
    name: "Implement /planning skill"
    canStartImmediately: true
    priority: "P0"

    scope: |
      Create the /planning skill for YAML planning document generation.
      Includes Plan Agent review loop for quality assurance.

    targetFiles:
      - path: "/home/palantir/.claude/skills/planning/SKILL.md"
        action: "create"
        readOnly: false

    referenceFiles:
      - path: "/home/palantir/.claude/skills/orchestrate/SKILL.md"
        reason: "Phase decomposition patterns"
      - path: "/home/palantir/.agent/plans/enhanced_pipeline_skills_20260124.yaml"
        reason: "Example planning document format"

    detailedInstructions: |
      1. Create directory: mkdir -p /home/palantir/.claude/skills/planning

      2. Create SKILL.md with frontmatter:
         ```yaml
         ---
         name: planning
         description: |
           Generate YAML planning documents from research results.
           Includes Plan Agent review loop for quality assurance.
           Outputs structured execution blueprints for /orchestrate.
         user-invocable: true
         disable-model-invocation: false
         context: standard
         model: opus
         version: "1.0.0"
         argument-hint: "[--research-slug <slug>] [--auto-approve]"
         allowed-tools:
           - Read
           - Write
           - Task
           - AskUserQuestion
         hooks:
           Stop:
             - type: command
               command: "/home/palantir/.claude/hooks/planning-finalize.sh"
               timeout: 150000
         ---
         ```

      3. Include sections:
         - Purpose: YAML planning document generation
         - Input Processing:
           * Read .agent/research/{slug}.md
           * Read .agent/clarify/{slug}.yaml
           * Extract key findings and requirements
         - Planning Document Schema:
           * metadata (id, version, status, sources)
           * project (name, description, objectives)
           * phases (id, name, priority, dependencies, targetFiles, completionCriteria)
           * dependencies (internal, external)
           * planAgentReview (status, comments)
         - Plan Agent Review Process:
           * Delegate to Plan Agent via Task tool
           * Validate dependency graph is acyclic
           * Check all phases have completion criteria
           * Iterate until approval
         - Output Path: .agent/plans/{slug}.yaml

      4. Plan Agent Review Logic:
         ```python
         # Delegate to Plan Agent
         review = Task(
           subagent_type="Plan",
           prompt=f"""
           Review this planning document:
           {planning_doc}

           Validate:
           1. Dependency graph is acyclic
           2. All phases have completion criteria
           3. Target files exist or creation is justified
           4. Risks are identified

           Return: APPROVED or list of issues
           """
         )

         if review.status != "APPROVED":
           iterate_on_issues(review.comments)
         ```

    completionCriteria:
      - "SKILL.md created with complete V2.1.19 frontmatter"
      - "Planning document YAML schema fully specified"
      - "Plan Agent review process documented"
      - "Stop hook configuration for finalization"
      - "Integration with /research output documented"

    onComplete:
      - "TaskUpdate(taskId='17', status='completed')"
      - "Notify: Task #19, #20, #22 may now be unblocked"

  # ---------------------------------------------------------------------------
  # Task 2: planning-finalize.sh hook (Depends on Task 17)
  # ---------------------------------------------------------------------------
  - nativeTaskId: "19"
    phaseId: "phase3b-planning-hook"
    name: "Create planning-finalize.sh hook"
    canStartImmediately: false
    blockedBy: ["17"]
    priority: "P1"

    scope: |
      Create Stop hook for /planning skill finalization.
      Validates planning document, records Plan Agent approval.

    targetFiles:
      - path: "/home/palantir/.claude/hooks/planning-finalize.sh"
        action: "create"
        readOnly: false

    referenceFiles:
      - path: "/home/palantir/.claude/hooks/clarify-finalize.sh"
        reason: "Similar hook pattern"

    detailedInstructions: |
      1. Create hook script with:
         - Shebang: #!/bin/bash
         - Validate planning document exists at .agent/plans/
         - Check planAgentReview.status == "approved"
         - Log completion timestamp
         - Output suggestion: "Next step: /orchestrate"

      2. Make executable: chmod +x

      3. Hook should:
         - Read latest planning document
         - Validate YAML structure with yq
         - Check status field
         - Log to .agent/logs/planning.log

    completionCriteria:
      - "Hook script created and executable"
      - "Validates planning document schema"
      - "Records Plan Agent review status"

    onComplete:
      - "TaskUpdate(taskId='19', status='completed')"

  # ---------------------------------------------------------------------------
  # Task 3: /synthesis update (Depends on Task 20)
  # ---------------------------------------------------------------------------
  - nativeTaskId: "21"
    phaseId: "phase5a-synthesis-update"
    name: "Update /synthesis integration for RSIL"
    canStartImmediately: false
    blockedBy: ["20"]
    priority: "P1"

    scope: |
      Modify /synthesis skill to suggest /rsil-plan when decision is ITERATE.
      Update decision block to include RSIL path.

    targetFiles:
      - path: "/home/palantir/.claude/skills/synthesis/SKILL.md"
        action: "modify"
        readOnly: false
        sections:
          - "decision_block"
          - "integration_points"

    referenceFiles:
      - path: "/home/palantir/.claude/skills/synthesis/SKILL.md"
        reason: "Current synthesis skill to be modified"
      - path: "/home/palantir/.claude/skills/rsil-plan/SKILL.md"
        reason: "RSIL skill for integration reference"

    detailedInstructions: |
      1. Open /home/palantir/.claude/skills/synthesis/SKILL.md

      2. Find the ITERATE decision block in getDecisionBlock function

      3. Update nextAction from:
         `/clarify "Address gaps: ${gapDescriptions}"`
         To:
         `/rsil-plan --iteration ${iteration_count}`

      4. Update the ITERATE return block to:
         ```javascript
         return `**Status: ITERATE** üîÑ

         **Rationale:**
         ${decisionResult.rationale.map(r => `- ${r}`).join('\n')}

         **Gaps to Address:**
         ${decisionResult.gaps.map((g, i) => `${i + 1}. ${g.requirementId}: ${g.requirement}`).join('\n')}

         **Next Action:**
         \`\`\`bash
         /rsil-plan --iteration ${iteration_count}
         \`\`\`

         RSIL will perform code-level gap analysis and create remediation plan.
         For manual iteration, use: /clarify "Address gaps: ..."
         `
         ```

      5. Update Integration Points section (## 7):
         Add /rsil-plan to the pipeline diagram:
         ```
         /synthesis
             ‚îÇ
             ‚îú‚îÄ‚îÄ COMPLETE ‚îÄ‚îÄ‚ñ∂ /commit-push-pr
             ‚îÇ
             ‚îî‚îÄ‚îÄ ITERATE ‚îÄ‚îÄ‚îÄ‚ñ∂ /rsil-plan (2nd+ Loop)
                                 ‚îÇ
                                 ‚îú‚îÄ‚îÄ Auto-Remediate ‚Üí /orchestrate
                                 ‚îî‚îÄ‚îÄ Escalate ‚Üí /clarify
         ```

      6. Bump version from 2.1.0 to 2.2.0 in frontmatter

    completionCriteria:
      - "ITERATE decision suggests /rsil-plan"
      - "Integration points updated with /rsil-plan"
      - "Version bumped to 2.2.0"

    onComplete:
      - "TaskUpdate(taskId='21', status='completed')"
      - "Notify: Task #23 (E2E testing) may now be unblocked"

# =============================================================================
# GLOBAL CONTEXT CONSIDERATIONS
# =============================================================================

globalContext:
  architecture: "Hybrid (Native Task System + File-Based Prompts)"
  fileNamingConvention: "kebab-case for skills, snake_case for outputs"
  skillVersion: "V2.1.19"
  outputFormat: "L1/L2/L3 Progressive Disclosure"

# =============================================================================
# OUTPUT FORMAT
# =============================================================================

outputFormat: "L1/L2/L3"
reportPath: ".agent/outputs/terminal-c/enhanced-pipeline-report.md"

# =============================================================================
# AUTONOMOUS EXECUTION INSTRUCTIONS (ÏûêÏú® Ïã§Ìñâ ÏßÄÏπ®)
# =============================================================================
# Terminal-CÎäî Ïù¥ ÏßÄÏπ®Ïóê Îî∞Îùº ÏµúÏ¢Ö ÏôÑÎ£åÍπåÏßÄ ÏûêÏú®Ï†ÅÏúºÎ°ú ÏûëÏóÖÏùÑ ÏßÑÌñâÌï©ÎãàÎã§.
# =============================================================================

autonomousExecution:
  enabled: true
  myTerminal: "terminal-c"
  myTasks: ["17", "19", "21"]

  # -------------------------------------------------------------------------
  # EXECUTION SEQUENCE (Ïã§Ìñâ ÏàúÏÑú)
  # -------------------------------------------------------------------------
  executionSequence:
    - step: 1
      taskId: "17"
      name: "Implement /planning skill"
      blockedBy: []
      action: "START IMMEDIATELY"
      onComplete: "Unblocks #19, #20 (Terminal-B partially), #22 (Terminal-B partially)"

    - step: 2
      taskId: "19"
      name: "Create planning-finalize.sh hook"
      blockedBy: ["17"]
      action: "Wait for #17, then start"
      onComplete: "No direct unblocks"

    - step: 3
      taskId: "21"
      name: "Update /synthesis integration for RSIL"
      blockedBy: ["20"]
      action: "Wait for #20 (Terminal-B), then start"
      onComplete: "Unblocks #23 (partially)"

  # -------------------------------------------------------------------------
  # SELF-MONITORING LOOP (ÏûêÍ∞Ä Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ)
  # -------------------------------------------------------------------------
  monitoringLoop: |
    REPEAT until all myTasks completed:
      1. TaskList() ‚Üí Check current status
      2. FOR each taskId in ["17", "19", "21"]:
           task = TaskGet(taskId)
           IF task.status == "pending":
             blockers = task.blockedBy
             allBlockersComplete = TRUE
             FOR each blockerId in blockers:
               blocker = TaskGet(blockerId)
               IF blocker.status != "completed":
                 allBlockersComplete = FALSE
                 BREAK
             IF allBlockersComplete:
               TaskUpdate(taskId, status="in_progress")
               EXECUTE task following detailedInstructions
               TaskUpdate(taskId, status="completed")
               LOG "‚úÖ Task #{taskId} completed"
             ELSE:
               LOG "‚è≥ Task #{taskId} waiting for blockers: {blockers}"
      3. Check if Terminal-B tasks (#16, #20) completed for cross-deps
      4. IF all myTasks completed:
           REPORT "Terminal-C: All tasks completed"
           EXIT loop

  # -------------------------------------------------------------------------
  # CROSS-TERMINAL DEPENDENCY CHECK
  # -------------------------------------------------------------------------
  crossTerminalDeps:
    task21_requires: "Task #20 from Terminal-B"
    checkMethod: "TaskGet('20').status == 'completed'"

  # -------------------------------------------------------------------------
  # COMPLETION CRITERIA
  # -------------------------------------------------------------------------
  completionCriteria:
    allTasksCompleted: ["17", "19", "21"]
    outputGenerated: ".agent/outputs/terminal-c/enhanced-pipeline-report.md"
    progressUpdated: "_progress.yaml reflects terminal-c.status = 'completed'"

# =============================================================================
# ON ALL COMPLETE
# =============================================================================

onAllComplete:
  - "Report to Orchestrator with L1 summary"
  - "Update .agent/prompts/_progress.yaml: terminal-c.status = 'completed'"
  - "Check if Task #23 can start (requires #22 from Terminal-B)"
