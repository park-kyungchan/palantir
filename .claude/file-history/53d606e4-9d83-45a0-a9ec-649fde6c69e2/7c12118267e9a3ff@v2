#!/bin/bash
# =============================================================================
# Claude Code Statusline - Standalone (No external dependencies)
# =============================================================================
# Native implementation using only Claude Code JSON + git + environment variables
#
# Data Sources:
#   - Claude Code JSON (stdin): model, output_style, mcp_servers, workspace
#   - Environment: CLAUDE_CODE_TASK_LIST_ID
#   - Filesystem: ~/.claude/tasks/{id}/*.json
#   - Git: branch, status
# =============================================================================

# Pastel background colors
BG_LINE1="\033[48;2;200;220;255m"     # Light Periwinkle Blue
BG_LINE2="\033[48;2;220;200;255m"     # Light Lavender
BG_LINE3="\033[48;2;200;255;220m"     # Light Mint Green

# Dark text for high contrast
FG_DARK="\033[38;2;30;30;50m"
BOLD="\033[1m"
RESET="\033[0m"

# Read Claude Code JSON from stdin
INPUT=$(cat)

# =============================================================================
# JSON Extraction Helpers
# =============================================================================
json_get() {
    local path="$1"
    if command -v jq &>/dev/null; then
        echo "$INPUT" | jq -r "$path // empty" 2>/dev/null
    fi
}

# =============================================================================
# Line 1: Git Info (branch + status)
# =============================================================================
get_git_info() {
    local branch=""
    local status_icon=""

    # Get current branch
    branch=$(git branch --show-current 2>/dev/null)
    [ -z "$branch" ] && return

    # Check if dirty
    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
        status_icon="ðŸ“"  # Dirty
    else
        status_icon="âœ…"  # Clean
    fi

    echo "${status_icon} ${branch}"
}

# =============================================================================
# Line 2: Model + MCP Status
# =============================================================================
get_model_info() {
    local model=$(json_get '.model')
    local emoji=""

    case "$model" in
        *opus*) emoji="ðŸ§ " ;;
        *sonnet*) emoji="ðŸŽµ" ;;
        *haiku*) emoji="âš¡" ;;
        *) emoji="ðŸ¤–" ;;
    esac

    # Shorten model name
    local short_model=$(echo "$model" | sed 's/claude-//' | sed 's/-[0-9]*$//')

    echo "${emoji} ${short_model}"
}

get_mcp_status() {
    local mcp_count=0
    local mcp_active=0

    if command -v jq &>/dev/null; then
        mcp_count=$(echo "$INPUT" | jq -r '.mcp_servers | length // 0' 2>/dev/null)
        mcp_active=$(echo "$INPUT" | jq -r '[.mcp_servers[] | select(.status == "connected")] | length // 0' 2>/dev/null)
    fi

    if [ "$mcp_count" -gt 0 ] 2>/dev/null; then
        echo "MCP:${mcp_active}/${mcp_count}"
    fi
}

# =============================================================================
# Line 3: Task API + Session Mode
# =============================================================================
get_task_status() {
    local task_base="$HOME/.claude/tasks"
    local task_list_id="${CLAUDE_CODE_TASK_LIST_ID:-}"
    local task_count=0
    local completed_count=0

    [ -z "$task_list_id" ] && return

    local task_dir="${task_base}/${task_list_id}"

    if [ -d "$task_dir" ] && ls "${task_dir}"/*.json &>/dev/null; then
        if command -v jq &>/dev/null; then
            for f in "${task_dir}"/*.json; do
                [ -f "$f" ] || continue
                ((task_count++))
                local status=$(jq -r '.status // "unknown"' "$f" 2>/dev/null)
                [ "$status" = "completed" ] && ((completed_count++))
            done
        else
            for f in "${task_dir}"/*.json; do
                [ -f "$f" ] || continue
                ((task_count++))
                grep -q '"status".*"completed"' "$f" 2>/dev/null && ((completed_count++))
            done
        fi
    fi

    if [ $task_count -gt 0 ]; then
        echo "ðŸ“‹ ${task_list_id} â”‚ âœ“${completed_count}/${task_count}"
    elif [ -n "$task_list_id" ]; then
        echo "ðŸ“‹ ${task_list_id}"
    fi
}

get_session_mode() {
    local style_name=$(json_get '.output_style.name')

    [ -z "$style_name" ] || [ "$style_name" = "null" ] && return

    case "$style_name" in
        "learning") echo "ðŸŽ“ ${style_name}" ;;
        "explanatory") echo "ðŸ“š ${style_name}" ;;
        "default") echo "${style_name}" ;;
        *) echo "âœ¨ ${style_name}" ;;
    esac
}

# =============================================================================
# Build Output Lines
# =============================================================================

# Line 1: Git info
LINE1=$(get_git_info)

# Line 2: Model + MCP
MODEL_INFO=$(get_model_info)
MCP_INFO=$(get_mcp_status)
LINE2="$MODEL_INFO"
[ -n "$MCP_INFO" ] && LINE2="$LINE2 â”‚ $MCP_INFO"

# Line 3: Task + Session Mode
TASK_INFO=$(get_task_status)
SESSION_MODE=$(get_session_mode)
LINE3=""
[ -n "$TASK_INFO" ] && LINE3="$TASK_INFO"
if [ -n "$SESSION_MODE" ]; then
    [ -n "$LINE3" ] && LINE3="$LINE3 â”‚ "
    LINE3="${LINE3}${SESSION_MODE}"
fi

# =============================================================================
# Output with Pastel Backgrounds
# =============================================================================
[ -n "$LINE1" ] && echo -e "${BG_LINE1}${FG_DARK}${BOLD} ${LINE1} ${RESET}"
[ -n "$LINE2" ] && echo -e "${BG_LINE2}${FG_DARK}${BOLD} ${LINE2} ${RESET}"
[ -n "$LINE3" ] && echo -e "${BG_LINE3}${FG_DARK}${BOLD} ${LINE3} ${RESET}"
