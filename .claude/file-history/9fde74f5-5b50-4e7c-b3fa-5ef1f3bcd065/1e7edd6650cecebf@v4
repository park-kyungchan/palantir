---
description: |
  Execute approved plan with Orchestrator-mode enforcement.
  Ensures Main Agent delegates all work to Subagents.
  Includes automatic result verification and recovery gate.
  **[V2.1.9] Progressive-Disclosure Native - Auto L2 generation via PostToolUse Hook**
  **[V2.1.11] Hybrid Execution Model - Dependency-aware parallel execution with L2 Synthesis**
  **[V2.1.12] Output Preservation Enforcement - Forced verification with is_summary_only()**
allowed-tools: Read, Grep, Glob, Bash, TodoWrite, Task, AskUserQuestion, TaskOutput
argument-hint: [plan-file-path]

# V2.1.9 Features
v21x_features:
  progressive_disclosure: true    # Hook auto-generates L2
  suppress_verbose_output: true   # Verbose output hidden from transcript
  auto_l2_generation: true        # L2 structured reports created automatically
  context_efficient: true         # Main Agent context stays lean during execution

# V2.1.11 Features
v2111_features:
  hybrid_execution: true           # Dependency-aware parallel + sequential
  dependency_analyzer: true        # Auto-detect phase dependencies
  l2_synthesis_integration: true   # L2Synthesizer after parallel groups
  parallel_groups: true            # run_in_background=True for independent phases

# V2.1.12 Features (NEW)
v2112_features:
  output_preservation: true        # Forced verification via output_verification.py
  summary_detection: true          # is_summary_only() function
  auto_l2_recovery: true           # Auto-read L2/L3 when summary detected
  blocking_enforcement: true       # BLOCK progress if only summary available
---

# /execute Command (Orchestrator Enforcement)

Execute an approved plan while **enforcing Orchestrator-only behavior**.
Main Agent is **prohibited from direct execution** - all work delegated to Subagents.

## Core Principle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  üéØ ORCHESTRATOR MODE                                           ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  Main Agent = Conductor                                         ‚îÇ
‚îÇ  - Reads plan                                                   ‚îÇ
‚îÇ  - Assigns Subagents                                            ‚îÇ
‚îÇ  - Verifies results                                             ‚îÇ
‚îÇ  - NEVER executes directly                                      ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  Subagents = Performers                                         ‚îÇ
‚îÇ  - Explore: Analysis (15K budget)                               ‚îÇ
‚îÇ  - Plan: Design (25K budget)                                    ‚îÇ
‚îÇ  - general-purpose: Implementation (32K budget)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Arguments

$ARGUMENTS - Optional path to plan file (defaults to most recent IN_PROGRESS plan)

---

## 7-Step Execution Flow

### Step 1: ROLE DECLARATION (Ïó≠Ìï† ÏÑ†Ïñ∏)

**Purpose:** Inject Orchestrator identity into TodoWrite as persistent reminder.

**Mandatory First Todo Item:**
```markdown
üéØ ORCHESTRATOR MODE ACTIVE
   ‚îú‚îÄ ÏßÅÏ†ë Ïã§Ìñâ Í∏àÏßÄ: Edit, Write, Î≥µÏû°Ìïú Bash ÏÇ¨Ïö© Î∂àÍ∞Ä
   ‚îú‚îÄ Î™®Îì† ÏûëÏóÖÏùÄ Task()Î°ú SubagentÏóê ÏúÑÏûÑ
   ‚îî‚îÄ Í≤∞Í≥º Í≤ÄÏ¶ù ÌïÑÏàò: ÏöîÏïΩÎßåÏúºÎ°ú ÏßÑÌñâ Í∏àÏßÄ
```

**Implementation:**
```python
# MANDATORY: Role declaration MUST be first todo item
orchestrator_declaration = {
    "content": "üéØ ORCHESTRATOR: ÏßÅÏ†ë Ïã§Ìñâ Í∏àÏßÄ - Task()Î°ú SubagentÏóê ÏúÑÏûÑ | Í≤∞Í≥º Í≤ÄÏ¶ù ÌïÑÏàò",
    "status": "in_progress",  # Always in_progress to stay visible
    "activeForm": "Orchestrating execution - delegation only"
}

# This item NEVER gets marked as completed
# It persists throughout the entire /execute session
```

---

### Step 2: PLAN RETRIEVAL (Plan ÏùΩÍ∏∞)

**Purpose:** Load the approved plan file for execution.

**Plan File Resolution:**
```python
import os
import glob
from datetime import datetime

def find_plan_file(argument=None):
    """
    Priority order:
    1. Explicit argument (if provided)
    2. Most recent IN_PROGRESS plan
    3. Ask user to select
    """
    if argument:
        return f".agent/plans/{argument}.md"

    # Find all plans
    plans = glob.glob(".agent/plans/*.md")

    # Filter to IN_PROGRESS
    in_progress = []
    for plan_path in plans:
        content = Read(plan_path)
        if "IN_PROGRESS" in content:
            mtime = os.path.getmtime(plan_path)
            in_progress.append((plan_path, mtime))

    if in_progress:
        # Sort by modification time, newest first
        in_progress.sort(key=lambda x: x[1], reverse=True)
        return in_progress[0][0]

    # No IN_PROGRESS plans - ask user
    return None  # Triggers AskUserQuestion
```

**Plan Parsing:**
```python
def parse_plan_file(plan_path):
    """
    Extract execution-relevant information:
    - Tasks table
    - Execution Strategy (Subagent assignments)
    - Critical File Paths
    - Agent Registry (if exists)
    """
    content = Read(plan_path)

    return {
        "tasks": extract_tasks_table(content),
        "strategy": extract_execution_strategy(content),
        "files": extract_critical_files(content),
        "agent_registry": extract_agent_registry(content)
    }
```

---

### Step 3: DELEGATION MAPPING (Subagent Ìï†Îãπ)

**Purpose:** Determine optimal Subagent for each Phase.

**Delegation Rules:**

| Task Type | Keywords | Subagent | Budget |
|-----------|----------|----------|--------|
| Analysis | Î∂ÑÏÑù, ÌÉêÏÉâ, Í≤ÄÌÜ†, analyze, explore, audit | Explore | 15K |
| Design | ÏÑ§Í≥Ñ, Í≥ÑÌöç, ÏïÑÌÇ§ÌÖçÏ≤ò, design, plan, architecture | Plan | 25K |
| Implementation | Íµ¨ÌòÑ, ÏûëÏÑ±, ÏàòÏ†ï, implement, write, modify | general-purpose | 32K |
| Verification | Í≤ÄÏ¶ù, ÌÖåÏä§Ìä∏, ÌôïÏù∏, verify, test, check | general-purpose | 32K |

**Mapping Logic:**
```python
def map_task_to_subagent(task_description):
    """
    Determine subagent type based on task keywords.
    """
    task_lower = task_description.lower()

    # Analysis keywords
    if any(kw in task_lower for kw in ["Î∂ÑÏÑù", "ÌÉêÏÉâ", "Í≤ÄÌÜ†", "analyze", "explore", "audit", "scan"]):
        return ("Explore", 15000)

    # Design keywords
    if any(kw in task_lower for kw in ["ÏÑ§Í≥Ñ", "Í≥ÑÌöç", "ÏïÑÌÇ§ÌÖçÏ≤ò", "design", "plan", "architecture"]):
        return ("Plan", 25000)

    # Default: Implementation
    return ("general-purpose", 32000)
```

---

### Step 4: TODOWRITE GENERATION (TodoWrite ÏÉùÏÑ±)

**Purpose:** Create comprehensive todo list with delegation info and verification requirements.

**Todo Item Format:**
```
[Phase N] {ÏûëÏóÖ ÏÑ§Î™Ö}
  ‚Üí Delegate to: {Subagent}:pending | Budget: {N}K
  ‚Üí Verify: {Í≤ÄÏ¶ù ÏöîÍµ¨ÏÇ¨Ìï≠}
  | Files: {ÎåÄÏÉÅ ÌååÏùº} | Scope: {Î≤îÏúÑ}
```

**Full TodoWrite Template:**
```python
def generate_execution_todos(plan_data):
    todos = []

    # 1. Orchestrator declaration (ALWAYS FIRST)
    todos.append({
        "content": "üéØ ORCHESTRATOR: ÏßÅÏ†ë Ïã§Ìñâ Í∏àÏßÄ - Task()Î°ú SubagentÏóê ÏúÑÏûÑ | Í≤∞Í≥º Í≤ÄÏ¶ù ÌïÑÏàò",
        "status": "in_progress",
        "activeForm": "Orchestrating execution - delegation only"
    })

    # 2. Phase todos
    for i, task in enumerate(plan_data["tasks"]):
        subagent, budget = map_task_to_subagent(task["description"])

        todos.append({
            "content": f"[Phase {i+1}] {task['description']} | ‚Üí Delegate: {subagent}:pending | Budget: {budget//1000}K | Verify: Full Output ÌôïÎ≥¥",
            "status": "pending",
            "activeForm": f"Delegating Phase {i+1} to {subagent}"
        })

    return todos
```

**Example Output:**
```
üéØ ORCHESTRATOR: ÏßÅÏ†ë Ïã§Ìñâ Í∏àÏßÄ - Task()Î°ú SubagentÏóê ÏúÑÏûÑ | Í≤∞Í≥º Í≤ÄÏ¶ù ÌïÑÏàò

[Phase 1] ÏΩîÎìúÎ≤†Ïù¥Ïä§ Íµ¨Ï°∞ Î∂ÑÏÑù | ‚Üí Delegate: Explore:pending | Budget: 15K | Verify: Full Output ÌôïÎ≥¥
[Phase 2] Î≥ÄÍ≤Ω ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù | ‚Üí Delegate: Explore:pending | Budget: 15K | Verify: Full Output ÌôïÎ≥¥
[Phase 3] Íµ¨ÌòÑ ÏÑ§Í≥Ñ Í≤ÄÌÜ† | ‚Üí Delegate: Plan:pending | Budget: 25K | Verify: Full Output ÌôïÎ≥¥
[Phase 4] Í∏∞Îä• Íµ¨ÌòÑ | ‚Üí Delegate: general-purpose:pending | Budget: 32K | Verify: Full Output ÌôïÎ≥¥
[Phase 5] ÌíàÏßà Í≤ÄÏ¶ù | ‚Üí Delegate: general-purpose:pending | Budget: 32K | Verify: Full Output ÌôïÎ≥¥
```

---

### Step 5: HYBRID EXECUTION (V2.1.11 Enhanced)

**Purpose:** Deploy Subagents using Hybrid Execution Model - parallel for independent phases, sequential for dependent phases.

**V2.1.11 Enhancement:** Dependency-aware parallel execution with L2 Synthesis.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    HYBRID EXECUTION FLOW                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Step 5.1: Dependency Analysis                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ phases ‚Üí DependencyAnalyzer ‚Üí execution_groups           ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ Example: [[P1,P2], [P3], [P4,P5]]                        ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ          parallel  seq    parallel                       ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ                           ‚îÇ                                         ‚îÇ
‚îÇ  Step 5.2: Group Execution                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ Group 1 (parallel): Task(P1), Task(P2) run_in_background ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ ‚Üí Wait for all ‚Üí L2Synthesizer ‚Üí proceed                 ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ Group 2 (sequential): Task(P3)                           ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ ‚Üí Verify ‚Üí proceed                                       ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ Group 3 (parallel): Task(P4), Task(P5) run_in_background ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ ‚Üí Wait for all ‚Üí L2Synthesizer ‚Üí complete                ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Execution Implementation:**
```python
from lib.oda.planning.hybrid_execution import (
    HybridExecutor,
    phases_from_plan,
    ExecutionMode,
)
from lib.oda.planning.l2_synthesizer import L2Synthesizer
from lib.oda.planning.output_layer_manager import OutputLayerManager

# 5.1 Convert plan tasks to phases with dependency detection
phases = phases_from_plan(plan_data["tasks"])

# 5.2 Create execution groups
executor = HybridExecutor()
groups = executor.plan(phases)

output_manager = OutputLayerManager()
synthesizer = L2Synthesizer()

# 5.3 Execute each group
for group in groups:
    # Update todos for all phases in group
    for phase in group.phases:
        update_todo_status(phase.id, "in_progress")

    if group.is_parallel:
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PARALLEL EXECUTION: Deploy all phases with run_in_background=True
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        agent_ids = []
        for params in group.get_task_params():
            result = Task(
                subagent_type=params["subagent_type"],
                prompt=params["prompt"],
                description=params["description"],
                run_in_background=True  # V2.1.11: Parallel!
            )
            agent_ids.append(result.agent_id)
            executor.register_agent(
                phase_id=params["description"].split("]")[0] + "]",
                agent_id=result.agent_id,
                agent_type=params["subagent_type"],
                group_id=group.group_id
            )

        # Wait for all parallel agents to complete (via TaskOutput)
        for agent_id in agent_ids:
            TaskOutput(task_id=agent_id, block=True, timeout=300000)

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # L2 SYNTHESIS: Aggregate results into ~500 tokens
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        synthesis_config = executor.get_synthesis_config(
            group,
            synthesis_goal="phase outcomes and critical findings"
        )
        synthesis_result = synthesizer.synthesize(**synthesis_config)
        # synthesis_result contains ~500 tokens of essential context

    else:
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # SEQUENTIAL EXECUTION: Single phase, standard flow
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        params = group.get_task_params()[0]
        result = Task(
            subagent_type=params["subagent_type"],
            prompt=params["prompt"],
            description=params["description"],
            run_in_background=False  # Sequential
        )
        executor.register_agent(
            phase_id=group.phases[0].id,
            agent_id=result.agent_id,
            agent_type=params["subagent_type"],
            group_id=group.group_id
        )

    # 5.4 Update todos with completion status
    for phase in group.phases:
        reg = executor.agent_registry.get(phase.id)
        if reg:
            update_todo_content(
                phase.id,
                f"‚úÖ [{phase.id}] {phase.description} | {reg['agent_type']}:{reg['agent_id']} (done)"
            )
```

**Context Cost Comparison:**

| Approach | 5 Phases | Context Cost | Time |
|----------|----------|--------------|------|
| V2.1.9 Sequential | P1‚ÜíP2‚ÜíP3‚ÜíP4‚ÜíP5 | ~25K tokens | 5 round-trips |
| V2.1.11 Hybrid | [P1,P2]‚Üí[P3]‚Üí[P4,P5] | ~2K tokens | 3 round-trips |
| **Reduction** | - | **~90%** | **40% faster** |
```

**Subagent Prompt Template:**
```python
def generate_subagent_prompt(phase):
    return f"""
## Context
Operating under ODA governance with schema-first, action-only mutation pattern.
This is Phase {phase['number']} of the execution plan.

## Task
{phase['description']}

## Scope
Files: {phase['files']}
Budget: {phase['budget']} tokens maximum

## Required Output
- files_viewed: [list of files examined]
- changes_made: [list of modifications] OR findings: [list of analysis results]
- evidence: [specific line references]

## Constraint: Output Budget
YOUR OUTPUT MUST NOT EXCEED {phase['budget']} TOKENS.
Return ONLY: Key findings, critical changes, summary.
Format: Bullet points with file:line references.

## IMPORTANT
- Provide COMPLETE results, not summaries
- Include all relevant details
- L2 Report will be generated from this output
"""
```

---

### Step 6: RESULT VERIFICATION (Í≤∞Í≥º Í≤ÄÏ¶ù) ‚òÖ V2.1.12 ENFORCED

**Purpose:** Ensure Main Agent has access to FULL results via L2/L3.

**V2.1.12 Enhancement:** Forced verification using lightweight `output_verification.py` module.
Main Agent MUST verify results are complete before proceeding.

**References:**
- `lib/oda/planning/output_verification.py` - Core verification functions (~100 lines)
- `.claude/hooks/output_preservation_hook.py` - PostToolUse Hook for auto-detection
- `.claude/hooks/config/output_preservation_config.yaml` - Hook configuration

**V2.1.12 Enforced Flow:**
```
Task result ‚Üí output_preservation_hook intercepts ‚Üí Summary detected?
                                                          ‚îÇ
                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            No                                                            Yes
                            ‚Üì                                                             ‚Üì
                       Pass through                                                Write L2 report
                                                                                  Inject guidance
                                                                                  Return L1 + path
```

**Main Agent MUST Use:**
```python
from lib.oda.planning.output_verification import (
    is_summary_only,
    verify_subagent_result,
    read_l2_file,
    read_l3_file,
)

# After EVERY Task completion, call verify_subagent_result()
result, status = verify_subagent_result(task_output, agent_id, agent_type)

if status == "complete":
    # Result is complete - proceed
    update_todo_status(phase, "completed")

elif status in ("l2_accessed", "l3_accessed"):
    # Got detailed content automatically - proceed
    task_output = result  # Use detailed content
    update_todo_status(phase, "completed", f"({status})")

elif status == "needs_redelegation":
    # ‚õî BLOCKED: Summary only, no L2/L3 available
    # MUST re-delegate or resume
    update_todo_content(
        phase,
        f"‚ö†Ô∏è BLOCKED: Summary only - Resume required | Agent: {agent_id}"
    )
    AskUserQuestion([{
        "question": "Í≤∞Í≥ºÍ∞Ä ÏöîÏïΩÎßå ÏàòÏã†ÎêòÏóàÏäµÎãàÎã§. Ïñ¥ÎñªÍ≤å ÏßÑÌñâÌï†ÍπåÏöî?",
        "options": [
            {"label": "Resume Agent", "description": f"Task(resume='{agent_id}')"},
            {"label": "Re-execute Phase", "description": "Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú Ïã§Ìñâ"},
        ]
    }])
```

**is_summary_only() Detection Logic:**
```python
# From lib/oda/planning/output_verification.py

SUMMARY_INDICATORS = [
    r"^\s*‚úÖ\s+\w+\[",             # L1 Headline format
    r"^\s*‚ö†Ô∏è\s+\w+\[",             # Warning headline
    r"^\s*‚ùå\s+\w+\[",             # Error headline
    r"summary\s*only",             # Explicit summary marker
    r"truncated",                  # Truncation marker
    r"\.{3}\s*$",                  # Trailing ellipsis
    r"see\s+(L2|L3|full|detailed)", # Reference to detailed layer
    r"abbreviated",                # Abbreviated marker
]

COMPLETENESS_INDICATORS = [
    r"files_viewed\s*[=:]\s*\[",   # Evidence: files_viewed
    r"lines_referenced",           # Evidence: line references
    r"## Critical Findings",       # Report section
    r"## Recommendations",         # Report section
    r"## Evidence",                # Report section
]

MIN_COMPLETE_CHARS = 500
MIN_COMPLETE_LINES = 20

def is_summary_only(result: str) -> Tuple[bool, List[str]]:
    """
    Detect if result is a summary/headline rather than complete output.
    Returns (is_summary: bool, reasons: List[str])
    """
    # Returns True if result matches summary patterns OR
    # is too short AND lacks completeness indicators
```

**Layer Access Priority:**
1. **L2 Structured** (`.agent/outputs/{type}/{id}_structured.md`) - ~2000 tokens
2. **L3 Raw** (`/tmp/claude/.../tasks/{id}.output`) - Full output
3. **Resume** (`Task(resume=agent_id)`) - Full context recovery

**When to Read L2:**
- Phase requires detailed results for next phase
- Synthesis step needs complete information
- Verification of specific file changes

**When L1 Headline Sufficient:**
- Progress tracking (TodoWrite update)
- Simple pass/fail status
- Moving to next independent phase

**HARD RULE: ÏöîÏïΩÎßåÏúºÎ°ú Îã§Ïùå Îã®Í≥Ñ ÏßÑÌñâ Í∏àÏßÄ**

---

### Step 7: RECOVERY GATE (Î≥µÍµ¨ Í≤åÏù¥Ìä∏) ‚òÖ BLOCKING

**Purpose:** BLOCK progress if only summary available.

**HARD RULE: ÏöîÏïΩÎßåÏúºÎ°ú Îã§Ïùå Îã®Í≥Ñ ÏßÑÌñâ Í∏àÏßÄ**

**Recovery Gate Logic:**
```python
def recovery_gate(verification_status, agent_id, phase):
    """
    BLOCKING GATE: Cannot proceed without full results.
    """
    if verification_status == "COMPLETE":
        # Mark phase as completed
        update_todo_status(phase, "completed", f"{phase['subagent']}:{agent_id} (done)")
        return True

    elif verification_status in ["L2_RECOVERED", "L3_RECOVERED"]:
        # Recovered from L2/L3 - can proceed
        update_todo_status(phase, "completed", f"{phase['subagent']}:{agent_id} ({verification_status})")
        return True

    else:  # NEEDS_RECOVERY
        # BLOCK: Cannot proceed
        handle_recovery_failure(agent_id, phase)
        return False

def handle_recovery_failure(agent_id, phase):
    """
    Block progress and guide recovery.
    """
    # Update todo with warning
    update_todo_content(
        phase,
        f"‚ö†Ô∏è BLOCKED: [Phase {phase['number']}] - Í≤∞Í≥º Í≤ÄÏ¶ù Ïã§Ìå® | Agent: {phase['subagent']}:{agent_id}"
    )

    # Present recovery options
    AskUserQuestion([{
        "question": f"Phase {phase['number']} Í≤∞Í≥ºÍ∞Ä ÏöîÏïΩÎßå ÏàòÏã†ÎêòÏóàÏäµÎãàÎã§. Ïñ¥ÎñªÍ≤å ÏßÑÌñâÌï†ÍπåÏöî?",
        "header": "Recovery",
        "options": [
            {
                "label": "Resume Agent (Recommended)",
                "description": f"Task(resume='{agent_id}')Î°ú Ï§ëÎã®Îêú Agent Ïû¨Í∞ú"
            },
            {
                "label": "Re-execute Phase",
                "description": "Ìï¥Îãπ PhaseÎ•º Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú Ïã§Ìñâ"
            },
            {
                "label": "Manual L2 Read",
                "description": f"Read('.agent/outputs/{phase['subagent'].lower()}/{agent_id}.md')Î°ú ÏàòÎèô ÌôïÏù∏"
            }
        ],
        "multiSelect": False
    }])
```

---

## TodoWrite Update Rules

### During Execution

| Event | Todo Update |
|-------|-------------|
| Phase ÏãúÏûë | `status: in_progress`, `‚Üí Delegate: {type}:pending` |
| Agent Î∞∞Ìè¨ ÏôÑÎ£å | `‚Üí Delegate: {type}:{agent_id}` |
| Í≤∞Í≥º Í≤ÄÏ¶ù ÏÑ±Í≥µ | `status: completed`, `{type}:{agent_id} (done)` |
| Í≤ÄÏ¶ù Ïã§Ìå® | `‚ö†Ô∏è BLOCKED: ... | Agent: {type}:{agent_id}` |

### Example Progression

**Initial:**
```
[Phase 1] ÏΩîÎìú Î∂ÑÏÑù | ‚Üí Delegate: Explore:pending | Budget: 15K
```

**After Deployment:**
```
[Phase 1] ÏΩîÎìú Î∂ÑÏÑù | ‚Üí Delegate: Explore:a1b2c3d | Budget: 15K
```

**After Verification (Success):**
```
‚úÖ [Phase 1] ÏΩîÎìú Î∂ÑÏÑù | ‚Üí Delegate: Explore:a1b2c3d (done)
```

**After Verification (Failure):**
```
‚ö†Ô∏è BLOCKED: [Phase 1] ÏΩîÎìú Î∂ÑÏÑù | Agent: Explore:a1b2c3d - Resume ÌïÑÏöî
```

---

## Auto-Compact Recovery

### Recovery from TodoWrite

After Auto-Compact, TodoWrite contains all necessary information:

```
üéØ ORCHESTRATOR: ÏßÅÏ†ë Ïã§Ìñâ Í∏àÏßÄ - Task()Î°ú SubagentÏóê ÏúÑÏûÑ | Í≤∞Í≥º Í≤ÄÏ¶ù ÌïÑÏàò

‚úÖ [Phase 1] ÏΩîÎìú Î∂ÑÏÑù | ‚Üí Delegate: Explore:a1b2c3d (done)
‚úÖ [Phase 2] ÏòÅÌñ•ÎèÑ Î∂ÑÏÑù | ‚Üí Delegate: Explore:b2c3d4e (done)
‚è≥ [Phase 3] ÏÑ§Í≥Ñ Í≤ÄÌÜ† | ‚Üí Delegate: Plan:c3d4e5f | Budget: 25K
[Phase 4] Íµ¨ÌòÑ | ‚Üí Delegate: general-purpose:pending | Budget: 32K
```

**Recovery Steps:**
1. Find in_progress Phase: `[Phase 3]`
2. Extract Agent ID: `c3d4e5f`
3. Resume or verify: `Task(resume="c3d4e5f")` or check L2

### Integration with /recover

```python
# /execute automatically checks for recovery state
if check_recovery_needed():
    Skill(skill="recover")
    # Then resume /execute from interrupted phase
```

---

## Orchestrator Enforcement Rules

### Main Agent ALLOWED Actions

| Action | Allowed | Reason |
|--------|---------|--------|
| `Read` | ‚úÖ | Information gathering |
| `Grep`, `Glob` | ‚úÖ | Search |
| `TodoWrite` | ‚úÖ | Progress tracking |
| `Task()` | ‚úÖ | Subagent delegation |
| `AskUserQuestion` | ‚úÖ | User interaction |

### Main Agent PROHIBITED Actions

| Action | Prohibited | Redirect |
|--------|------------|----------|
| `Edit` | ‚ùå | `Task(subagent_type="general-purpose")` |
| `Write` | ‚ùå | `Task(subagent_type="general-purpose")` |
| Complex `Bash` | ‚ùå | `Task(subagent_type="general-purpose")` |
| Direct implementation | ‚ùå | Delegate to Subagent |

### Enforcement Hook

**Reference:** `.claude/hooks/config/enforcement_config.yaml`

```yaml
enforcement_mode: BLOCK  # As of v2.1.6

# During /execute, these are blocked for Main Agent:
blocked_during_execute:
  - Edit
  - Write
  - NotebookEdit
  - Bash with > 200 chars
  - Bash with > 3 pipes
```

---

## Usage Examples

### Basic Usage (Auto-detect Plan)
```
/execute
```
‚Üí Finds most recent IN_PROGRESS plan and executes

### Specific Plan
```
/execute user_authentication
```
‚Üí Executes `.agent/plans/user_authentication.md`

### After /plan Approval
```
User: /plan ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù Í∏∞Îä• Ï∂îÍ∞Ä
Assistant: [Plan generated, awaiting approval]
User: ÏäπÏù∏. /execute
Assistant: [Orchestrator mode activated, executing plan...]
```

---

## Integration with /plan

| Workflow Step | Command | Output |
|---------------|---------|--------|
| 1. Requirements | `/ask` | Clarified requirements |
| 2. Planning | `/plan` | Approved plan file |
| 3. Execution | `/execute` | Implemented changes |
| 4. Verification | `/quality-check` | Quality gates passed |

---

## Error Handling

| Error | Cause | Resolution |
|-------|-------|------------|
| No plan found | No IN_PROGRESS plans | Ask user to run `/plan` first |
| Verification failed | Summary-only result | Resume agent or re-execute |
| Subagent timeout | Long-running task | Check L2/L3 for partial results |
| Context exhaustion | Too many parallel tasks | Reduce parallel execution |

---

## Progressive-Disclosure Integration

### L2 Report Generation

After each Phase completion:
```python
output_manager.write_structured_report(
    agent_id=agent_id,
    agent_type=subagent_type,
    task_description=phase["description"],
    result=task_result,
    status="completed"
)
# Creates: .agent/outputs/{type}/{agent_id}.md
```

### Layer Access Priority

1. **L1 (Main Context):** Headline only (~50 tokens)
2. **L2 (On-demand):** Structured report (~2000 tokens)
3. **L3 (Full recovery):** Raw output (unlimited)

---

## Evidence Requirements

This command enforces anti-hallucination:

- Each Phase MUST produce `files_viewed` evidence
- Results without evidence trigger verification failure
- Summary-only results are BLOCKED, not accepted

```python
def validate_evidence(result):
    if "files_viewed" not in result:
        return False, "Missing files_viewed evidence"
    if len(result["files_viewed"]) == 0:
        return False, "Empty files_viewed - no evidence collected"
    return True, "Evidence validated"
```
