---
description: |
  Execute approved plan with Orchestrator-mode enforcement.
  Ensures Main Agent delegates all work to Subagents.
  Includes automatic result verification and recovery gate.
  **[V2.1.9] Progressive-Disclosure Native - Auto L2 generation via PostToolUse Hook**
  **[V2.1.11] Hybrid Execution Model - Dependency-aware parallel execution with L2 Synthesis**
allowed-tools: Read, Grep, Glob, Bash, TodoWrite, Task, AskUserQuestion, TaskOutput
argument-hint: [plan-file-path]

# V2.1.9 Features
v21x_features:
  progressive_disclosure: true    # Hook auto-generates L2
  suppress_verbose_output: true   # Verbose output hidden from transcript
  auto_l2_generation: true        # L2 structured reports created automatically
  context_efficient: true         # Main Agent context stays lean during execution

# V2.1.11 Features (NEW)
v2111_features:
  hybrid_execution: true           # Dependency-aware parallel + sequential
  dependency_analyzer: true        # Auto-detect phase dependencies
  l2_synthesis_integration: true   # L2Synthesizer after parallel groups
  parallel_groups: true            # run_in_background=True for independent phases
---

# /execute Command (Orchestrator Enforcement)

Execute an approved plan while **enforcing Orchestrator-only behavior**.
Main Agent is **prohibited from direct execution** - all work delegated to Subagents.

## Core Principle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ¯ ORCHESTRATOR MODE                                           â”‚
â”‚                                                                 â”‚
â”‚  Main Agent = Conductor                                         â”‚
â”‚  - Reads plan                                                   â”‚
â”‚  - Assigns Subagents                                            â”‚
â”‚  - Verifies results                                             â”‚
â”‚  - NEVER executes directly                                      â”‚
â”‚                                                                 â”‚
â”‚  Subagents = Performers                                         â”‚
â”‚  - Explore: Analysis (15K budget)                               â”‚
â”‚  - Plan: Design (25K budget)                                    â”‚
â”‚  - general-purpose: Implementation (32K budget)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Arguments

$ARGUMENTS - Optional path to plan file (defaults to most recent IN_PROGRESS plan)

---

## 7-Step Execution Flow

### Step 1: ROLE DECLARATION (ì—­í•  ì„ ì–¸)

**Purpose:** Inject Orchestrator identity into TodoWrite as persistent reminder.

**Mandatory First Todo Item:**
```markdown
ğŸ¯ ORCHESTRATOR MODE ACTIVE
   â”œâ”€ ì§ì ‘ ì‹¤í–‰ ê¸ˆì§€: Edit, Write, ë³µì¡í•œ Bash ì‚¬ìš© ë¶ˆê°€
   â”œâ”€ ëª¨ë“  ì‘ì—…ì€ Task()ë¡œ Subagentì— ìœ„ì„
   â””â”€ ê²°ê³¼ ê²€ì¦ í•„ìˆ˜: ìš”ì•½ë§Œìœ¼ë¡œ ì§„í–‰ ê¸ˆì§€
```

**Implementation:**
```python
# MANDATORY: Role declaration MUST be first todo item
orchestrator_declaration = {
    "content": "ğŸ¯ ORCHESTRATOR: ì§ì ‘ ì‹¤í–‰ ê¸ˆì§€ - Task()ë¡œ Subagentì— ìœ„ì„ | ê²°ê³¼ ê²€ì¦ í•„ìˆ˜",
    "status": "in_progress",  # Always in_progress to stay visible
    "activeForm": "Orchestrating execution - delegation only"
}

# This item NEVER gets marked as completed
# It persists throughout the entire /execute session
```

---

### Step 2: PLAN RETRIEVAL (Plan ì½ê¸°)

**Purpose:** Load the approved plan file for execution.

**Plan File Resolution:**
```python
import os
import glob
from datetime import datetime

def find_plan_file(argument=None):
    """
    Priority order:
    1. Explicit argument (if provided)
    2. Most recent IN_PROGRESS plan
    3. Ask user to select
    """
    if argument:
        return f".agent/plans/{argument}.md"

    # Find all plans
    plans = glob.glob(".agent/plans/*.md")

    # Filter to IN_PROGRESS
    in_progress = []
    for plan_path in plans:
        content = Read(plan_path)
        if "IN_PROGRESS" in content:
            mtime = os.path.getmtime(plan_path)
            in_progress.append((plan_path, mtime))

    if in_progress:
        # Sort by modification time, newest first
        in_progress.sort(key=lambda x: x[1], reverse=True)
        return in_progress[0][0]

    # No IN_PROGRESS plans - ask user
    return None  # Triggers AskUserQuestion
```

**Plan Parsing:**
```python
def parse_plan_file(plan_path):
    """
    Extract execution-relevant information:
    - Tasks table
    - Execution Strategy (Subagent assignments)
    - Critical File Paths
    - Agent Registry (if exists)
    """
    content = Read(plan_path)

    return {
        "tasks": extract_tasks_table(content),
        "strategy": extract_execution_strategy(content),
        "files": extract_critical_files(content),
        "agent_registry": extract_agent_registry(content)
    }
```

---

### Step 3: DELEGATION MAPPING (Subagent í• ë‹¹)

**Purpose:** Determine optimal Subagent for each Phase.

**Delegation Rules:**

| Task Type | Keywords | Subagent | Budget |
|-----------|----------|----------|--------|
| Analysis | ë¶„ì„, íƒìƒ‰, ê²€í† , analyze, explore, audit | Explore | 15K |
| Design | ì„¤ê³„, ê³„íš, ì•„í‚¤í…ì²˜, design, plan, architecture | Plan | 25K |
| Implementation | êµ¬í˜„, ì‘ì„±, ìˆ˜ì •, implement, write, modify | general-purpose | 32K |
| Verification | ê²€ì¦, í…ŒìŠ¤íŠ¸, í™•ì¸, verify, test, check | general-purpose | 32K |

**Mapping Logic:**
```python
def map_task_to_subagent(task_description):
    """
    Determine subagent type based on task keywords.
    """
    task_lower = task_description.lower()

    # Analysis keywords
    if any(kw in task_lower for kw in ["ë¶„ì„", "íƒìƒ‰", "ê²€í† ", "analyze", "explore", "audit", "scan"]):
        return ("Explore", 15000)

    # Design keywords
    if any(kw in task_lower for kw in ["ì„¤ê³„", "ê³„íš", "ì•„í‚¤í…ì²˜", "design", "plan", "architecture"]):
        return ("Plan", 25000)

    # Default: Implementation
    return ("general-purpose", 32000)
```

---

### Step 4: TODOWRITE GENERATION (TodoWrite ìƒì„±)

**Purpose:** Create comprehensive todo list with delegation info and verification requirements.

**Todo Item Format:**
```
[Phase N] {ì‘ì—… ì„¤ëª…}
  â†’ Delegate to: {Subagent}:pending | Budget: {N}K
  â†’ Verify: {ê²€ì¦ ìš”êµ¬ì‚¬í•­}
  | Files: {ëŒ€ìƒ íŒŒì¼} | Scope: {ë²”ìœ„}
```

**Full TodoWrite Template:**
```python
def generate_execution_todos(plan_data):
    todos = []

    # 1. Orchestrator declaration (ALWAYS FIRST)
    todos.append({
        "content": "ğŸ¯ ORCHESTRATOR: ì§ì ‘ ì‹¤í–‰ ê¸ˆì§€ - Task()ë¡œ Subagentì— ìœ„ì„ | ê²°ê³¼ ê²€ì¦ í•„ìˆ˜",
        "status": "in_progress",
        "activeForm": "Orchestrating execution - delegation only"
    })

    # 2. Phase todos
    for i, task in enumerate(plan_data["tasks"]):
        subagent, budget = map_task_to_subagent(task["description"])

        todos.append({
            "content": f"[Phase {i+1}] {task['description']} | â†’ Delegate: {subagent}:pending | Budget: {budget//1000}K | Verify: Full Output í™•ë³´",
            "status": "pending",
            "activeForm": f"Delegating Phase {i+1} to {subagent}"
        })

    return todos
```

**Example Output:**
```
ğŸ¯ ORCHESTRATOR: ì§ì ‘ ì‹¤í–‰ ê¸ˆì§€ - Task()ë¡œ Subagentì— ìœ„ì„ | ê²°ê³¼ ê²€ì¦ í•„ìˆ˜

[Phase 1] ì½”ë“œë² ì´ìŠ¤ êµ¬ì¡° ë¶„ì„ | â†’ Delegate: Explore:pending | Budget: 15K | Verify: Full Output í™•ë³´
[Phase 2] ë³€ê²½ ì˜í–¥ë„ ë¶„ì„ | â†’ Delegate: Explore:pending | Budget: 15K | Verify: Full Output í™•ë³´
[Phase 3] êµ¬í˜„ ì„¤ê³„ ê²€í†  | â†’ Delegate: Plan:pending | Budget: 25K | Verify: Full Output í™•ë³´
[Phase 4] ê¸°ëŠ¥ êµ¬í˜„ | â†’ Delegate: general-purpose:pending | Budget: 32K | Verify: Full Output í™•ë³´
[Phase 5] í’ˆì§ˆ ê²€ì¦ | â†’ Delegate: general-purpose:pending | Budget: 32K | Verify: Full Output í™•ë³´
```

---

### Step 5: HYBRID EXECUTION (V2.1.11 Enhanced)

**Purpose:** Deploy Subagents using Hybrid Execution Model - parallel for independent phases, sequential for dependent phases.

**V2.1.11 Enhancement:** Dependency-aware parallel execution with L2 Synthesis.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HYBRID EXECUTION FLOW                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Step 5.1: Dependency Analysis                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ phases â†’ DependencyAnalyzer â†’ execution_groups           â”‚       â”‚
â”‚  â”‚ Example: [[P1,P2], [P3], [P4,P5]]                        â”‚       â”‚
â”‚  â”‚          parallel  seq    parallel                       â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                           â”‚                                         â”‚
â”‚  Step 5.2: Group Execution                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ Group 1 (parallel): Task(P1), Task(P2) run_in_background â”‚       â”‚
â”‚  â”‚ â†’ Wait for all â†’ L2Synthesizer â†’ proceed                 â”‚       â”‚
â”‚  â”‚ Group 2 (sequential): Task(P3)                           â”‚       â”‚
â”‚  â”‚ â†’ Verify â†’ proceed                                       â”‚       â”‚
â”‚  â”‚ Group 3 (parallel): Task(P4), Task(P5) run_in_background â”‚       â”‚
â”‚  â”‚ â†’ Wait for all â†’ L2Synthesizer â†’ complete                â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Execution Implementation:**
```python
from lib.oda.planning.hybrid_execution import (
    HybridExecutor,
    phases_from_plan,
    ExecutionMode,
)
from lib.oda.planning.l2_synthesizer import L2Synthesizer
from lib.oda.planning.output_layer_manager import OutputLayerManager

# 5.1 Convert plan tasks to phases with dependency detection
phases = phases_from_plan(plan_data["tasks"])

# 5.2 Create execution groups
executor = HybridExecutor()
groups = executor.plan(phases)

output_manager = OutputLayerManager()
synthesizer = L2Synthesizer()

# 5.3 Execute each group
for group in groups:
    # Update todos for all phases in group
    for phase in group.phases:
        update_todo_status(phase.id, "in_progress")

    if group.is_parallel:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # PARALLEL EXECUTION: Deploy all phases with run_in_background=True
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        agent_ids = []
        for params in group.get_task_params():
            result = Task(
                subagent_type=params["subagent_type"],
                prompt=params["prompt"],
                description=params["description"],
                run_in_background=True  # V2.1.11: Parallel!
            )
            agent_ids.append(result.agent_id)
            executor.register_agent(
                phase_id=params["description"].split("]")[0] + "]",
                agent_id=result.agent_id,
                agent_type=params["subagent_type"],
                group_id=group.group_id
            )

        # Wait for all parallel agents to complete (via TaskOutput)
        for agent_id in agent_ids:
            TaskOutput(task_id=agent_id, block=True, timeout=300000)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # L2 SYNTHESIS: Aggregate results into ~500 tokens
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        synthesis_config = executor.get_synthesis_config(
            group,
            synthesis_goal="phase outcomes and critical findings"
        )
        synthesis_result = synthesizer.synthesize(**synthesis_config)
        # synthesis_result contains ~500 tokens of essential context

    else:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # SEQUENTIAL EXECUTION: Single phase, standard flow
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        params = group.get_task_params()[0]
        result = Task(
            subagent_type=params["subagent_type"],
            prompt=params["prompt"],
            description=params["description"],
            run_in_background=False  # Sequential
        )
        executor.register_agent(
            phase_id=group.phases[0].id,
            agent_id=result.agent_id,
            agent_type=params["subagent_type"],
            group_id=group.group_id
        )

    # 5.4 Update todos with completion status
    for phase in group.phases:
        reg = executor.agent_registry.get(phase.id)
        if reg:
            update_todo_content(
                phase.id,
                f"âœ… [{phase.id}] {phase.description} | {reg['agent_type']}:{reg['agent_id']} (done)"
            )
```

**Context Cost Comparison:**

| Approach | 5 Phases | Context Cost | Time |
|----------|----------|--------------|------|
| V2.1.9 Sequential | P1â†’P2â†’P3â†’P4â†’P5 | ~25K tokens | 5 round-trips |
| V2.1.11 Hybrid | [P1,P2]â†’[P3]â†’[P4,P5] | ~2K tokens | 3 round-trips |
| **Reduction** | - | **~90%** | **40% faster** |
```

**Subagent Prompt Template:**
```python
def generate_subagent_prompt(phase):
    return f"""
## Context
Operating under ODA governance with schema-first, action-only mutation pattern.
This is Phase {phase['number']} of the execution plan.

## Task
{phase['description']}

## Scope
Files: {phase['files']}
Budget: {phase['budget']} tokens maximum

## Required Output
- files_viewed: [list of files examined]
- changes_made: [list of modifications] OR findings: [list of analysis results]
- evidence: [specific line references]

## Constraint: Output Budget
YOUR OUTPUT MUST NOT EXCEED {phase['budget']} TOKENS.
Return ONLY: Key findings, critical changes, summary.
Format: Bullet points with file:line references.

## IMPORTANT
- Provide COMPLETE results, not summaries
- Include all relevant details
- L2 Report will be generated from this output
"""
```

---

### Step 6: RESULT VERIFICATION (ê²°ê³¼ ê²€ì¦) â˜… V2.1.9 SIMPLIFIED

**Purpose:** Ensure Main Agent has access to FULL results via L2.

**V2.1.9 Change:** `progressive_disclosure_hook.py` automatically generates L2 reports.
Main Agent no longer needs manual verification - Hook handles this automatically.

**Reference:** `.claude/hooks/progressive_disclosure_hook.py`

**V2.1.9 Automatic Flow:**
```
Task result â†’ Hook intercepts â†’ L2 written â†’ L1 headline returned
```

**Main Agent Receives:**
```
âœ… GeneralPurpose[abc123]: Phase 4 complete, 3 files modified

## Subagent Result (Progressive-Disclosure)

**L1 Headline:**
âœ… GeneralPurpose[abc123]: Phase 4 complete, 3 files modified

**L2 Report Available:**
Path: `.agent/outputs/general/abc123_structured.md`
To read full details: `Read(".agent/outputs/general/abc123_structured.md")`

**Agent ID (for resume):** `abc123`
```

**Verification Flow (Simplified):**
```python
def verify_result(task_result, agent_id, agent_type):
    """
    V2.1.9: Hook already generated L2. Just check if L2 exists.
    """
    # Hook provides L2 path in additionalContext
    l2_path = f".agent/outputs/{agent_type.lower()}/{agent_id}_structured.md"

    if Path(l2_path).exists():
        # L2 available - can access if details needed
        return task_result, "L2_AVAILABLE"

    # L2 not found (edge case) - use validate_task_result.py fallback
    return task_result, "VERIFY_MANUALLY"
```

**When to Read L2:**
- Phase requires detailed results for next phase
- Synthesis step needs complete information
- Verification of specific file changes

**When L1 Headline Sufficient:**
- Progress tracking (TodoWrite update)
- Simple pass/fail status
- Moving to next independent phase

**Summary Detection Patterns:**
```python
# Patterns indicating summary-only result:
SUMMARY_PATTERNS = [
    r"^\s*âœ…\s+\w+\[",           # L1 Headline format
    r"summary only",             # Explicit summary marker
    r"truncated",                # Truncation marker
]

# Size thresholds:
SUMMARY_THRESHOLDS = {
    "min_chars": 500,            # < 500 chars = likely summary
    "min_lines": 20,             # < 20 lines = likely summary
}
```

---

### Step 7: RECOVERY GATE (ë³µêµ¬ ê²Œì´íŠ¸) â˜… BLOCKING

**Purpose:** BLOCK progress if only summary available.

**HARD RULE: ìš”ì•½ë§Œìœ¼ë¡œ ë‹¤ìŒ ë‹¨ê³„ ì§„í–‰ ê¸ˆì§€**

**Recovery Gate Logic:**
```python
def recovery_gate(verification_status, agent_id, phase):
    """
    BLOCKING GATE: Cannot proceed without full results.
    """
    if verification_status == "COMPLETE":
        # Mark phase as completed
        update_todo_status(phase, "completed", f"{phase['subagent']}:{agent_id} (done)")
        return True

    elif verification_status in ["L2_RECOVERED", "L3_RECOVERED"]:
        # Recovered from L2/L3 - can proceed
        update_todo_status(phase, "completed", f"{phase['subagent']}:{agent_id} ({verification_status})")
        return True

    else:  # NEEDS_RECOVERY
        # BLOCK: Cannot proceed
        handle_recovery_failure(agent_id, phase)
        return False

def handle_recovery_failure(agent_id, phase):
    """
    Block progress and guide recovery.
    """
    # Update todo with warning
    update_todo_content(
        phase,
        f"âš ï¸ BLOCKED: [Phase {phase['number']}] - ê²°ê³¼ ê²€ì¦ ì‹¤íŒ¨ | Agent: {phase['subagent']}:{agent_id}"
    )

    # Present recovery options
    AskUserQuestion([{
        "question": f"Phase {phase['number']} ê²°ê³¼ê°€ ìš”ì•½ë§Œ ìˆ˜ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ ì§„í–‰í• ê¹Œìš”?",
        "header": "Recovery",
        "options": [
            {
                "label": "Resume Agent (Recommended)",
                "description": f"Task(resume='{agent_id}')ë¡œ ì¤‘ë‹¨ëœ Agent ì¬ê°œ"
            },
            {
                "label": "Re-execute Phase",
                "description": "í•´ë‹¹ Phaseë¥¼ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹¤í–‰"
            },
            {
                "label": "Manual L2 Read",
                "description": f"Read('.agent/outputs/{phase['subagent'].lower()}/{agent_id}.md')ë¡œ ìˆ˜ë™ í™•ì¸"
            }
        ],
        "multiSelect": False
    }])
```

---

## TodoWrite Update Rules

### During Execution

| Event | Todo Update |
|-------|-------------|
| Phase ì‹œì‘ | `status: in_progress`, `â†’ Delegate: {type}:pending` |
| Agent ë°°í¬ ì™„ë£Œ | `â†’ Delegate: {type}:{agent_id}` |
| ê²°ê³¼ ê²€ì¦ ì„±ê³µ | `status: completed`, `{type}:{agent_id} (done)` |
| ê²€ì¦ ì‹¤íŒ¨ | `âš ï¸ BLOCKED: ... | Agent: {type}:{agent_id}` |

### Example Progression

**Initial:**
```
[Phase 1] ì½”ë“œ ë¶„ì„ | â†’ Delegate: Explore:pending | Budget: 15K
```

**After Deployment:**
```
[Phase 1] ì½”ë“œ ë¶„ì„ | â†’ Delegate: Explore:a1b2c3d | Budget: 15K
```

**After Verification (Success):**
```
âœ… [Phase 1] ì½”ë“œ ë¶„ì„ | â†’ Delegate: Explore:a1b2c3d (done)
```

**After Verification (Failure):**
```
âš ï¸ BLOCKED: [Phase 1] ì½”ë“œ ë¶„ì„ | Agent: Explore:a1b2c3d - Resume í•„ìš”
```

---

## Auto-Compact Recovery

### Recovery from TodoWrite

After Auto-Compact, TodoWrite contains all necessary information:

```
ğŸ¯ ORCHESTRATOR: ì§ì ‘ ì‹¤í–‰ ê¸ˆì§€ - Task()ë¡œ Subagentì— ìœ„ì„ | ê²°ê³¼ ê²€ì¦ í•„ìˆ˜

âœ… [Phase 1] ì½”ë“œ ë¶„ì„ | â†’ Delegate: Explore:a1b2c3d (done)
âœ… [Phase 2] ì˜í–¥ë„ ë¶„ì„ | â†’ Delegate: Explore:b2c3d4e (done)
â³ [Phase 3] ì„¤ê³„ ê²€í†  | â†’ Delegate: Plan:c3d4e5f | Budget: 25K
[Phase 4] êµ¬í˜„ | â†’ Delegate: general-purpose:pending | Budget: 32K
```

**Recovery Steps:**
1. Find in_progress Phase: `[Phase 3]`
2. Extract Agent ID: `c3d4e5f`
3. Resume or verify: `Task(resume="c3d4e5f")` or check L2

### Integration with /recover

```python
# /execute automatically checks for recovery state
if check_recovery_needed():
    Skill(skill="recover")
    # Then resume /execute from interrupted phase
```

---

## Orchestrator Enforcement Rules

### Main Agent ALLOWED Actions

| Action | Allowed | Reason |
|--------|---------|--------|
| `Read` | âœ… | Information gathering |
| `Grep`, `Glob` | âœ… | Search |
| `TodoWrite` | âœ… | Progress tracking |
| `Task()` | âœ… | Subagent delegation |
| `AskUserQuestion` | âœ… | User interaction |

### Main Agent PROHIBITED Actions

| Action | Prohibited | Redirect |
|--------|------------|----------|
| `Edit` | âŒ | `Task(subagent_type="general-purpose")` |
| `Write` | âŒ | `Task(subagent_type="general-purpose")` |
| Complex `Bash` | âŒ | `Task(subagent_type="general-purpose")` |
| Direct implementation | âŒ | Delegate to Subagent |

### Enforcement Hook

**Reference:** `.claude/hooks/config/enforcement_config.yaml`

```yaml
enforcement_mode: BLOCK  # As of v2.1.6

# During /execute, these are blocked for Main Agent:
blocked_during_execute:
  - Edit
  - Write
  - NotebookEdit
  - Bash with > 200 chars
  - Bash with > 3 pipes
```

---

## Usage Examples

### Basic Usage (Auto-detect Plan)
```
/execute
```
â†’ Finds most recent IN_PROGRESS plan and executes

### Specific Plan
```
/execute user_authentication
```
â†’ Executes `.agent/plans/user_authentication.md`

### After /plan Approval
```
User: /plan ì‚¬ìš©ì ì¸ì¦ ê¸°ëŠ¥ ì¶”ê°€
Assistant: [Plan generated, awaiting approval]
User: ìŠ¹ì¸. /execute
Assistant: [Orchestrator mode activated, executing plan...]
```

---

## Integration with /plan

| Workflow Step | Command | Output |
|---------------|---------|--------|
| 1. Requirements | `/ask` | Clarified requirements |
| 2. Planning | `/plan` | Approved plan file |
| 3. Execution | `/execute` | Implemented changes |
| 4. Verification | `/quality-check` | Quality gates passed |

---

## Error Handling

| Error | Cause | Resolution |
|-------|-------|------------|
| No plan found | No IN_PROGRESS plans | Ask user to run `/plan` first |
| Verification failed | Summary-only result | Resume agent or re-execute |
| Subagent timeout | Long-running task | Check L2/L3 for partial results |
| Context exhaustion | Too many parallel tasks | Reduce parallel execution |

---

## Progressive-Disclosure Integration

### L2 Report Generation

After each Phase completion:
```python
output_manager.write_structured_report(
    agent_id=agent_id,
    agent_type=subagent_type,
    task_description=phase["description"],
    result=task_result,
    status="completed"
)
# Creates: .agent/outputs/{type}/{agent_id}.md
```

### Layer Access Priority

1. **L1 (Main Context):** Headline only (~50 tokens)
2. **L2 (On-demand):** Structured report (~2000 tokens)
3. **L3 (Full recovery):** Raw output (unlimited)

---

## Evidence Requirements

This command enforces anti-hallucination:

- Each Phase MUST produce `files_viewed` evidence
- Results without evidence trigger verification failure
- Summary-only results are BLOCKED, not accepted

```python
def validate_evidence(result):
    if "files_viewed" not in result:
        return False, "Missing files_viewed evidence"
    if len(result["files_viewed"]) == 0:
        return False, "Empty files_viewed - no evidence collected"
    return True, "Evidence validated"
```
