---
name: deep-audit
description: |
  Execute Progressive Deep-Dive Audit with RSIL method.
  Uses forked context with Explore agent for isolated, intensive analysis.
  BLOCK enforcement - must pass before code changes.
  V1.0: TaskDecomposer integration + RSIL 5-phase synthesis
allowed-tools: Read, Grep, Glob, Bash, Task, TodoWrite
argument-hint: <target_path>
version: "1.0"
model: opus
context: fork
block_enforcement: true
---

# /deep-audit Command (RSIL + Forked Context)

$ARGUMENTS

> **Protocol:** AuditProtocol (BLOCK enforcement)
> **Method:** RSIL (Recursive Self-Improvement Loop)
> **Execution:** Forked context with Explore subagent

---

## Native Capability Optimization

This command leverages Claude Code V2.1 features:

| Feature | Usage |
|---------|-------|
| `context: fork` | Isolated execution, no main context pollution |
| `agent: Explore` | Specialized codebase exploration |
| `Task(evidence-collector)` | Background evidence tracking |
| `TodoWrite` | Stage progress visualization |
| `Skill(oda-audit)` | Internal protocol (user-invocable: false) |

---

## Execution Strategy

### Step 1: Initialize with TodoWrite
```python
TodoWrite([
    {"content": "Stage A: SCAN - Map landscape", "status": "in_progress"},
    {"content": "Stage B: TRACE - Verify logic", "status": "pending"},
    {"content": "Stage C: VERIFY - Quality gate", "status": "pending"},
])
```

### Step 2: Launch Forked Audit

```python
# Main audit in forked context (prevents context pollution)
Skill("oda-audit", args="$ARGUMENTS")
# oda-audit skill has: context: fork, agent: Explore
```

### Step 3: Evidence Collection (Background)

```python
Task(
    subagent_type="evidence-collector",
    prompt="Collect audit evidence for: $ARGUMENTS",
    run_in_background=True,
    description="Evidence collection"
)
```

---

## Stage A: SURFACE SCAN (Landscape)

### Goal
Establish Structural Reality & Remove Guesswork.

### Actions
1. **File Structure Analysis**: Map target directory structure
2. **Legacy Artifact Sweep**: Check for deprecated paths, AIP-KEY remnants
3. **Pattern Identification**: Identify key components and modules
4. **Dependency Check**: Verify imports and external dependencies

### Evidence Required
```yaml
files_viewed: [실제 읽은 파일 목록]
legacy_artifacts: CLEAN | DETECTED
structure: {디렉토리 구조 맵}
```

### Verification
- [ ] All target files identified
- [ ] Legacy artifacts status confirmed
- [ ] Structure documented

---

## Stage B: LOGIC TRACE (Deep-Dive)

### Goal
Prevent Integration Failures by Tracing Actual Data Flow.

### Actions
1. **Import Path Verification**: Confirm all imports exist
2. **Call Stack Trace**: Map data flow paths
3. **Signature Matching**: Verify function signatures align
4. **Dependency Mapping**: Identify integration points

### Trace Format
```
[EntryPoint] function_name() file.py:line
    │
    ├── [Dependency] import_path
    │       ↓
    │   Called function: signature
    │
    └── [Output] return type
```

### RSIL Trigger
If signature mismatch found → HALT → CORRECT → RESTART Stage B

### Verification
- [ ] Import paths validated
- [ ] Call stack documented
- [ ] Signatures matched

---

## Stage C: QUALITY GATE (Microscopic Audit)

### Goal
Ensure Micro-to-Macro Consistency.

### Quality Checks
1. **Pattern Fidelity**: Does code match ODA patterns?
2. **Safety Audit**: Type hints, docstrings, null validation
3. **Clean Architecture**: Layer separation
4. **SOLID Principles**: Single responsibility, etc.

### Findings Format
```
[File:Line] [Severity] - Description
```

### Severity Levels
| Level | Action |
|-------|--------|
| CRITICAL | Block execution |
| HIGH | Require fix before merge |
| MEDIUM | Recommend fix |
| LOW | Informational |

### Verification
- [ ] No critical findings
- [ ] High findings documented
- [ ] Quality gate: PASS / FAIL

---

## Output Format

```markdown
### AUDIT REPORT (Deep-Dive)

#### Execution Context
- Method: RSIL + Forked Context
- Agent: Explore
- Evidence Collector: Active

#### Stage A: SCAN
- Target Files: [count]
- Legacy Artifacts: CLEAN/DETECTED
- Structure: Documented
- Evidence: [files_viewed count]

#### Stage B: TRACE
- Import Verification: VALID/INVALID
- Critical Path: Documented
- Signature Match: PASS/FAIL
- RSIL Iterations: [count]

#### Stage C: QUALITY
- Pattern Fidelity: ALIGNED/MISALIGNED
- Findings: [count by severity]
- Quality Gate: PASS/FAIL

#### Evidence Summary
```yaml
files_viewed: [list]
lines_referenced: {file: [lines]}
code_snippets: [count]
```

#### Status
- Audit Result: PASS/FAIL
- Duration: X seconds
- Context: Forked (isolated)
```

---

## When to Use

| Scenario | Command |
|----------|---------|
| Quick scan | `/audit` |
| Pre-merge validation | `/deep-audit` |
| After major refactor | `/deep-audit` |
| Security review | `/deep-audit` |
| Performance investigation | `/deep-audit` |

---

## Integration with Workflow

```
/deep-audit → PASS → /governance → PASS → Proceed with changes
           ↓
         FAIL → Fix issues → /deep-audit (re-run)
```

---

## Example Usage

```
/deep-audit scripts/ontology/           # Deep audit ontology module
/deep-audit .                           # Deep audit entire workspace
/deep-audit hwpx/ --focus security     # Security-focused audit
```

---

**ZERO-TRUST: Do NOT execute code changes until deep-audit passes**
