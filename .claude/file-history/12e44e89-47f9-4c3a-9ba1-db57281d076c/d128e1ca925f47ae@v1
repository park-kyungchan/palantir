# L1/L2 Orchestrating Loop 설계 및 구현

> **Version:** 1.0 | **Status:** IN_PROGRESS | **Date:** 2026-01-19
> **Auto-Compact Safe:** This file persists across context compaction

## Overview

| Item | Value |
|------|-------|
| Complexity | large |
| Total Tasks | 18 |
| Files Affected | ~25 |
| Phases | 5 |

## Requirements

Main Agent가 Subagent에게 작업 위임 시:
1. 출력을 L1(Summary+Index)과 L2(Detail)로 분리
2. L1만으로 오케스트레이션 수행
3. 필요시 L2의 정확한 섹션만 참조
4. Loop 구조로 반복 실행

## Tasks

| # | Phase | Task | Status |
|---|-------|------|--------|
| 1.1 | Phase 1 | ObjectType: AgentOutputL1 | PENDING |
| 1.2 | Phase 1 | ObjectType: AgentOutputL2 | PENDING |
| 1.3 | Phase 1 | ObjectType: DelegationPrompt | PENDING |
| 1.4 | Phase 1 | ObjectType: OrchestrationState | PENDING |
| 2.1 | Phase 2 | LinkType: L1ReferencesL2 | PENDING |
| 2.2 | Phase 2 | LinkType: AgentProducesOutput | PENDING |
| 2.3 | Phase 2 | LinkType: StateContainsOutput | PENDING |
| 3.1 | Phase 3 | ActionType: DelegateToAgent | PENDING |
| 3.2 | Phase 3 | ActionType: ValidateL2Exists | PENDING |
| 3.3 | Phase 3 | ActionType: OrchestrateWithL1 | PENDING |
| 3.4 | Phase 3 | ActionType: RetrieveL2Section | PENDING |
| 3.5 | Phase 3 | ActionType: WriteL2ToFile | PENDING |
| 4.1 | Phase 4 | Interaction: OutputFormatEnforcement | PENDING |
| 4.2 | Phase 4 | Interaction: L2StorageValidation | PENDING |
| 4.3 | Phase 4 | Interaction: IndexConsistency | PENDING |
| 5.1 | Phase 5 | Hook: pre-task-delegation | PENDING |
| 5.2 | Phase 5 | Hook: post-task-output | PENDING |
| 5.3 | Phase 5 | Hook: orchestration-loop | PENDING |

## Progress Tracking

| Phase | Tasks | Completed | Status |
|-------|-------|-----------|--------|
| Phase 1: ObjectTypes | 4 | 0 | PENDING |
| Phase 2: LinkTypes | 3 | 0 | PENDING |
| Phase 3: ActionTypes | 5 | 0 | PENDING |
| Phase 4: Interactions | 3 | 0 | PENDING |
| Phase 5: Stop Hooks | 3 | 0 | PENDING |

## Quick Resume After Auto-Compact

If context is compacted, resume by:

1. Read this file: `.agent/plans/l1_l2_orchestrating_loop.md`
2. Check TodoWrite for current task status
3. Continue from first PENDING task in sequence
4. Use subagent delegation pattern from "Execution Strategy" section

## Execution Strategy

### Phase Dependencies

```
Phase 1 (ObjectTypes) ──┐
                        ├──► Phase 2 (LinkTypes) ──┐
                        │                          │
                        └──────────────────────────┼──► Phase 3 (ActionTypes)
                                                   │           │
                                                   └───────────┼──► Phase 4 (Interactions)
                                                               │           │
                                                               └───────────┴──► Phase 5 (Hooks)
```

### Parallel Execution Groups

**Phase 1 (Parallel):**
- Task(general-purpose): AgentOutputL1
- Task(general-purpose): AgentOutputL2
- Task(general-purpose): DelegationPrompt
- Task(general-purpose): OrchestrationState

**Phase 2 (Parallel, after Phase 1):**
- Task(general-purpose): L1ReferencesL2
- Task(general-purpose): AgentProducesOutput
- Task(general-purpose): StateContainsOutput

**Phase 3 (Parallel, after Phase 2):**
- Task(general-purpose): All 5 ActionTypes

**Phase 4 (Parallel, after Phase 3):**
- Task(general-purpose): All 3 Interactions

**Phase 5 (Sequential, after Phase 4):**
- Write Bash hooks one by one (test each)

### Subagent Delegation

| Task Group | Subagent Type | Context | Budget |
|------------|---------------|---------|--------|
| ObjectTypes (4) | general-purpose | standard | 15K each |
| LinkTypes (3) | general-purpose | standard | 15K each |
| ActionTypes (5) | general-purpose | standard | 15K each |
| Interactions (3) | general-purpose | standard | 15K each |
| Hooks (3) | general-purpose | standard | 15K each |

## Critical File Paths

```yaml
# Schema references
objecttype_schema: ontology_definition/schemas/ObjectType.schema.json
actiontype_schema: ontology_definition/schemas/ActionType.schema.json
linktype_schema: ontology_definition/schemas/LinkType.schema.json
interaction_schema: ontology_definition/schemas/Interaction.schema.json

# Output locations
l2_storage: .agent/outputs/{taskId}/{timestamp}.md
hooks_dir: .claude/hooks/

# ODA skills (reference)
oda_objecttype: .claude/skills/oda-objecttype.md
oda_actiontype: .claude/skills/oda-actiontype.md
oda_linktype: .claude/skills/oda-linktype.md
oda_interaction: .claude/skills/oda-interaction.md
```

## Agent Registry (Auto-Compact Resume)

| Task | Agent ID | Status | Resume Eligible |
|------|----------|--------|-----------------|
| (To be populated during execution) | - | - | - |

## Risk Register

| Risk | Mitigation |
|------|------------|
| Schema validation failure | Use jsonschema validation before deploy |
| Hook execution blocking | Implement timeout + fallback in hooks |
| L2 storage path conflicts | Use UUID-based taskId for uniqueness |
| Circular references in Links | Validate cardinality constraints |

## Notes

- All ODA type definitions must pass JSON Schema validation
- Hooks use Stop Hooks pattern (exit non-zero to block)
- L1 output format is MANDATORY for all subagent responses
