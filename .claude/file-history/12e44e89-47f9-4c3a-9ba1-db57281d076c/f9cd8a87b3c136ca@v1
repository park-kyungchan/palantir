#!/usr/bin/env python3
"""
Orchestration Loop Manager

Manages phase transitions and state persistence for L1/L2 orchestration.
"""
import json
import sys
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import List, Optional, Dict, Any


class OrchestrationPhase(str, Enum):
    INIT = "init"
    ANALYSIS = "analysis"
    PLANNING = "planning"
    EXECUTION = "execution"
    VERIFICATION = "verification"
    REMEDIATION = "remediation"
    COMPLETE = "complete"


class Decision(str, Enum):
    CONTINUE = "CONTINUE"
    TERMINATE = "TERMINATE"
    RETRY = "RETRY"
    ESCALATE = "ESCALATE"


@dataclass
class OrchestrationState:
    phase: OrchestrationPhase = OrchestrationPhase.INIT
    completedPhases: List[str] = field(default_factory=list)
    completedTasks: List[str] = field(default_factory=list)
    pendingL2Refs: List[str] = field(default_factory=list)
    iteration: int = 0
    lastUpdated: str = ""
    blockers: List[str] = field(default_factory=list)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "OrchestrationState":
        return cls(
            phase=OrchestrationPhase(data.get("phase", "init")),
            completedPhases=data.get("completedPhases", []),
            completedTasks=data.get("completedTasks", []),
            pendingL2Refs=data.get("pendingL2Refs", []),
            iteration=data.get("iteration", 0),
            lastUpdated=data.get("lastUpdated", ""),
            blockers=data.get("blockers", []),
        )

    def to_dict(self) -> Dict[str, Any]:
        d = asdict(self)
        d["phase"] = self.phase.value
        return d


class OrchestrationManager:
    """Manages orchestration loop state and transitions."""

    MAX_ITERATIONS = 20
    STATE_DIR = Path(".agent/state")
    STATE_FILE = STATE_DIR / "orchestration.json"

    # Phase transition map
    TRANSITIONS = {
        OrchestrationPhase.INIT: OrchestrationPhase.ANALYSIS,
        OrchestrationPhase.ANALYSIS: OrchestrationPhase.PLANNING,
        OrchestrationPhase.PLANNING: OrchestrationPhase.EXECUTION,
        OrchestrationPhase.EXECUTION: OrchestrationPhase.VERIFICATION,
        OrchestrationPhase.VERIFICATION: OrchestrationPhase.COMPLETE,
        OrchestrationPhase.REMEDIATION: OrchestrationPhase.VERIFICATION,
    }

    def __init__(self):
        self.STATE_DIR.mkdir(parents=True, exist_ok=True)
        self.state = self._load_state()

    def _load_state(self) -> OrchestrationState:
        if self.STATE_FILE.exists():
            with open(self.STATE_FILE) as f:
                return OrchestrationState.from_dict(json.load(f))
        return OrchestrationState()

    def _save_state(self) -> None:
        self.state.lastUpdated = datetime.now().isoformat()
        with open(self.STATE_FILE, "w") as f:
            json.dump(self.state.to_dict(), f, indent=2)

    def check_blockers(self, l1_summaries: List[str]) -> List[str]:
        """Check L1 summaries for blocking conditions."""
        blockers = []
        blocking_keywords = ["BLOCK", "FAIL", "ERROR", "CRITICAL"]

        for summary in l1_summaries:
            for keyword in blocking_keywords:
                if keyword in summary.upper():
                    blockers.append(f"Found '{keyword}' in summary: {summary[:50]}...")
                    break

        return blockers

    def determine_decision(
        self,
        completed_phase: OrchestrationPhase,
        l1_summaries: List[str],
    ) -> tuple[Decision, Optional[OrchestrationPhase], str]:
        """Determine next action based on completed phase and summaries."""

        # Check iteration limit
        if self.state.iteration >= self.MAX_ITERATIONS:
            return Decision.TERMINATE, None, "Iteration limit reached"

        # Check for blockers
        blockers = self.check_blockers(l1_summaries)
        if blockers:
            self.state.blockers.extend(blockers)
            return Decision.TERMINATE, None, f"Blockers found: {blockers[0]}"

        # Get next phase from transition map
        next_phase = self.TRANSITIONS.get(completed_phase)

        if next_phase == OrchestrationPhase.COMPLETE:
            return Decision.TERMINATE, None, "All phases completed successfully"

        if next_phase:
            return Decision.CONTINUE, next_phase, f"Transitioning to {next_phase.value}"

        return Decision.TERMINATE, None, f"Unknown phase: {completed_phase.value}"

    def complete_phase(
        self,
        phase: str,
        l1_summaries: List[str],
    ) -> Dict[str, Any]:
        """Mark a phase as complete and determine next action."""

        completed_phase = OrchestrationPhase(phase)

        # Update state
        if phase not in self.state.completedPhases:
            self.state.completedPhases.append(phase)
        self.state.phase = completed_phase
        self.state.iteration += 1

        # Determine next action
        decision, next_phase, reason = self.determine_decision(
            completed_phase, l1_summaries
        )

        # Save state
        self._save_state()

        return {
            "decision": decision.value,
            "nextPhase": next_phase.value if next_phase else None,
            "reason": reason,
            "iteration": self.state.iteration,
            "completedPhases": self.state.completedPhases,
        }

    def reset(self) -> None:
        """Reset orchestration state."""
        self.state = OrchestrationState()
        self._save_state()

    def get_status(self) -> Dict[str, Any]:
        """Get current orchestration status."""
        return {
            "phase": self.state.phase.value,
            "iteration": self.state.iteration,
            "completedPhases": self.state.completedPhases,
            "pendingL2Refs": len(self.state.pendingL2Refs),
            "blockers": self.state.blockers,
            "lastUpdated": self.state.lastUpdated,
        }


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: orchestration_manager.py <command> [args]")
        print("Commands:")
        print("  complete <phase> [l1_summaries_json]  - Complete a phase")
        print("  status                                 - Get current status")
        print("  reset                                  - Reset state")
        sys.exit(1)

    command = sys.argv[1]
    manager = OrchestrationManager()

    if command == "complete":
        if len(sys.argv) < 3:
            print("Error: phase argument required")
            sys.exit(1)
        phase = sys.argv[2]
        l1_summaries = json.loads(sys.argv[3]) if len(sys.argv) > 3 else []
        result = manager.complete_phase(phase, l1_summaries)
        print(json.dumps(result, indent=2))

    elif command == "status":
        result = manager.get_status()
        print(json.dumps(result, indent=2))

    elif command == "reset":
        manager.reset()
        print("Orchestration state reset.")

    else:
        print(f"Unknown command: {command}")
        sys.exit(1)


if __name__ == "__main__":
    main()
