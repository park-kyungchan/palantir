"""
ODA V3.0 - Ontology MCP Server (Persistent Edition)
====================================================

Exposes Ontology inspection and action execution via MCP protocol
with full SQLite persistence for proposals.

Features:
- Real proposal persistence (SQLite)
- Full history tracking
- Pagination support for queries
- Statistics and metrics

Start with: python -m scripts.mcp.ontology_server
"""

from __future__ import annotations

import asyncio
import json
import logging
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

from lib.oda.ontology.actions import action_registry, ActionContext
from lib.oda.ontology.objects.proposal import (
    Proposal,
    ProposalPriority,
    ProposalStatus,
)
from lib.oda.ontology.storage.database import initialize_database
from lib.oda.ontology.storage.proposal_repository import (
    ProposalRepository,
    ProposalQuery,
    ProposalNotFoundError,
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize MCP Server
server = Server("oda-ontology")

# Global repository instance (initialized on first use)
_repo: Optional[ProposalRepository] = None


async def get_repo() -> ProposalRepository:
    """Get or create the repository instance."""
    global _repo
    if _repo is None:
        db = await initialize_database()
        _repo = ProposalRepository(db)
    return _repo


@server.list_tools()
async def list_tools() -> List[Tool]:
    """List available ODA tools."""
    return [
        # =====================================================================
        # ACTION TOOLS
        # =====================================================================
        Tool(
            name="list_actions",
            description="List all registered ActionTypes with their metadata",
            inputSchema={
                "type": "object",
                "properties": {
                    "include_hazardous_only": {
                        "type": "boolean",
                        "description": "Filter to only hazardous actions",
                        "default": False
                    }
                }
            }
        ),
        Tool(
            name="inspect_action",
            description="Get detailed information about a specific ActionType",
            inputSchema={
                "type": "object",
                "properties": {
                    "api_name": {
                        "type": "string",
                        "description": "The API name of the action to inspect"
                    }
                },
                "required": ["api_name"]
            }
        ),
        Tool(
            name="execute_action",
            description="Execute a non-hazardous ActionType with given parameters",
            inputSchema={
                "type": "object",
                "properties": {
                    "api_name": {
                        "type": "string",
                        "description": "The API name of the action"
                    },
                    "params": {
                        "type": "object",
                        "description": "Action parameters"
                    },
                    "actor_id": {
                        "type": "string",
                        "description": "ID of the actor executing the action",
                        "default": "gemini-agent"
                    }
                },
                "required": ["api_name", "params"]
            }
        ),
        
        # =====================================================================
        # PROPOSAL TOOLS (PERSISTENT)
        # =====================================================================
        Tool(
            name="create_proposal",
            description="Create and save a Proposal for a hazardous action (persisted to SQLite)",
            inputSchema={
                "type": "object",
                "properties": {
                    "action_type": {
                        "type": "string",
                        "description": "The action type API name"
                    },
                    "payload": {
                        "type": "object",
                        "description": "Action parameters"
                    },
                    "priority": {
                        "type": "string",
                        "enum": ["low", "medium", "high", "critical"],
                        "default": "medium"
                    },
                    "submit": {
                        "type": "boolean",
                        "description": "If true, submit for review immediately",
                        "default": True
                    }
                },
                "required": ["action_type", "payload"]
            }
        ),
        Tool(
            name="get_proposal",
            description="Get a proposal by ID with full history",
            inputSchema={
                "type": "object",
                "properties": {
                    "proposal_id": {
                        "type": "string",
                        "description": "The proposal ID"
                    }
                },
                "required": ["proposal_id"]
            }
        ),
        Tool(
            name="list_proposals",
            description="List proposals with optional filters and pagination",
            inputSchema={
                "type": "object",
                "properties": {
                    "status": {
                        "type": "string",
                        "enum": ["draft", "pending", "approved", "rejected", "executed", "cancelled"],
                        "description": "Filter by status"
                    },
                    "action_type": {
                        "type": "string",
                        "description": "Filter by action type"
                    },
                    "created_by": {
                        "type": "string",
                        "description": "Filter by creator"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Max results to return",
                        "default": 20
                    },
                    "offset": {
                        "type": "integer",
                        "description": "Offset for pagination",
                        "default": 0
                    }
                }
            }
        ),
        Tool(
            name="list_pending_proposals",
            description="List all proposals pending review (shortcut)",
            inputSchema={
                "type": "object",
                "properties": {
                    "limit": {
                        "type": "integer",
                        "default": 50
                    }
                }
            }
        ),
        Tool(
            name="approve_proposal",
            description="Approve a pending proposal",
            inputSchema={
                "type": "object",
                "properties": {
                    "proposal_id": {
                        "type": "string",
                        "description": "The proposal ID"
                    },
                    "reviewer_id": {
                        "type": "string",
                        "description": "ID of the reviewer",
                        "default": "gemini-agent"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Approval comment"
                    }
                },
                "required": ["proposal_id"]
            }
        ),
        Tool(
            name="reject_proposal",
            description="Reject a pending proposal",
            inputSchema={
                "type": "object",
                "properties": {
                    "proposal_id": {
                        "type": "string",
                        "description": "The proposal ID"
                    },
                    "reviewer_id": {
                        "type": "string",
                        "description": "ID of the reviewer",
                        "default": "gemini-agent"
                    },
                    "reason": {
                        "type": "string",
                        "description": "Rejection reason"
                    }
                },
                "required": ["proposal_id", "reason"]
            }
        ),
        Tool(
            name="execute_proposal",
            description="Execute an approved proposal",
            inputSchema={
                "type": "object",
                "properties": {
                    "proposal_id": {
                        "type": "string",
                        "description": "The proposal ID"
                    },
                    "executor_id": {
                        "type": "string",
                        "description": "ID of the executor",
                        "default": "gemini-agent"
                    }
                },
                "required": ["proposal_id"]
            }
        ),
        
        # =====================================================================
        # STATISTICS TOOLS
        # =====================================================================
        Tool(
            name="get_proposal_stats",
            description="Get proposal statistics by status",
            inputSchema={
                "type": "object",
                "properties": {}
            }
        ),
        Tool(
            name="get_proposal_history",
            description="Get full history for a proposal",
            inputSchema={
                "type": "object",
                "properties": {
                    "proposal_id": {
                        "type": "string",
                        "description": "The proposal ID"
                    }
                },
                "required": ["proposal_id"]
            }
        ),
    ]


@server.call_tool()
async def call_tool(name: str, arguments: Dict[str, Any]) -> List[TextContent]:
    """Handle tool calls."""
    repo = await get_repo()
    
    # =========================================================================
    # ACTION TOOLS
    # =========================================================================
    
    if name == "list_actions":
        include_hazardous_only = arguments.get("include_hazardous_only", False)

        if include_hazardous_only:
            actions = action_registry.get_hazardous_actions()
        else:
            actions = action_registry.list_actions()

        result = []
        for api_name in sorted(actions):
            action_cls = action_registry.get(api_name)
            if action_cls is None:
                # Skip actions that failed to load
                continue
            object_type_name = getattr(action_cls, "object_type", None)
            result.append({
                "api_name": api_name,
                "object_type": object_type_name.__name__ if object_type_name else "Unknown",
                "requires_proposal": getattr(action_cls, "requires_proposal", False),
            })

        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    
    elif name == "inspect_action":
        api_name = arguments["api_name"]
        action_cls = action_registry.get(api_name)
        
        if not action_cls:
            return [TextContent(type="text", text=json.dumps({
                "error": "ACTION_NOT_FOUND",
                "message": f"Action '{api_name}' not found"
            }))]
        
        criteria = []
        for c in getattr(action_cls, "submission_criteria", []):
            criteria.append(c.name if hasattr(c, "name") else str(c))
        
        side_effects = []
        for s in getattr(action_cls, "side_effects", []):
            side_effects.append(s.name if hasattr(s, "name") else str(s))
        
        result = {
            "api_name": api_name,
            "object_type": action_cls.object_type.__name__,
            "requires_proposal": getattr(action_cls, "requires_proposal", False),
            "submission_criteria": criteria,
            "side_effects": side_effects,
            "docstring": action_cls.__doc__,
        }
        
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    
    elif name == "execute_action":
        api_name = arguments["api_name"]
        params = arguments["params"]
        actor_id = arguments.get("actor_id", "gemini-agent")
        
        action_cls = action_registry.get(api_name)
        if not action_cls:
            return [TextContent(type="text", text=json.dumps({
                "error": "ACTION_NOT_FOUND",
                "message": f"Action '{api_name}' not found"
            }))]
        
        if getattr(action_cls, "requires_proposal", False):
            return [TextContent(type="text", text=json.dumps({
                "error": "PROPOSAL_REQUIRED",
                "message": f"Action '{api_name}' requires proposal approval. Use create_proposal instead.",
                "hint": "Call create_proposal with action_type='{api_name}'"
            }))]
        
        action = action_cls()
        context = ActionContext(actor_id=actor_id)
        result = await action.execute(params, context)
        
        return [TextContent(type="text", text=json.dumps(result.to_dict(), indent=2))]
    
    # =========================================================================
    # PROPOSAL TOOLS (PERSISTENT)
    # =========================================================================
    
    elif name == "create_proposal":
        proposal = Proposal(
            action_type=arguments["action_type"],
            payload=arguments["payload"],
            priority=ProposalPriority(arguments.get("priority", "medium")),
            created_by="gemini-agent",
        )
        
        if arguments.get("submit", True):
            proposal.submit()
        
        await repo.save(proposal, actor_id="gemini-agent")
        
        result = {
            "success": True,
            "proposal_id": proposal.id,
            "action_type": proposal.action_type,
            "status": proposal.status.value,
            "priority": proposal.priority.value,
            "message": f"Proposal created and {'submitted for review' if proposal.status == ProposalStatus.PENDING else 'saved as draft'}",
            "next_steps": [
                f"View: get_proposal('{proposal.id}')",
                f"Approve: approve_proposal('{proposal.id}')",
                f"Reject: reject_proposal('{proposal.id}', reason='...')",
            ] if proposal.status == ProposalStatus.PENDING else [
                f"Submit: Use list_proposals to find and submit"
            ]
        }
        
        return [TextContent(type="text", text=json.dumps(result, indent=2))]
    
    elif name == "get_proposal":
        proposal_id = arguments["proposal_id"]
        
        try:
            proposal, history = await repo.get_with_history(proposal_id)
            
            if proposal is None:
                return [TextContent(type="text", text=json.dumps({
                    "error": "PROPOSAL_NOT_FOUND",
                    "proposal_id": proposal_id
                }))]
            
            result = {
                "proposal": {
                    "id": proposal.id,
                    "action_type": proposal.action_type,
                    "payload": proposal.payload,
                    "status": proposal.status.value,
                    "priority": proposal.priority.value,
                    "created_by": proposal.created_by,
                    "created_at": proposal.created_at.isoformat(),
                    "reviewed_by": proposal.reviewed_by,
                    "reviewed_at": proposal.reviewed_at.isoformat() if proposal.reviewed_at else None,
                    "review_comment": proposal.review_comment,
                    "executed_at": proposal.executed_at.isoformat() if proposal.executed_at else None,
                    "version": proposal.version,
                },
                "history": [
                    {
                        "action": h.action,
                        "actor_id": h.actor_id,
                        "timestamp": h.timestamp.isoformat(),
                        "previous_status": h.previous_status,
                        "new_status": h.new_status,
                        "comment": h.comment,
                    }
                    for h in history
                ]
            }
            
            return [TextContent(type="text", text=json.dumps(result, indent=2))]
        
        except Exception as e:
            return [TextContent(type="text", text=json.dumps({
                "error": str(type(e).__name__),
                "message": str(e)
            }))]
    
    elif name == "list_proposals":
        query = ProposalQuery(
            status=ProposalStatus(arguments["status"]) if arguments.get("status") else None,
            action_type=arguments.get("action_type"),
            created_by=arguments.get("created_by"),
            limit=arguments.get("limit", 20),
            offset=arguments.get("offset", 0),
        )
        
        result = await repo.query(query)
        
        return [TextContent(type="text", text=json.dumps({
            "proposals": [
                {
                    "id": p.id,
                    "action_type": p.action_type,
                    "status": p.status.value,
                    "priority": p.priority.value,
                    "created_by": p.created_by,
                    "created_at": p.created_at.isoformat(),
                }
                for p in result.items
            ],
            "pagination": {
                "total": result.total,
                "limit": result.limit,
                "offset": result.offset,
                "has_more": result.has_more,
            }
        }, indent=2))]
    
    elif name == "list_pending_proposals":
        limit = arguments.get("limit", 50)
        pending = await repo.find_pending(limit=limit)
        
        return [TextContent(type="text", text=json.dumps({
            "count": len(pending),
            "proposals": [
                {
                    "id": p.id,
                    "action_type": p.action_type,
                    "priority": p.priority.value,
                    "created_by": p.created_by,
                    "created_at": p.created_at.isoformat(),
                    "payload_preview": str(p.payload)[:100] + "..." if len(str(p.payload)) > 100 else str(p.payload),
                }
                for p in pending
            ]
        }, indent=2))]
    
    elif name == "approve_proposal":
        proposal_id = arguments["proposal_id"]
        reviewer_id = arguments.get("reviewer_id", "gemini-agent")
        comment = arguments.get("comment")
        
        try:
            proposal = await repo.approve(proposal_id, reviewer_id, comment)
            
            return [TextContent(type="text", text=json.dumps({
                "success": True,
                "proposal_id": proposal.id,
                "status": proposal.status.value,
                "reviewed_by": proposal.reviewed_by,
                "message": "Proposal approved successfully",
                "next_step": f"Execute: execute_proposal('{proposal.id}')"
            }, indent=2))]
        
        except ProposalNotFoundError:
            return [TextContent(type="text", text=json.dumps({
                "error": "PROPOSAL_NOT_FOUND",
                "proposal_id": proposal_id
            }))]
        except Exception as e:
            return [TextContent(type="text", text=json.dumps({
                "error": str(type(e).__name__),
                "message": str(e)
            }))]
    
    elif name == "reject_proposal":
        proposal_id = arguments["proposal_id"]
        reviewer_id = arguments.get("reviewer_id", "gemini-agent")
        reason = arguments["reason"]
        
        try:
            proposal = await repo.reject(proposal_id, reviewer_id, reason)
            
            return [TextContent(type="text", text=json.dumps({
                "success": True,
                "proposal_id": proposal.id,
                "status": proposal.status.value,
                "reviewed_by": proposal.reviewed_by,
                "reason": reason,
                "message": "Proposal rejected"
            }, indent=2))]
        
        except ProposalNotFoundError:
            return [TextContent(type="text", text=json.dumps({
                "error": "PROPOSAL_NOT_FOUND",
                "proposal_id": proposal_id
            }))]
        except Exception as e:
            return [TextContent(type="text", text=json.dumps({
                "error": str(type(e).__name__),
                "message": str(e)
            }))]
    
    elif name == "execute_proposal":
        proposal_id = arguments["proposal_id"]
        executor_id = arguments.get("executor_id", "gemini-agent")

        try:
            # Get the proposal
            proposal = await repo.find_by_id(proposal_id)
            if proposal is None:
                return [TextContent(type="text", text=json.dumps({
                    "error": "PROPOSAL_NOT_FOUND",
                    "proposal_id": proposal_id
                }))]

            # Verify proposal is approved (ODA-RISK-007: state validation)
            if proposal.status != ProposalStatus.APPROVED:
                return [TextContent(type="text", text=json.dumps({
                    "error": "INVALID_PROPOSAL_STATUS",
                    "proposal_id": proposal_id,
                    "current_status": proposal.status.value,
                    "required_status": "approved",
                    "message": f"Proposal must be approved before execution. Current status: {proposal.status.value}"
                }))]

            # Execute the underlying action
            action_cls = action_registry.get(proposal.action_type)
            if action_cls is None:
                return [TextContent(type="text", text=json.dumps({
                    "error": "ACTION_NOT_FOUND",
                    "action_type": proposal.action_type
                }))]

            action = action_cls()
            context = ActionContext(actor_id=executor_id)

            # ODA-RISK-007: Re-validate submission criteria before execution
            # This ensures criteria haven't changed since approval
            validation_errors = action.validate(proposal.payload, context)
            if validation_errors:
                return [TextContent(type="text", text=json.dumps({
                    "error": "REVALIDATION_FAILED",
                    "proposal_id": proposal_id,
                    "action_type": proposal.action_type,
                    "validation_errors": validation_errors,
                    "message": "Proposal payload no longer meets submission criteria. Action definition may have changed since approval."
                }))]

            action_result = await action.execute(proposal.payload, context)
            
            # Mark proposal as executed
            await repo.execute(
                proposal_id,
                executor_id=executor_id,
                result=action_result.to_dict()
            )
            
            return [TextContent(type="text", text=json.dumps({
                "success": True,
                "proposal_id": proposal_id,
                "action_type": proposal.action_type,
                "status": "executed",
                "action_result": action_result.to_dict(),
                "message": "Proposal executed successfully"
            }, indent=2))]
        
        except Exception as e:
            return [TextContent(type="text", text=json.dumps({
                "error": str(type(e).__name__),
                "message": str(e)
            }))]
    
    # =========================================================================
    # STATISTICS TOOLS
    # =========================================================================
    
    elif name == "get_proposal_stats":
        counts = await repo.count_by_status()
        total = sum(counts.values())
        
        return [TextContent(type="text", text=json.dumps({
            "total_proposals": total,
            "by_status": counts,
            "pending_review": counts.get("pending", 0),
            "ready_to_execute": counts.get("approved", 0),
        }, indent=2))]
    
    elif name == "get_proposal_history":
        proposal_id = arguments["proposal_id"]
        history = await repo.get_history(proposal_id)
        
        return [TextContent(type="text", text=json.dumps({
            "proposal_id": proposal_id,
            "history_count": len(history),
            "entries": [
                {
                    "action": h.action,
                    "actor_id": h.actor_id,
                    "timestamp": h.timestamp.isoformat(),
                    "previous_status": h.previous_status,
                    "new_status": h.new_status,
                    "comment": h.comment,
                }
                for h in history
            ]
        }, indent=2))]
    
    return [TextContent(type="text", text=json.dumps({
        "error": "UNKNOWN_TOOL",
        "tool": name
    }))]


async def main():
    """Run the MCP server."""
    # Pre-initialize the database
    await get_repo()
    logger.info("ODA Ontology MCP Server started with persistent storage")
    
    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options()
        )


if __name__ == "__main__":
    asyncio.run(main())
