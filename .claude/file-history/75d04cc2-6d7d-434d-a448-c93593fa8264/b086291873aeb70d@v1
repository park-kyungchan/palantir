"""
Orion ODA v3.0 - Semantic Action System
Palantir AIP/Foundry Compliant Action Definitions

This module implements the Action layer of the Ontology-Driven Architecture.
Actions are the ONLY way to mutate the Ontology, ensuring:
- All changes are validated (SubmissionCriteria)
- All changes are audited (EditOperations)
- Side effects are decoupled (post-commit execution)

Design Principles:
1. Actions are declarative (class-based, not instance-based)
2. Validation before mutation (fail-fast)
3. Side effects after commit (eventual consistency)
4. Full audit trail (who, what, when)
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import (
    Any,
    Callable,
    ClassVar,
    Dict,
    Generic,
    List,
    Optional,
    Protocol,
    Type,
    TypeVar,
    Union,
    runtime_checkable,
)

from pydantic import BaseModel, Field

from lib.oda.ontology.ontology_types import OntologyObject, utc_now

logger = logging.getLogger(__name__)

# ConcurrencyError is imported lazily in execute() to avoid circular imports


# =============================================================================
# EDIT OPERATIONS
# =============================================================================

class EditType(str, Enum):
    """Types of edit operations on the Ontology."""
    CREATE = "create"
    MODIFY = "modify"
    DELETE = "delete"
    LINK = "link"
    UNLINK = "unlink"


@dataclass
class EditOperation:
    """
    Represents a single edit operation on the Ontology.
    
    Used for:
    - Audit logging
    - Transaction rollback
    - Change data capture
    """
    edit_type: EditType
    object_type: str
    object_id: str
    changes: Dict[str, Any] = field(default_factory=dict)
    # Using default_factory for timestamp to ensure it's generated at instantiation
    timestamp: datetime = field(default_factory=utc_now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "edit_type": self.edit_type.value,
            "object_type": self.object_type,
            "object_id": self.object_id,
            "changes": self.changes,
            "timestamp": self.timestamp.isoformat(),
        }



# =============================================================================
# SUBMISSION CRITERIA
# =============================================================================

class ValidationError(Exception):
    """Raised when SubmissionCriteria validation fails."""
    
    def __init__(self, criterion: str, message: str, details: Dict[str, Any] = None):
        self.criterion = criterion
        self.message = message
        self.details = details or {}
        super().__init__(f"[{criterion}] {message}")


@runtime_checkable
class SubmissionCriterion(Protocol):
    """
    Protocol for SubmissionCriteria validators.
    
    Implement this protocol to create custom validation rules.
    Each criterion is evaluated before action execution.
    """
    
    @property
    def name(self) -> str:
        """Human-readable name of this criterion."""
        ...
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        """
        Validate the action parameters.
        
        Args:
            params: Action parameters
            context: Execution context (user, timestamp, etc.)
        
        Returns:
            True if validation passes
        
        Raises:
            ValidationError: If validation fails
        """
        ...


class RequiredField(SubmissionCriterion):
    """Validates that a required field is present and non-empty."""
    
    def __init__(self, field_name: str):
        self.field_name = field_name
    
    @property
    def name(self) -> str:
        return f"RequiredField({self.field_name})"
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        value = params.get(self.field_name)
        if value is None or (isinstance(value, str) and not value.strip()):
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' is required",
                details={"field": self.field_name, "value": value}
            )
        return True


class AllowedValues(SubmissionCriterion):
    """Validates that a field value is in an allowed set."""
    
    def __init__(self, field_name: str, allowed: List[Any]):
        self.field_name = field_name
        self.allowed = allowed
    
    @property
    def name(self) -> str:
        return f"AllowedValues({self.field_name})"
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        value = params.get(self.field_name)
        if value is not None and value not in self.allowed:
            raise ValidationError(
                criterion=self.name,
                message=f"Value '{value}' not in allowed values: {self.allowed}",
                details={"field": self.field_name, "value": value, "allowed": self.allowed}
            )
        return True


class MaxLength(SubmissionCriterion):
    """Validates that a string field doesn't exceed max length."""
    
    def __init__(self, field_name: str, max_length: int):
        self.field_name = field_name
        self.max_length = max_length
    
    @property
    def name(self) -> str:
        return f"MaxLength({self.field_name}, {self.max_length})"
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        value = params.get(self.field_name, "")
        if isinstance(value, str) and len(value) > self.max_length:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' exceeds max length {self.max_length}",
                details={"field": self.field_name, "length": len(value), "max": self.max_length}
            )
        return True


class CustomValidator(SubmissionCriterion):
    """Wraps a custom validation function."""
    
    def __init__(
        self,
        name: str,
        validator_fn: Callable[[Dict[str, Any], "ActionContext"], bool],
        error_message: str = "Custom validation failed"
    ):
        self._name = name
        self.validator_fn = validator_fn
        self.error_message = error_message
    
    @property
    def name(self) -> str:
        return self._name
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        if not self.validator_fn(params, context):
            raise ValidationError(
                criterion=self.name,
                message=self.error_message,
                details={"params": params}
            )
        return True


class ArraySizeValidator(SubmissionCriterion):
    """
    Validates array/list field size constraints.
    
    Aligns with Palantir Foundry's 'arraySize' constraint type:
    {"type": "arraySize", "gte": 2, "lte": 4}
    """
    
    def __init__(self, field_name: str, *, min_size: int = None, max_size: int = None):
        self.field_name = field_name
        self.min_size = min_size
        self.max_size = max_size
    
    @property
    def name(self) -> str:
        constraints = []
        if self.min_size is not None:
            constraints.append(f"gte={self.min_size}")
        if self.max_size is not None:
            constraints.append(f"lte={self.max_size}")
        return f"ArraySize({self.field_name}, {', '.join(constraints)})"
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        value = params.get(self.field_name, [])
        
        if value is None:
            value = []
        
        if not isinstance(value, (list, tuple)):
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be an array",
                details={"field": self.field_name, "value_type": type(value).__name__}
            )
        
        if self.min_size is not None and len(value) < self.min_size:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must have at least {self.min_size} items (got {len(value)})",
                details={"field": self.field_name, "size": len(value), "min_size": self.min_size}
            )
        
        if self.max_size is not None and len(value) > self.max_size:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must have at most {self.max_size} items (got {len(value)})",
                details={"field": self.field_name, "size": len(value), "max_size": self.max_size}
            )
        
        return True


class StringLengthValidator(SubmissionCriterion):
    """
    Validates string length with min/max constraints.
    
    Aligns with Palantir Foundry's 'STRING_LENGTH' constraint:
    {"type": "STRING_LENGTH", "minLength": 10, "maxLength": 500}
    
    Superset of MaxLength - supports both min and max.
    """
    
    def __init__(self, field_name: str, *, min_length: int = None, max_length: int = None):
        self.field_name = field_name
        self.min_length = min_length
        self.max_length = max_length
    
    @property
    def name(self) -> str:
        constraints = []
        if self.min_length is not None:
            constraints.append(f"min={self.min_length}")
        if self.max_length is not None:
            constraints.append(f"max={self.max_length}")
        return f"StringLength({self.field_name}, {', '.join(constraints)})"
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        value = params.get(self.field_name, "")
        
        if value is None:
            value = ""
        
        if not isinstance(value, str):
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be a string",
                details={"field": self.field_name, "value_type": type(value).__name__}
            )
        
        if self.min_length is not None and len(value) < self.min_length:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be at least {self.min_length} characters (got {len(value)})",
                details={"field": self.field_name, "length": len(value), "min_length": self.min_length}
            )
        
        if self.max_length is not None and len(value) > self.max_length:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be at most {self.max_length} characters (got {len(value)})",
                details={"field": self.field_name, "length": len(value), "max_length": self.max_length}
            )
        
        return True


class RangeValidator(SubmissionCriterion):
    """
    Validates numeric value is within specified range.
    
    Aligns with Palantir Foundry's Range constraint:
    - Valid for: Integer, Float, Decimal
    - Both min_value and max_value are inclusive
    
    Usage:
        RangeValidator("price", min_value=0, max_value=10000)
        RangeValidator("age", min_value=0)  # No upper bound
    """
    
    def __init__(self, field_name: str, *, min_value: float = None, max_value: float = None):
        self.field_name = field_name
        self.min_value = min_value
        self.max_value = max_value
    
    @property
    def name(self) -> str:
        constraints = []
        if self.min_value is not None:
            constraints.append(f"min={self.min_value}")
        if self.max_value is not None:
            constraints.append(f"max={self.max_value}")
        return f"Range({self.field_name}, {', '.join(constraints)})"
    
    def validate(self, params: Dict[str, Any], context: "ActionContext") -> bool:
        if self.field_name not in params:
            return True  # Not our job to check required
        
        value = params[self.field_name]
        
        if not isinstance(value, (int, float)):
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be numeric, got {type(value).__name__}",
                details={"field": self.field_name, "value_type": type(value).__name__}
            )
        
        if self.min_value is not None and value < self.min_value:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be >= {self.min_value}, got {value}",
                details={"field": self.field_name, "value": value, "min_value": self.min_value}
            )
        
        if self.max_value is not None and value > self.max_value:
            raise ValidationError(
                criterion=self.name,
                message=f"Field '{self.field_name}' must be <= {self.max_value}, got {value}",
                details={"field": self.field_name, "value": value, "max_value": self.max_value}
            )
        
        return True



# =============================================================================
# SIDE EFFECTS
# =============================================================================

from .side_effects import (
    SideEffect,
    LogSideEffect,
    WebhookSideEffect,
    SlackNotification,
    EventBusSideEffect
)

# =============================================================================
# ACTION CONTEXT & RESULT
# =============================================================================

@dataclass
class ActionContext:
    """
    Execution context for an action.
    
    Contains information about WHO is executing the action,
    WHEN it's being executed, and any relevant metadata.
    """
    actor_id: str  # User or Agent ID
    timestamp: datetime = field(default_factory=utc_now)
    correlation_id: Optional[str] = None  # For distributed tracing
    session: Optional[Any] = None  # Explicit AsyncSession injection
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @classmethod
    def system(cls) -> "ActionContext":
        """Create a system-level context (for automated actions)."""
        return cls(actor_id="system", metadata={"automated": True})


@dataclass
class ActionResult:
    """
    Result of an action execution.
    
    Contains success/failure status, created/modified objects,
    and any error information.
    
    Attributes:
        action_type: The api_name of the executed action.
        success: True if action completed without errors.
        data: The primary return value of the action. Convention:
              - CREATE actions: The newly created OntologyObject
              - READ/QUERY actions: The queried object(s)  
              - UPDATE actions: The modified OntologyObject
              - DELETE actions: None (use deleted_ids instead)
              - validate_only=True: None (just validation, no object)
        message: Human-readable status message (e.g., "Validation passed").
        edits: List of EditOperations for the audit trail.
        created_ids: IDs of objects created by this action.
        modified_ids: IDs of objects modified by this action.
        deleted_ids: IDs of objects deleted by this action.
        error: Error message if success=False.
        error_details: Additional error context (e.g., validation_errors).
        timestamp: When the action completed (UTC).
    """
    action_type: str
    success: bool
    data: Any = None
    message: Optional[str] = None
    edits: List[EditOperation] = field(default_factory=list)
    created_ids: List[str] = field(default_factory=list)
    modified_ids: List[str] = field(default_factory=list)
    deleted_ids: List[str] = field(default_factory=list)
    # GAP-01: Palantir modifiedEntities alignment
    affected_types: Dict[str, Dict[str, bool]] = field(default_factory=dict)
    error: Optional[str] = None
    error_details: Optional[Dict[str, Any]] = None
    timestamp: datetime = field(default_factory=utc_now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "action_type": self.action_type,
            "success": self.success,
            "data": self.data,
            "edits": [e.to_dict() for e in self.edits],
            "created_ids": self.created_ids,
            "modified_ids": self.modified_ids,
            "deleted_ids": self.deleted_ids,
            "affected_types": self.affected_types,  # GAP-01: Palantir alignment
            "error": self.error,
            "error_details": self.error_details,
            "timestamp": self.timestamp.isoformat(),
        }


# =============================================================================
# BASE ACTION TYPE
# =============================================================================

T = TypeVar("T", bound=OntologyObject)


class ActionType(ABC, Generic[T]):
    """
    Base class for all ActionTypes.
    
    To define a new action, subclass ActionType and implement:
    1. Class attributes: api_name, object_type, submission_criteria, side_effects
    2. apply_edits() method: the actual mutation logic
    """
    
    # Class attributes to be overridden by subclasses
    api_name: ClassVar[str]
    object_type: ClassVar[Type[T]]
    submission_criteria: ClassVar[List[SubmissionCriterion]] = []
    side_effects: ClassVar[List[SideEffect]] = []
    requires_proposal: ClassVar[bool] = False  # True for hazardous actions
    
    def __init__(self):
        """Initialize the action. Override for custom initialization."""
        pass
    
    def validate(self, params: Dict[str, Any], context: ActionContext) -> List[str]:
        """
        Run all submission criteria validators.
        """
        errors = []
        for criterion in self.submission_criteria:
            try:
                criterion.validate(params, context)
            except ValidationError as e:
                errors.append(str(e))
        return errors
    
    @abstractmethod
    async def apply_edits(
        self,
        params: Dict[str, Any],
        context: ActionContext
    ) -> tuple[Optional[T], List[EditOperation]]:
        """
        Apply the action's edits to the Ontology.
        """
        ...
    
    @classmethod
    def get_parameter_schema(cls) -> Dict[str, Any]:
        """
        Export parameter schema for API documentation / UI generation.
        """
        required_fields = []
        properties = {}

        for criterion in cls.submission_criteria:
            if isinstance(criterion, RequiredField):
                required_fields.append(criterion.field_name)
                properties[criterion.field_name] = {"type": "string"}
            elif isinstance(criterion, MaxLength):
                if criterion.field_name not in properties:
                    properties[criterion.field_name] = {}
                properties[criterion.field_name]["maxLength"] = criterion.max_length
            elif isinstance(criterion, AllowedValues):
                if criterion.field_name not in properties:
                    properties[criterion.field_name] = {}
                properties[criterion.field_name]["enum"] = criterion.allowed

        return {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "title": cls.api_name,
            "type": "object",
            "required": required_fields,
            "properties": properties,
            "additionalProperties": False,
            "description": cls.__doc__ or "",
        }
    
    async def execute(
        self,
        params: Dict[str, Any],
        context: ActionContext,
        validate_only: bool = False,  # Palantir OSDK alignment: $validateOnly
        return_edits: bool = True     # GAP-02: Palantir OSDK alignment: $returnEdits
    ) -> ActionResult:
        """
        Execute the action with full validation, retry on concurrency, and side effects.
        
        Args:
            params: Action parameters
            context: Execution context (actor, timestamp, etc.)
            validate_only: If True, only validate without applying changes (dry-run mode).
                          Aligns with Palantir OSDK's $validateOnly option.
            return_edits: If True, include EditOperations in result (default True).
                         Aligns with Palantir OSDK's $returnEdits option.
        
        Returns:
            ActionResult with success/error status and affected objects
        """
        import asyncio

        MAX_RETRIES = 3
        BACKOFF_BASE = 0.5  # seconds

        # 1. Validation
        errors = self.validate(params, context)
        if errors:
            return ActionResult(
                action_type=self.api_name,
                success=False,
                error="Submission criteria failed",
                error_details={"validation_errors": errors},
            )
        
        # 2. Validate-Only Mode (Palantir $validateOnly alignment)
        if validate_only:
            return ActionResult(
                action_type=self.api_name,
                success=True,
                message="Validation passed (dry-run mode - no changes applied)",
                data=None,
                edits=[],
            )
        
        
        # 2. Apply Edits with Retry
        last_error = None
        result = None

        for attempt in range(MAX_RETRIES):
            try:
                obj, edits = await self.apply_edits(params, context)
                
                # Determine affected object type
                obj_type_name = obj.__class__.__name__ if obj else self.object_type.__name__
                has_create = any(e.edit_type == EditType.CREATE for e in edits)
                has_modify = any(e.edit_type == EditType.MODIFY for e in edits)
                
                result = ActionResult(
                    action_type=self.api_name,
                    success=True,
                    data=obj,
                    edits=edits if return_edits else [],  # GAP-02: conditional
                    created_ids=[obj.id] if obj and has_create else [],
                    modified_ids=[obj.id] if obj and has_modify else [],
                    # GAP-01: Palantir modifiedEntities alignment
                    affected_types={obj_type_name: {"created": has_create, "modified": has_modify}} if obj else {},
                )
                break  # Success, exit retry loop
                
            except Exception as e:
                # Lazy import to avoid circular dependency
                from lib.oda.ontology.storage.exceptions import ConcurrencyError
                if isinstance(e, ConcurrencyError):
                    last_error = e
                    if attempt < MAX_RETRIES - 1:
                        wait_time = BACKOFF_BASE * (2 ** attempt)
                        logger.warning(f"ConcurrencyError on {self.api_name}, retry {attempt+1}/{MAX_RETRIES} in {wait_time}s")
                        await asyncio.sleep(wait_time)
                        continue  # Continue to next retry attempt
                    else:
                        logger.error(f"All retries exhausted for {self.api_name}")
                        return ActionResult(
                            action_type=self.api_name,
                            success=False,
                            error=f"Concurrency conflict after {MAX_RETRIES} retries",
                            error_details={"exception": str(e)},
                        )
                # Not a ConcurrencyError - handle as regular exception
                logger.exception(f"Action {self.api_name} failed")
                return ActionResult(
                    action_type=self.api_name,
                    success=False,
                    error=str(e),
                    error_details={"exception_type": type(e).__name__},
                )
        
        # 3. Side Effects with Retry (DIA v2.1 C4 compliant)
        if result and result.success:
            for effect in self.side_effects:
                await self._execute_side_effect_with_retry(effect, result, context)
        
        return result

    async def _execute_side_effect_with_retry(
        self,
        effect: "SideEffect",
        result: ActionResult,
        context: ActionContext,
        max_attempts: int = 3
    ) -> None:
        """
        Execute side effect with exponential backoff retry.
        
        Args:
            effect: The SideEffect instance to execute
            result: ActionResult from the main action
            context: Execution context
            max_attempts: Maximum retry attempts (default 3)
            
        Note: Errors are logged but not raised (fire-and-forget pattern preserved)
        DIA v2.1: C4 compliant - resilient side effect execution
        """
        import asyncio
        for attempt in range(max_attempts):
            try:
                await effect.execute(result, context)
                logger.debug(f"Side effect {effect.name} succeeded on attempt {attempt + 1}")
                return
            except Exception as e:
                if attempt == max_attempts - 1:
                    logger.error(
                        f"Side effect {effect.name} failed after {max_attempts} attempts: {e}"
                    )
                else:
                    wait_time = 0.5 * (2 ** attempt)  # 0.5s, 1s, 2s
                    logger.warning(
                        f"Side effect {effect.name} attempt {attempt + 1} failed, "
                        f"retrying in {wait_time}s: {e}"
                    )
                    await asyncio.sleep(wait_time)
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(api_name='{self.api_name}')"


# =============================================================================
# ACTION REGISTRY & GOVERNANCE
# =============================================================================

@dataclass
class ActionMetadata:
    """Metadata for governance and execution policy."""
    requires_proposal: bool = False
    is_dangerous: bool = False
    description: str = ""

class ActionRegistry:
    """
    Registry for ActionType discovery and lookup with Metadata.
    
    Args:
        strict: If True, raise ValueError on duplicate registrations or invalid api_names
    """
    
    def __init__(self, strict: bool = False):
        # Mapping: api_name -> (ActionClass, Metadata)
        self._actions: Dict[str, tuple[Type[ActionType], ActionMetadata]] = {}
        self._strict = strict
    
    def register(self, action_class: Type[ActionType], **metadata_overrides) -> None:
        """Register an ActionType class with extracted or overridden metadata."""
        if not hasattr(action_class, "api_name"):
            raise ValueError(f"{action_class.__name__} missing api_name")
        
        api_name = action_class.api_name
        
        # GAP-02-C: Validate api_name format (namespace.action pattern recommended)
        import re
        API_NAME_PATTERN = re.compile(r'^[a-z][a-z0-9_]*(\.[a-z][a-z0-9_]*)*$')
        if not API_NAME_PATTERN.match(api_name):
            msg = (
                f"ActionType '{action_class.__name__}' has non-standard api_name: '{api_name}'. "
                f"Recommended format: 'namespace.action_name' (lowercase, dots allowed)"
            )
            if self._strict:
                raise ValueError(msg)
            logger.warning(msg)
        
        requires_proposal = metadata_overrides.get(
            "requires_proposal", 
            getattr(action_class, "requires_proposal", False)
        )
        is_dangerous = metadata_overrides.get("is_dangerous", False) 
        
        metadata = ActionMetadata(
            requires_proposal=requires_proposal,
            is_dangerous=is_dangerous,
            description=action_class.__doc__ or ""
        )

        # GAP-02-B: Enhanced duplicate detection with class info
        if api_name in self._actions:
            existing_cls, _ = self._actions[api_name]
            if existing_cls != action_class:
                msg = (
                    f"ActionType '{api_name}' registered twice with DIFFERENT classes! "
                    f"Existing: {existing_cls.__module__}.{existing_cls.__name__}, "
                    f"New: {action_class.__module__}.{action_class.__name__}."
                )
                if self._strict:
                    raise ValueError(msg)
                logger.warning(f"{msg} Using new definition.")
            else:
                logger.debug(f"ActionType '{api_name}' re-registered (same class)")
        
        self._actions[api_name] = (action_class, metadata)
        logger.debug(f"Registered action: {api_name} [Proposal:{requires_proposal}]")
    
    def get(self, api_name: str) -> Optional[Type[ActionType]]:
        """Get an ActionType class by api_name."""
        entry = self._actions.get(api_name)
        return entry[0] if entry else None

    def get_metadata(self, api_name: str) -> Optional[ActionMetadata]:
        """Get governance metadata for an action."""
        entry = self._actions.get(api_name)
        return entry[1] if entry else None
    
    def list_actions(self) -> List[str]:
        """List all registered action api_names."""
        return list(self._actions.keys())

    def get_hazardous_actions(self) -> List[str]:
        """Return list of actions that require a proposal."""
        return [
            name for name, (cls, meta) in self._actions.items()
            if meta.requires_proposal
        ]


# Global registry instance
action_registry = ActionRegistry()


def register_action(cls: Type[ActionType] = None, *, requires_proposal: bool = None):
    """
    Decorator to register an ActionType with the global registry.
    
    V3.1: Now includes quality gate validation.
    """
    def _register(action_cls):
        # V3.1: Quality Gate Enforcement
        try:
            from lib.oda.ontology.governance import (
                CodeQualityGate,
                QualityGateEnforcement,
                GovernanceError,
            )
            
            if QualityGateEnforcement.is_enabled():
                report = CodeQualityGate.validate_action_class(
                    action_cls,
                    strict=QualityGateEnforcement.should_block()
                )
                
                if report.violations:
                    api_name = getattr(action_cls, 'api_name', action_cls.__name__)
                    for v in report.violations:
                        logger.warning(f"[QualityGate] {api_name}: {v}")
                    
                    if QualityGateEnforcement.should_block() and report.has_errors:
                        raise GovernanceError(report)
        except ImportError:
            # Governance module not available, skip validation
            pass
        
        overrides = {}
        if requires_proposal is not None:
            overrides["requires_proposal"] = requires_proposal
            
        action_registry.register(action_cls, **overrides)
        return action_cls

    if cls is None:
        return _register
    return _register(cls)

@dataclass
class PolicyResult:
    """
    Result of a governance policy check.
    Aligns with IndyDevDan's PreToolUse hook pattern.
    """
    decision: str  # "ALLOW_IMMEDIATE" | "REQUIRE_PROPOSAL" | "BLOCK" | "DENY"
    reason: str = ""  # Explanation for the decision (shown to Claude/user)
    
    def is_allowed(self) -> bool:
        return self.decision == "ALLOW_IMMEDIATE"
    
    def is_blocked(self) -> bool:
        return self.decision in ("BLOCK", "DENY")


import os

# Environment variable for fail-closed mode (ODA-RISK-008)
GOVERNANCE_FAIL_CLOSED = os.getenv("ODA_GOVERNANCE_FAIL_CLOSED", "true").lower() == "true"


class GovernanceEngine:
    """
    Enforces policies based on ActionMetadata.
    Enhanced with PolicyResult for IndyDevDan PreToolUse pattern.

    Security (ODA-RISK-008): Supports fail-closed mode where unknown actions
    are blocked by default. Controlled by ODA_GOVERNANCE_FAIL_CLOSED env var.

    Environment Variables:
        ODA_GOVERNANCE_FAIL_CLOSED: Set to "false" to allow unknown actions (default: true)
    """
    def __init__(self, registry: ActionRegistry, fail_closed: bool = None):
        self.registry = registry
        # Use parameter if provided, otherwise use environment variable
        self._fail_closed = fail_closed if fail_closed is not None else GOVERNANCE_FAIL_CLOSED
    
    def check_execution_policy(self, action_name: str, params: Dict[str, Any] = None) -> PolicyResult:
        """
        Determines execution policy with reason feedback.
        
        Args:
            action_name: API name of the action
            params: Optional parameters for context-aware blocking
            
        Returns:
            PolicyResult with decision and reason
        """
        meta = self.registry.get_metadata(action_name)
        if not meta:
            return PolicyResult(
                decision="DENY",
                reason=f"Action '{action_name}' not found in registry"
            )
        
        # P1.1: Context-aware blocking (IndyDevDan PreToolUse pattern)
        if params:
            block_reason = self._check_dangerous_params(action_name, params)
            if block_reason:
                return PolicyResult(decision="BLOCK", reason=block_reason)
        
        if meta.requires_proposal:
            return PolicyResult(
                decision="REQUIRE_PROPOSAL",
                reason=f"Action '{action_name}' requires governance approval"
            )
        
        return PolicyResult(decision="ALLOW_IMMEDIATE", reason="")
    
    def _check_dangerous_params(self, action_name: str, params: Dict[str, Any]) -> str:
        """
        Check for dangerous parameter patterns (IndyDevDan security pattern).
        Returns block reason if dangerous, empty string if safe.
        """
        # Example dangerous patterns (extendable)
        dangerous_patterns = [
            ("rm -rf", "Dangerous recursive deletion detected"),
            ("sudo rm", "Sudo deletion not allowed"),
            ("chmod 777", "Insecure permissions not allowed"),
        ]
        
        # Stringify params for pattern matching
        params_str = str(params).lower()
        
        for pattern, reason in dangerous_patterns:
            if pattern in params_str:
                return reason
        
        return ""
    
    def check_protocol_compliance(self, action_name: str) -> PolicyResult:
        """
        Check if action has completed required 3-Stage Protocol.
        
        V3.1: Integrates with lib/oda/ontology/protocols framework.
        
        Returns:
            PolicyResult with ALLOW_IMMEDIATE, REQUIRE_PROTOCOL, or BLOCK decision
        """
        try:
            from lib.oda.ontology.protocols.decorators import ProtocolRegistry
            
            is_compliant, reason = ProtocolRegistry.is_compliant(action_name)
            
            if not is_compliant:
                return PolicyResult(
                    decision="BLOCK",
                    reason=reason or f"Protocol compliance check failed for '{action_name}'"
                )
            
            if reason:  # Warning case
                return PolicyResult(
                    decision="ALLOW_IMMEDIATE",
                    reason=reason
                )
            
            return PolicyResult(decision="ALLOW_IMMEDIATE", reason="")
            
        except ImportError:
            # Protocol framework not available, allow execution
            return PolicyResult(decision="ALLOW_IMMEDIATE", reason="")

# Exports from submodules
# Expected actions for startup validation
_EXPECTED_ACTIONS = [
    "GeneratePlanAction", "RouteTaskAction", "ProcessLLMPromptAction",
    "SaveInsightAction", "SavePatternAction",
    "SaveLearnerStateAction",
    "ExecuteLogicAction"
]

try:
    from .llm_actions import GeneratePlanAction, RouteTaskAction, ProcessLLMPromptAction
    from .memory_actions import SaveInsightAction, SavePatternAction
    from .learning_actions import SaveLearnerStateAction
    from .logic_actions import ExecuteLogicAction
except ImportError as e:
    # I-04 Fix: Changed from debug to warning to surface import failures
    logger.warning(f"Action submodule import failed: {e}")
    # Continue - don't fail hard during import, but warn


def validate_registry() -> bool:
    """
    Validate all expected actions are registered.
    
    Call this after app startup to ensure action registry integrity.
    This addresses I-04 (Silent Import Failures) by providing an explicit
    validation mechanism.
    
    Returns:
        True if all expected actions are registered, False otherwise.
    
    Usage:
        from lib.oda.ontology.actions import validate_registry
        if not validate_registry():
            raise RuntimeError("Action registry incomplete")
    """
    registered = action_registry.list_actions()
    missing = [name for name in _EXPECTED_ACTIONS if name not in registered]
    
    if missing:
        logger.error(f"Missing expected actions in registry: {missing}")
        return False
    
    logger.info(f"Action registry validated: {len(registered)} actions registered")
    return True
