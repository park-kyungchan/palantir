#!/usr/bin/env bash
# =============================================================================
# YAML Logger Helper (V1.0.0)
# =============================================================================
# Purpose: Machine-Readable YAML logging for /build skill interactions
# Architecture: Workload-scoped interaction logging (2026-02-01)
# Usage: source /home/palantir/.claude/skills/build/helpers/yaml-logger.sh
# =============================================================================
#
# CHANGELOG (V1.0.0):
# - Initial implementation for interaction_log.yaml management
# - Round-by-Round Q&A logging with full traceability
# - collected_state updates for Parallel Agents Delegation
# - Post-Compact Recovery compatible
# =============================================================================

set -euo pipefail

# ============================================================================
# CONSTANTS
# ============================================================================
YAML_LOGGER_VERSION="1.0.0"
PROMPTS_BASE_DIR=".agent/prompts"
BUILD_SUBDIR="build"
INTERACTION_LOG_FILENAME="interaction_log.yaml"

# Source dependencies
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source workload-files.sh for workload management
if ! command -v get_active_workload_slug &> /dev/null; then
    SHARED_DIR="$(cd "$SCRIPT_DIR/../../shared" && pwd)"
    if [[ -f "${SHARED_DIR}/workload-files.sh" ]]; then
        source "${SHARED_DIR}/workload-files.sh"
    fi
fi

# ============================================================================
# get_interaction_log_path
# Get path to workload-specific interaction_log.yaml
#
# Args:
#   $1 - Workload slug (optional, defaults to active workload)
#
# Output:
#   Path to interaction_log.yaml file
# ============================================================================
get_interaction_log_path() {
    local slug="${1:-}"

    if [[ -z "$slug" ]]; then
        slug=$(get_active_workload_slug 2>/dev/null || echo "")
    fi

    if [[ -z "$slug" ]]; then
        echo "ERROR: No active workload. Set workload first." >&2
        return 1
    fi

    echo "${PROMPTS_BASE_DIR}/${slug}/${BUILD_SUBDIR}/${INTERACTION_LOG_FILENAME}"
}

# ============================================================================
# init_interaction_log
# Initialize a new interaction log for a build session
#
# Args:
#   $1 - Workload slug
#   $2 - Component type (agent|skill|hook)
#   $3 - Mode (concept|direct|resume)
#   $4 - Original request (user's original request text)
#
# Side Effects:
#   Creates .agent/prompts/{slug}/build/interaction_log.yaml
#
# Output:
#   Path to created interaction log
# ============================================================================
init_interaction_log() {
    local slug="$1"
    local component_type="$2"
    local mode="${3:-concept}"
    local original_request="${4:-}"

    local log_dir="${PROMPTS_BASE_DIR}/${slug}/${BUILD_SUBDIR}"
    local log_path="${log_dir}/${INTERACTION_LOG_FILENAME}"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Derive workload_id from slug (reconstruct format)
    local workload_id="${slug//-/_}"

    # Create directory structure
    mkdir -p "$log_dir"

    # Escape special characters in original_request for YAML
    local escaped_request
    escaped_request=$(echo "$original_request" | sed 's/"/\\"/g' | sed "s/'/\\'/g")

    # Initialize interaction log with full schema
    cat > "$log_path" <<EOF
# ============================================================
# /build Interaction Log
# ============================================================
# Auto-generated by yaml-logger.sh V${YAML_LOGGER_VERSION}
# Schema: enhancement_spec.yaml/interaction_log_schema
# ============================================================

workload:
  id: "${workload_id}"
  slug: "${slug}"
  type: "${component_type}"
  mode: "${mode}"
  status: "in_progress"
  created_at: "${timestamp}"
  updated_at: "${timestamp}"

requirements:
  original_request: "${escaped_request}"
  clarified_intent: ""
  target_components: []

interactions: []

collected_state:
  # Agent fields (Claude Code 2.1.x full spec)
  name: ""
  description: ""
  model: ""
  tools: []
  disallowedTools: []
  permissionMode: ""
  skills: []
  hooks:
    PreToolUse: []
    PostToolUse: []
    Stop: []
  custom_instructions: ""

generation:
  status: "pending"
  target_path: ""
  preview: ""
  validation_result: null
  error: null
EOF

    echo "$log_path"
}

# ============================================================================
# log_interaction_round
# Record a Q&A round in the interaction log
#
# Args:
#   $1 - Workload slug
#   $2 - Phase (identity|tools|permissions|hooks|...)
#   $3 - Builder (agent-builder|skill-builder|hook-builder)
#   $4 - Question text
#   $5 - Question type (text|single_select|multi_select)
#   $6 - User response
#   $7 - Decision (key: value format)
#   $8 - Options (JSON array string, optional)
#   $9 - Rationale (optional)
#   $10 - Delegated to (optional, parameter module name)
#
# Side Effects:
#   Appends to interactions array in interaction_log.yaml
# ============================================================================
log_interaction_round() {
    local slug="$1"
    local phase="$2"
    local builder="$3"
    local question="$4"
    local question_type="$5"
    local user_response="$6"
    local decision="$7"
    local options="${8:-null}"
    local rationale="${9:-}"
    local delegated_to="${10:-}"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Get current round number
    local round
    local round_count
    if command -v yq &> /dev/null; then
        round=$(yq -r '.interactions | length + 1' "$log_path")
    else
        # Fallback: count existing rounds
        round_count=$(grep -c "^  - round:" "$log_path" 2>/dev/null) || round_count=0
        round=$((round_count + 1))
    fi

    # Escape special characters for YAML
    local escaped_question
    local escaped_response
    local escaped_decision
    local escaped_rationale
    escaped_question=$(echo "$question" | sed 's/"/\\"/g')
    escaped_response=$(echo "$user_response" | sed 's/"/\\"/g')
    escaped_decision=$(echo "$decision" | sed 's/"/\\"/g')
    escaped_rationale=$(echo "$rationale" | sed 's/"/\\"/g')

    # Handle options (could be null or JSON array)
    local options_yaml
    if [[ "$options" == "null" || -z "$options" ]]; then
        options_yaml="null"
    else
        # Convert JSON array to YAML inline format
        options_yaml="$options"
    fi

    # Handle delegated_to
    local delegated_yaml
    if [[ -z "$delegated_to" ]]; then
        delegated_yaml="null"
    else
        delegated_yaml="\"$delegated_to\""
    fi

    # Handle rationale
    local rationale_yaml
    if [[ -z "$escaped_rationale" ]]; then
        rationale_yaml="null"
    else
        rationale_yaml="\"$escaped_rationale\""
    fi

    if command -v yq &> /dev/null; then
        # Use yq for proper YAML handling
        local new_round
        new_round=$(cat <<EOF
{
  "round": $round,
  "phase": "$phase",
  "builder": "$builder",
  "question": "$escaped_question",
  "question_type": "$question_type",
  "options": $options_yaml,
  "user_response": "$escaped_response",
  "decision": "$escaped_decision",
  "rationale": $rationale_yaml,
  "delegated_to": $delegated_yaml,
  "timestamp": "$timestamp"
}
EOF
)
        yq -i ".interactions += [$new_round] | .workload.updated_at = \"$timestamp\"" "$log_path"
    else
        # Fallback: append manually (limited but functional)
        # Find the line with "interactions: []" and replace, or append to array
        local temp_file
        temp_file=$(mktemp)

        # Read current file, find interactions section, append new round
        if grep -q "interactions: \[\]" "$log_path"; then
            # Empty array - replace with new content
            sed "s/interactions: \[\]/interactions:\n  - round: $round\n    phase: \"$phase\"\n    builder: \"$builder\"\n    question: \"$escaped_question\"\n    question_type: \"$question_type\"\n    options: $options_yaml\n    user_response: \"$escaped_response\"\n    decision: \"$escaped_decision\"\n    rationale: $rationale_yaml\n    delegated_to: $delegated_yaml\n    timestamp: \"$timestamp\"/" "$log_path" > "$temp_file"
            mv "$temp_file" "$log_path"
        else
            # Append to existing array (insert before collected_state)
            local insert_content
            insert_content="  - round: $round
    phase: \"$phase\"
    builder: \"$builder\"
    question: \"$escaped_question\"
    question_type: \"$question_type\"
    options: $options_yaml
    user_response: \"$escaped_response\"
    decision: \"$escaped_decision\"
    rationale: $rationale_yaml
    delegated_to: $delegated_yaml
    timestamp: \"$timestamp\"
"
            sed -i "/^collected_state:/i\\$insert_content" "$log_path"
        fi

        # Update timestamp
        sed -i "s/updated_at:.*/updated_at: \"$timestamp\"/" "$log_path"
    fi

    echo "Round $round logged: $phase"
}

# ============================================================================
# update_collected_state
# Update a field in the collected_state section
#
# Args:
#   $1 - Workload slug
#   $2 - Field name (name|description|model|tools|disallowedTools|...)
#   $3 - Value (string or JSON array for array fields)
#
# Side Effects:
#   Updates collected_state in interaction_log.yaml
# ============================================================================
update_collected_state() {
    local slug="$1"
    local field="$2"
    local value="$3"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if command -v yq &> /dev/null; then
        # Determine if value is array or scalar
        if [[ "$value" == "["* ]]; then
            # JSON array
            yq -i ".collected_state.$field = $value | .workload.updated_at = \"$timestamp\"" "$log_path"
        else
            # String value
            yq -i ".collected_state.$field = \"$value\" | .workload.updated_at = \"$timestamp\"" "$log_path"
        fi
    else
        # Fallback: use sed (limited)
        local escaped_value
        escaped_value=$(echo "$value" | sed 's/"/\\"/g')

        if [[ "$value" == "["* ]]; then
            # Array - need special handling
            sed -i "s/^  $field:.*$/  $field: $value/" "$log_path"
        else
            sed -i "s/^  $field:.*$/  $field: \"$escaped_value\"/" "$log_path"
        fi

        sed -i "s/updated_at:.*/updated_at: \"$timestamp\"/" "$log_path"
    fi
}

# ============================================================================
# update_collected_state_array
# Add items to an array field in collected_state
#
# Args:
#   $1 - Workload slug
#   $2 - Field name (tools|disallowedTools|skills)
#   $@ - Items to add
#
# Side Effects:
#   Updates array in collected_state
# ============================================================================
update_collected_state_array() {
    local slug="$1"
    local field="$2"
    shift 2
    local items=("$@")

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if command -v yq &> /dev/null; then
        # Build JSON array from items
        local json_array
        json_array=$(printf '%s\n' "${items[@]}" | jq -R . | jq -s .)

        yq -i ".collected_state.$field = $json_array | .workload.updated_at = \"$timestamp\"" "$log_path"
    else
        # Fallback: manual array building
        local yaml_items=""
        for item in "${items[@]}"; do
            yaml_items="$yaml_items\n    - \"$item\""
        done

        # Replace the field
        sed -i "s/^  $field: \[\]/  $field:$yaml_items/" "$log_path"
        sed -i "s/updated_at:.*/updated_at: \"$timestamp\"/" "$log_path"
    fi
}

# ============================================================================
# update_hooks_state
# Update hooks in collected_state
#
# Args:
#   $1 - Workload slug
#   $2 - Hook type (PreToolUse|PostToolUse|Stop)
#   $3 - Hook config (JSON object)
#
# Side Effects:
#   Appends hook config to collected_state.hooks
# ============================================================================
update_hooks_state() {
    local slug="$1"
    local hook_type="$2"
    local hook_config="$3"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if command -v yq &> /dev/null; then
        yq -i ".collected_state.hooks.$hook_type += [$hook_config] | .workload.updated_at = \"$timestamp\"" "$log_path"
    else
        echo "WARNING: Hook update requires yq for proper handling" >&2
        return 1
    fi
}

# ============================================================================
# update_generation_status
# Update generation section status
#
# Args:
#   $1 - Workload slug
#   $2 - Status (pending|preview|confirmed|generated|failed)
#   $3 - Target path (optional)
#   $4 - Preview content (optional)
#   $5 - Error message (optional)
#
# Side Effects:
#   Updates generation section in interaction_log.yaml
# ============================================================================
update_generation_status() {
    local slug="$1"
    local status="$2"
    local target_path="${3:-}"
    local preview="${4:-}"
    local error="${5:-}"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if command -v yq &> /dev/null; then
        yq -i ".generation.status = \"$status\" | .workload.updated_at = \"$timestamp\"" "$log_path"

        if [[ -n "$target_path" ]]; then
            yq -i ".generation.target_path = \"$target_path\"" "$log_path"
        fi

        if [[ -n "$preview" ]]; then
            # Escape for YAML
            local escaped_preview
            escaped_preview=$(echo "$preview" | sed 's/"/\\"/g')
            yq -i ".generation.preview = \"$escaped_preview\"" "$log_path"
        fi

        if [[ -n "$error" ]]; then
            yq -i ".generation.error = \"$error\"" "$log_path"
        fi
    else
        sed -i "s/^  status:.*$/  status: \"$status\"/" "$log_path"
        sed -i "s/updated_at:.*/updated_at: \"$timestamp\"/" "$log_path"
    fi
}

# ============================================================================
# update_workload_status
# Update overall workload status
#
# Args:
#   $1 - Workload slug
#   $2 - Status (in_progress|awaiting_input|completed|failed)
#
# Side Effects:
#   Updates workload.status in interaction_log.yaml
# ============================================================================
update_workload_status() {
    local slug="$1"
    local status="$2"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if command -v yq &> /dev/null; then
        yq -i ".workload.status = \"$status\" | .workload.updated_at = \"$timestamp\"" "$log_path"
    else
        # Find the status under workload section (first occurrence)
        sed -i "0,/status:/s/status:.*/status: \"$status\"/" "$log_path"
        sed -i "s/updated_at:.*/updated_at: \"$timestamp\"/" "$log_path"
    fi
}

# ============================================================================
# set_clarified_intent
# Set the clarified intent in requirements
#
# Args:
#   $1 - Workload slug
#   $2 - Clarified intent text
#
# Side Effects:
#   Updates requirements.clarified_intent
# ============================================================================
set_clarified_intent() {
    local slug="$1"
    local intent="$2"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local escaped_intent
    escaped_intent=$(echo "$intent" | sed 's/"/\\"/g')

    if command -v yq &> /dev/null; then
        yq -i ".requirements.clarified_intent = \"$escaped_intent\" | .workload.updated_at = \"$timestamp\"" "$log_path"
    else
        sed -i "s/clarified_intent:.*/clarified_intent: \"$escaped_intent\"/" "$log_path"
        sed -i "s/updated_at:.*/updated_at: \"$timestamp\"/" "$log_path"
    fi
}

# ============================================================================
# add_target_component
# Add a target component to requirements
#
# Args:
#   $1 - Workload slug
#   $2 - Component type (agent|skill|hook)
#   $3 - Component name
#   $4 - Component purpose
#
# Side Effects:
#   Appends to requirements.target_components
# ============================================================================
add_target_component() {
    local slug="$1"
    local comp_type="$2"
    local comp_name="$3"
    local comp_purpose="$4"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if command -v yq &> /dev/null; then
        local component_json
        component_json=$(cat <<EOF
{
  "type": "$comp_type",
  "name": "$comp_name",
  "purpose": "$comp_purpose"
}
EOF
)
        yq -i ".requirements.target_components += [$component_json] | .workload.updated_at = \"$timestamp\"" "$log_path"
    else
        echo "WARNING: add_target_component requires yq" >&2
        return 1
    fi
}

# ============================================================================
# read_interaction_log
# Read and parse interaction log
#
# Args:
#   $1 - Workload slug
#
# Output:
#   Full YAML content of interaction log
# ============================================================================
read_interaction_log() {
    local slug="$1"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    cat "$log_path"
}

# ============================================================================
# get_collected_state
# Get collected_state section as JSON
#
# Args:
#   $1 - Workload slug
#
# Output:
#   JSON representation of collected_state
# ============================================================================
get_collected_state() {
    local slug="$1"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "ERROR: Interaction log not found: $log_path" >&2
        return 1
    fi

    if command -v yq &> /dev/null; then
        yq -o=json '.collected_state' "$log_path"
    else
        echo "{}"
        return 1
    fi
}

# ============================================================================
# get_interaction_count
# Get number of recorded interaction rounds
#
# Args:
#   $1 - Workload slug
#
# Output:
#   Number of interactions
# ============================================================================
get_interaction_count() {
    local slug="$1"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo "0"
        return 1
    fi

    if command -v yq &> /dev/null; then
        yq -r '.interactions | length' "$log_path"
    else
        grep -c "^  - round:" "$log_path" 2>/dev/null || echo "0"
    fi
}

# ============================================================================
# get_last_phase
# Get the phase of the last interaction round
#
# Args:
#   $1 - Workload slug
#
# Output:
#   Phase name of last round, or empty if no rounds
# ============================================================================
get_last_phase() {
    local slug="$1"

    local log_path
    log_path=$(get_interaction_log_path "$slug") || return 1

    if [[ ! -f "$log_path" ]]; then
        echo ""
        return 1
    fi

    if command -v yq &> /dev/null; then
        yq -r '.interactions[-1].phase // ""' "$log_path"
    else
        # Fallback: get last phase entry
        grep "phase:" "$log_path" | tail -1 | sed 's/.*phase: "//' | sed 's/"//'
    fi
}

# ============================================================================
# check_yq_available
# Check if yq is available for proper YAML handling
#
# Output:
#   0 if available, 1 if not
# ============================================================================
check_yq_available() {
    if command -v yq &> /dev/null; then
        return 0
    else
        echo "WARNING: yq not found. Some features may be limited." >&2
        echo "   Install yq for better YAML handling: https://github.com/mikefarah/yq" >&2
        return 1
    fi
}

# ============================================================================
# EXPORTS
# ============================================================================
export -f get_interaction_log_path
export -f init_interaction_log
export -f log_interaction_round
export -f update_collected_state
export -f update_collected_state_array
export -f update_hooks_state
export -f update_generation_status
export -f update_workload_status
export -f set_clarified_intent
export -f add_target_component
export -f read_interaction_log
export -f get_collected_state
export -f get_interaction_count
export -f get_last_phase
export -f check_yq_available

# ============================================================================
# SELF-TEST (Optional - for development)
# ============================================================================
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "=== YAML Logger Self-Test ==="
    echo "Version: $YAML_LOGGER_VERSION"

    # Check yq availability
    echo ""
    echo "Checking yq availability..."
    if check_yq_available; then
        echo "  yq is available"
    else
        echo "  yq is NOT available (tests may be limited)"
    fi

    # Test 1: Initialize interaction log
    echo ""
    echo "Test 1: init_interaction_log"
    test_slug="yaml-logger-test-$(date +%s)"
    log_path=$(init_interaction_log "$test_slug" "agent" "concept" "Create a readonly analyzer agent")
    echo "  Created: $log_path"

    # Test 2: Log interaction round
    echo ""
    echo "Test 2: log_interaction_round"
    log_interaction_round "$test_slug" "identity" "agent-builder" \
        "What should be the agent name?" "text" \
        "readonly-analyzer" "name: readonly-analyzer" \
        "null" "User provided explicit name"

    # Test 3: Update collected state
    echo ""
    echo "Test 3: update_collected_state"
    update_collected_state "$test_slug" "name" "readonly-analyzer"
    update_collected_state "$test_slug" "model" "sonnet"

    # Test 4: Update array field
    echo ""
    echo "Test 4: update_collected_state_array"
    update_collected_state_array "$test_slug" "tools" "Read" "Grep" "Glob"

    # Test 5: Get interaction count
    echo ""
    echo "Test 5: get_interaction_count"
    count=$(get_interaction_count "$test_slug")
    echo "  Interaction count: $count"

    # Test 6: Get collected state
    echo ""
    echo "Test 6: get_collected_state"
    state=$(get_collected_state "$test_slug")
    echo "  State: $state"

    # Test 7: Read full log
    echo ""
    echo "Test 7: read_interaction_log"
    echo "  Full log content:"
    read_interaction_log "$test_slug" | head -30
    echo "  ..."

    # Cleanup
    echo ""
    echo "Cleaning up test files..."
    rm -rf "${PROMPTS_BASE_DIR}/${test_slug}"
    echo "  Removed: ${PROMPTS_BASE_DIR}/${test_slug}"

    echo ""
    echo "=== All tests completed ==="
fi
