# Session-Aware Worker Prompt System

> **Plan ID:** streamed-wishing-scott
> **Created:** 2026-01-24
> **Status:** Pending Approval

---

## 1. 목표

1. **세션 추적**: `CLAUDE_SESSION_ID` 파일 기반 레지스트리로 터미널 식별
2. **Machine-Readable 프롬프트**: Worker 프롬프트를 YAML 파일로 전달
3. **Orchestrator 워크플로우 최적화**: Main Agent가 파일 생성 → Worker가 파일 읽기

---

## 2. 핵심 설계 결정

### 2.1 환경변수 대신 파일 기반 세션 레지스트리

**문제**: Hook의 `export`는 부모 프로세스로 전파 불가 (shell 한계)

**해결**: `.agent/tmp/current_session.json` 파일 사용

```json
{
  "sessionId": "1769181929-610430",
  "startTime": "2026-01-24T00:00:00Z",
  "pid": "610430",
  "status": "active"
}
```

### 2.2 Worker 프롬프트 파일 구조

```yaml
---
promptId: abc12345
sessionId: 1769181929-610430
timestamp: 2026-01-24T00:00:00Z
subagentType: Explore
model: opus
outputFormat: L1/L2/L3
cacheInputHash: def67890
---

## Task Description
{Original prompt content}

## Output Format
{L1/L2/L3 instructions}
```

### 2.3 프롬프트 파일 Lifecycle

```
pending/ → active/ → completed/
   │          │           │
   │          │           └── 완료 후 아카이브 (audit trail)
   │          └── Worker 실행 중
   └── Main Agent가 생성, Worker 대기
```

---

## 3. 디렉토리 구조

```
.agent/
├── prompts/                    # NEW
│   ├── pending/                # 대기 중인 프롬프트
│   │   └── {session8}-{promptId}.yaml
│   ├── active/                 # 실행 중
│   └── completed/              # 완료됨
├── tmp/
│   ├── current_session.json    # NEW: 세션 레지스트리
│   └── sessions/
└── outputs/                    # 기존 L3 파일
```

---

## 4. 수정 파일 목록

| 파일 | 수정 내용 | 우선순위 |
|------|----------|----------|
| `.claude/hooks/session-start.sh` | current_session.json 생성, prompts 디렉토리 초기화 | P1 |
| `.claude/hooks/task-pipeline/pd-task-interceptor.sh` | 세션 ID 파일 읽기, 프롬프트 파일 생성 | P1 |
| `.claude/hooks/task-pipeline/pd-task-processor.sh` | 프롬프트 파일 lifecycle 관리 | P2 |
| `.claude/hooks/session-health.sh` | 세션 ID 파일에서 읽기 | P2 |
| `.claude/hooks/session-end.sh` | 세션 상태 업데이트 | P3 |

---

## 5. 구현 단계

### Phase 1: 세션 레지스트리 (session-start.sh)

**위치**: 라인 301 이후

```bash
# Write current session to file registry
CURRENT_SESSION_FILE="$AGENT_TMP_DIR/current_session.json"
cat > "$CURRENT_SESSION_FILE" << SESSION_EOF
{
  "sessionId": "$SESSION_ID",
  "startTime": "$TIMESTAMP",
  "pid": "$$",
  "status": "active"
}
SESSION_EOF

# Create prompts directories
mkdir -p "${WORKSPACE_ROOT}/.agent/prompts/pending" 2>/dev/null
mkdir -p "${WORKSPACE_ROOT}/.agent/prompts/active" 2>/dev/null
mkdir -p "${WORKSPACE_ROOT}/.agent/prompts/completed" 2>/dev/null
```

### Phase 2: 프롬프트 파일 생성 (pd-task-interceptor.sh)

**위치**: 라인 160 이후 (세션 ID 읽기)

```bash
# Read session from file registry
SESSION_REGISTRY="${HOME}/.agent/tmp/current_session.json"
ORCHESTRATOR_SESSION_ID="unknown"
if [ -f "$SESSION_REGISTRY" ]; then
    ORCHESTRATOR_SESSION_ID=$(json_get '.sessionId' "$(cat "$SESSION_REGISTRY")")
fi
```

**위치**: 라인 290 이후 (새 함수)

```bash
create_worker_prompt_file() {
    local subagent_type="$1"
    local original_prompt="$2"
    local cache_hash="$3"

    local prompt_id=$(date +%s | tail -c 9)
    local session_prefix="${ORCHESTRATOR_SESSION_ID:0:8}"
    local prompt_file="${WORKSPACE_ROOT}/.agent/prompts/pending/${session_prefix}-${prompt_id}.yaml"

    cat > "$prompt_file" << PROMPT_EOF
---
promptId: $prompt_id
sessionId: $ORCHESTRATOR_SESSION_ID
timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
subagentType: $subagent_type
model: opus
outputFormat: L1/L2/L3
cacheInputHash: $cache_hash
---

$original_prompt

$L1L2L3_PROMPT
PROMPT_EOF

    echo "$prompt_file"
}
```

### Phase 3: 프롬프트 Lifecycle (pd-task-processor.sh)

**위치**: 라인 270 이후

```bash
# Move prompt file: pending → completed
PROMPT_FILE=$(json_get '.tool_input._workerPromptFile' "$INPUT")
if [[ -n "$PROMPT_FILE" && -f "$PROMPT_FILE" ]]; then
    COMPLETED_DIR="${WORKSPACE_ROOT}/.agent/prompts/completed"
    mv "$PROMPT_FILE" "$COMPLETED_DIR/" 2>/dev/null || true
fi
```

---

## 6. 성능 목표

| 작업 | 목표 | 방법 |
|------|------|------|
| 세션 파일 읽기 | <1ms | 단일 JSON 파일 |
| 프롬프트 파일 쓰기 | <2ms | 사전 생성된 디렉토리 |
| 전체 오버헤드 | <5ms | jq 우선 사용 |

---

## 7. 검증 방법

### 7.1 세션 ID 확인
```bash
cat ~/.agent/tmp/current_session.json
# 예상: {"sessionId": "...", "status": "active"}
```

### 7.2 프롬프트 파일 생성 확인
```bash
ls -la .agent/prompts/pending/
# Task 호출 후 YAML 파일 존재 확인
```

### 7.3 Lifecycle 확인
```bash
# Task 완료 후
ls -la .agent/prompts/completed/
# 프롬프트 파일이 이동됨 확인
```

### 7.4 성능 벤치마크
```bash
# 10회 Task 실행 시간 측정
time for i in {1..10}; do
  # Task subagent 호출
done
# 기존 대비 <5ms 증가 확인
```

---

## 8. Rollback Plan

문제 발생 시:
1. `session-start.sh`에서 current_session.json 생성 제거
2. `pd-task-interceptor.sh`에서 프롬프트 파일 생성 제거
3. 기존 inline JSON 방식으로 자동 폴백
4. `.agent/prompts/` 디렉토리는 유지 (데이터 손실 없음)

---

## 9. Worker 터미널 사용법 (구현 후)

### Orchestrator (Main Agent)
```bash
# 1. 프롬프트 파일 확인
cat .agent/prompts/pending/*.yaml

# 2. Worker에 전달할 정보
echo "Worker 프롬프트: .agent/prompts/pending/17691819-abc12345.yaml"
```

### Worker 터미널
```bash
# 환경 설정
export CLAUDE_CODE_TASK_LIST_ID="palantir-v3-refactor"
claude

# Claude Code 내에서
# 프롬프트 파일 읽기: Read .agent/prompts/pending/17691819-abc12345.yaml
```
