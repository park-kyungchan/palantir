"""
Property Definition for Ontology Types.

A PropertyDefinition describes a single property within an ObjectType, LinkType,
or StructType. It specifies:
    - Data type (one of 20 supported types)
    - Validation constraints
    - Backing column mapping
    - Special flags (editOnly, derived, mandatoryControl)

This module provides:
    - DataTypeSpec: Data type specification with nested type support
    - PropertyDefinition: Complete property schema definition
    - StructField: Field definition for STRUCT type
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, field_validator, model_validator

from ontology_definition.core.enums import DataType, PropertyVisibility
from ontology_definition.constraints.property_constraints import (
    ArrayConstraints,
    DecimalConstraints,
    PropertyConstraints,
    VectorConstraints,
)

if TYPE_CHECKING:
    pass


class StructField(BaseModel):
    """
    Field definition within a STRUCT type.

    Structs are nested, typed structures similar to JSON objects.
    Each field has a name, type, and optional required flag.

    Example:
        address_struct = [
            StructField(name="street", data_type=DataTypeSpec(type=DataType.STRING)),
            StructField(name="city", data_type=DataTypeSpec(type=DataType.STRING), required=True),
            StructField(name="zip_code", data_type=DataTypeSpec(type=DataType.STRING)),
        ]
    """

    name: str = Field(
        ...,
        description="Field name within the struct.",
        min_length=1,
        max_length=255,
    )

    data_type: "DataTypeSpec" = Field(
        ...,
        description="Data type for this field.",
        alias="type",
    )

    required: bool = Field(
        default=False,
        description="If true, this field must have a value.",
    )

    description: Optional[str] = Field(
        default=None,
        description="Documentation for this field.",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        result: dict[str, Any] = {
            "name": self.name,
            "type": self.data_type.to_foundry_dict(),
        }
        if self.required:
            result["required"] = True
        if self.description:
            result["description"] = self.description
        return result


class DataTypeSpec(BaseModel):
    """
    Data type specification for a property.

    Supports all 20 Palantir Foundry data types with nested type configuration:
    - Simple types: STRING, INTEGER, LONG, FLOAT, DOUBLE, BOOLEAN, etc.
    - Complex types: ARRAY (with item type), STRUCT (with fields)
    - Special types: VECTOR (with dimension), DECIMAL (with precision/scale)

    Examples:
        # Simple type
        DataTypeSpec(type=DataType.STRING)

        # Array of strings
        DataTypeSpec(
            type=DataType.ARRAY,
            array_item_type=DataTypeSpec(type=DataType.STRING)
        )

        # Struct type
        DataTypeSpec(
            type=DataType.STRUCT,
            struct_fields=[
                StructField(name="x", data_type=DataTypeSpec(type=DataType.FLOAT)),
                StructField(name="y", data_type=DataTypeSpec(type=DataType.FLOAT)),
            ]
        )
    """

    type: DataType = Field(
        ...,
        description="Base data type identifier.",
    )

    # For ARRAY type
    array_item_type: Optional["DataTypeSpec"] = Field(
        default=None,
        description="For ARRAY type, the type of array elements.",
        alias="arrayItemType",
    )

    # For STRUCT type
    struct_fields: Optional[list[StructField]] = Field(
        default=None,
        description="For STRUCT type, the field definitions.",
        alias="structFields",
    )

    # For ValueType reference
    value_type_ref: Optional[str] = Field(
        default=None,
        description="Reference to a custom ValueType definition by apiName.",
        alias="valueTypeRef",
    )

    # For DECIMAL type
    precision: Optional[int] = Field(
        default=None,
        description="For DECIMAL type, total number of digits (1-38).",
        ge=1,
        le=38,
    )

    scale: Optional[int] = Field(
        default=None,
        description="For DECIMAL type, digits after decimal point (0-precision).",
        ge=0,
        le=38,
    )

    # For VECTOR type
    vector_dimension: Optional[int] = Field(
        default=None,
        description="For VECTOR type, the dimension size.",
        ge=1,
        alias="vectorDimension",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
        use_enum_values=False,
    )

    @model_validator(mode="after")
    def validate_type_config(self) -> "DataTypeSpec":
        """Validate that required configuration is present for complex types."""
        if self.type == DataType.ARRAY and self.array_item_type is None:
            raise ValueError("ARRAY type requires array_item_type specification")

        if self.type == DataType.STRUCT and not self.struct_fields:
            raise ValueError("STRUCT type requires struct_fields specification")

        if self.type == DataType.VECTOR and self.vector_dimension is None:
            raise ValueError("VECTOR type requires vector_dimension specification")

        return self

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        result: dict[str, Any] = {"type": self.type.value}

        if self.array_item_type:
            result["arrayItemType"] = self.array_item_type.to_foundry_dict()

        if self.struct_fields:
            result["structFields"] = [f.to_foundry_dict() for f in self.struct_fields]

        if self.value_type_ref:
            result["valueTypeRef"] = self.value_type_ref

        if self.precision is not None:
            result["precision"] = self.precision

        if self.scale is not None:
            result["scale"] = self.scale

        if self.vector_dimension is not None:
            result["vectorDimension"] = self.vector_dimension

        return result

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "DataTypeSpec":
        """Create from Foundry JSON format."""
        array_item = None
        if data.get("arrayItemType"):
            array_item = cls.from_foundry_dict(data["arrayItemType"])

        struct_fields = None
        if data.get("structFields"):
            struct_fields = [
                StructField(
                    name=f["name"],
                    data_type=cls.from_foundry_dict(f["type"]),
                    required=f.get("required", False),
                    description=f.get("description"),
                )
                for f in data["structFields"]
            ]

        return cls(
            type=DataType(data["type"]),
            array_item_type=array_item,
            struct_fields=struct_fields,
            value_type_ref=data.get("valueTypeRef"),
            precision=data.get("precision"),
            scale=data.get("scale"),
            vector_dimension=data.get("vectorDimension"),
        )


class PropertyDefinition(BaseModel):
    """
    Complete property definition within an ObjectType.

    A property represents a single attribute of an ObjectType, defining:
    - Identity: apiName, displayName, description
    - Type: data type specification (one of 20 types)
    - Constraints: validation rules (required, unique, pattern, etc.)
    - Mapping: backing column in dataset
    - Flags: editOnly, derived, mandatoryControl

    Example:
        employee_name = PropertyDefinition(
            api_name="employeeName",
            display_name="Employee Name",
            data_type=DataTypeSpec(type=DataType.STRING),
            constraints=PropertyConstraints(
                required=True,
                string=StringConstraints(min_length=1, max_length=100)
            ),
            backing_column="employee_name"
        )
    """

    # Identity
    api_name: str = Field(
        ...,
        description="Unique identifier within the ObjectType.",
        min_length=1,
        max_length=255,
        pattern=r"^[a-zA-Z][a-zA-Z0-9_]*$",
        alias="apiName",
    )

    display_name: str = Field(
        ...,
        description="Human-friendly name for UI display.",
        min_length=1,
        max_length=255,
        alias="displayName",
    )

    description: Optional[str] = Field(
        default=None,
        description="Documentation describing this property.",
        max_length=4096,
    )

    # Type Specification
    data_type: DataTypeSpec = Field(
        ...,
        description="Data type specification for this property.",
        alias="dataType",
    )

    # Constraints
    constraints: Optional[PropertyConstraints] = Field(
        default=None,
        description="Validation constraints for this property.",
    )

    # Dataset Mapping
    backing_column: Optional[str] = Field(
        default=None,
        description="Column name in backing dataset. Null for edit-only properties.",
        alias="backingColumn",
    )

    # Special Flags
    is_edit_only: bool = Field(
        default=False,
        description="If true, not populated from dataset, only via user edits.",
        alias="isEditOnly",
    )

    is_derived: bool = Field(
        default=False,
        description="If true, computed in real-time by function/expression.",
        alias="isDerived",
    )

    derived_expression: Optional[str] = Field(
        default=None,
        description="Expression or function reference for derived properties.",
        alias="derivedExpression",
    )

    is_mandatory_control: bool = Field(
        default=False,
        description="If true, this is a security marking property for row-level access control. "
                    "Must be required and cannot have default value.",
        alias="isMandatoryControl",
    )

    # SharedProperty Reference
    shared_property_ref: Optional[str] = Field(
        default=None,
        description="Reference to a SharedProperty definition if this uses shared schema.",
        alias="sharedPropertyRef",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    @model_validator(mode="after")
    def validate_mandatory_control_rules(self) -> "PropertyDefinition":
        """
        Validate mandatory control property requirements.

        Mandatory control properties:
        1. Must be required
        2. Cannot have default value
        3. Must be STRING or ARRAY[STRING] type
        """
        if self.is_mandatory_control:
            # Check required constraint
            if not self.constraints or not self.constraints.required:
                raise ValueError(
                    "Mandatory control property must have required=True constraint"
                )

            # Check no default value
            if self.constraints and self.constraints.default_value is not None:
                raise ValueError(
                    "Mandatory control property cannot have a default value"
                )

            # Check data type
            valid = (
                self.data_type.type == DataType.STRING
                or (
                    self.data_type.type == DataType.ARRAY
                    and self.data_type.array_item_type
                    and self.data_type.array_item_type.type == DataType.STRING
                )
            )
            if not valid:
                raise ValueError(
                    "Mandatory control property must be STRING or ARRAY[STRING] type"
                )

        return self

    @model_validator(mode="after")
    def validate_derived_expression(self) -> "PropertyDefinition":
        """Validate derived properties have expression defined."""
        if self.is_derived and not self.derived_expression:
            raise ValueError("Derived property must have derived_expression defined")
        return self

    @model_validator(mode="after")
    def validate_edit_only_backing(self) -> "PropertyDefinition":
        """Validate edit-only properties don't have backing column."""
        if self.is_edit_only and self.backing_column:
            raise ValueError(
                "Edit-only property should not have backing_column "
                "(it's not populated from dataset)"
            )
        return self

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        result: dict[str, Any] = {
            "apiName": self.api_name,
            "displayName": self.display_name,
            "dataType": self.data_type.to_foundry_dict(),
        }

        if self.description:
            result["description"] = self.description

        if self.constraints:
            result["constraints"] = self.constraints.to_foundry_dict()

        if self.backing_column:
            result["backingColumn"] = self.backing_column

        if self.is_edit_only:
            result["isEditOnly"] = True

        if self.is_derived:
            result["isDerived"] = True
            if self.derived_expression:
                result["derivedExpression"] = self.derived_expression

        if self.is_mandatory_control:
            result["isMandatoryControl"] = True

        if self.shared_property_ref:
            result["sharedPropertyRef"] = self.shared_property_ref

        return result

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "PropertyDefinition":
        """Create from Foundry JSON format."""
        constraints = None
        if data.get("constraints"):
            constraints = PropertyConstraints.from_foundry_dict(data["constraints"])

        return cls(
            api_name=data["apiName"],
            display_name=data["displayName"],
            description=data.get("description"),
            data_type=DataTypeSpec.from_foundry_dict(data["dataType"]),
            constraints=constraints,
            backing_column=data.get("backingColumn"),
            is_edit_only=data.get("isEditOnly", False),
            is_derived=data.get("isDerived", False),
            derived_expression=data.get("derivedExpression"),
            is_mandatory_control=data.get("isMandatoryControl", False),
            shared_property_ref=data.get("sharedPropertyRef"),
        )


class PrimaryKeyDefinition(BaseModel):
    """
    Primary key configuration for ObjectType.

    Every ObjectType must have a primary key to uniquely identify instances.
    The primary key references a property by its apiName.

    Example:
        primary_key = PrimaryKeyDefinition(
            property_api_name="employeeId",
            backing_column="employee_id"
        )
    """

    property_api_name: str = Field(
        ...,
        description="apiName of the property used as primary key.",
        alias="propertyApiName",
    )

    backing_column: Optional[str] = Field(
        default=None,
        description="Column name in backing dataset that maps to this key.",
        alias="backingColumn",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        result: dict[str, Any] = {"propertyApiName": self.property_api_name}
        if self.backing_column:
            result["backingColumn"] = self.backing_column
        return result

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "PrimaryKeyDefinition":
        """Create from Foundry JSON format."""
        return cls(
            property_api_name=data["propertyApiName"],
            backing_column=data.get("backingColumn"),
        )


# Update forward references
StructField.model_rebuild()
DataTypeSpec.model_rebuild()
