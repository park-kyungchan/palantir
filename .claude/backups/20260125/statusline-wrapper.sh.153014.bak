#!/bin/bash
# =============================================================================
# Statusline Wrapper with Pastel Background Colors (High Contrast)
# =============================================================================
# Applies pastel backgrounds to ALL text with dark foreground for readability
# Extended: Task API integration + Session Mode on Line 3

# Pastel background colors (softer, lighter pastels)
BG_LINE1="\033[48;2;200;220;255m"     # Light Periwinkle Blue
BG_LINE2="\033[48;2;220;200;255m"     # Light Lavender
BG_LINE3="\033[48;2;200;255;220m"     # Light Mint Green

# Dark text color for high contrast (override all colors)
FG_DARK="\033[38;2;30;30;50m"         # Dark navy text
BOLD="\033[1m"
RESET="\033[0m"

# Read stdin (JSON from Claude Code)
INPUT=$(cat)

# =============================================================================
# Task API Integration
# =============================================================================
get_current_task() {
    local task_dir="$HOME/.claude/tasks"
    local current_task=""
    local task_count=0
    local in_progress_count=0
    local completed_count=0

    # Find the most recent task list directory with actual task files
    if [ -d "$task_dir" ]; then
        # Get most recently modified task list that contains JSON files
        local latest_list=""
        for dir in $(ls -td "$task_dir"/*/ 2>/dev/null); do
            if ls "${dir%/}"/*.json &>/dev/null; then
                latest_list="$dir"
                break
            fi
        done

        if [ -n "$latest_list" ] && [ -d "$latest_list" ]; then
            # Count tasks by status using jq if available, fallback to grep
            if command -v jq &>/dev/null; then
                for f in "${latest_list%/}"/*.json; do
                    [ -f "$f" ] || continue
                    ((task_count++))
                    local status=$(jq -r '.status // "unknown"' "$f" 2>/dev/null)
                    local subject=$(jq -r '.subject // "Unknown"' "$f" 2>/dev/null)

                    case "$status" in
                        "in_progress")
                            ((in_progress_count++))
                            # Get the first in_progress task as current
                            [ -z "$current_task" ] && current_task="$subject"
                            ;;
                        "completed")
                            ((completed_count++))
                            ;;
                    esac
                done
            else
                # Fallback: grep-based parsing
                for f in "${latest_list%/}"/*.json; do
                    [ -f "$f" ] || continue
                    ((task_count++))
                    if grep -q '"status".*"in_progress"' "$f" 2>/dev/null; then
                        ((in_progress_count++))
                        if [ -z "$current_task" ]; then
                            current_task=$(grep -o '"subject"[[:space:]]*:[[:space:]]*"[^"]*"' "$f" | head -1 | sed 's/.*"\([^"]*\)"$/\1/')
                        fi
                    elif grep -q '"status".*"completed"' "$f" 2>/dev/null; then
                        ((completed_count++))
                    fi
                done
            fi
        fi
    fi

    # Build task status string
    if [ $task_count -gt 0 ]; then
        local pending_count=$((task_count - in_progress_count - completed_count))

        if [ -n "$current_task" ]; then
            # Truncate long task names
            [ ${#current_task} -gt 30 ] && current_task="${current_task:0:27}..."
            echo "ðŸ“‹ ${current_task} â”‚ âœ“${completed_count}/${task_count}"
        else
            echo "ðŸ“‹ Tasks: âœ“${completed_count} â³${pending_count} /${task_count}"
        fi
    else
        echo "ðŸ“‹ No tasks"
    fi
}

# Extract session_mode from statusline output (will be moved to Line 3)
extract_session_mode() {
    local output="$1"
    # Look for "Style:" pattern in the output
    echo "$output" | grep -o 'Style:[^â”‚]*' | head -1 | sed 's/[[:space:]]*$//'
}

# =============================================================================
# Main Processing
# =============================================================================

# Run original statusline and capture output
OUTPUT=$(echo "$INPUT" | ~/.claude/statusline/statusline.sh 2>/dev/null)

# Get Task API status (always fetch, even if statusline fails)
TASK_STATUS=$(get_current_task)

# If statusline fails, show only Task info on Line 3
if [ -z "$OUTPUT" ]; then
    if [ -n "$TASK_STATUS" ]; then
        echo -e "${BG_LINE3}${FG_DARK}${BOLD} ${TASK_STATUS} ${RESET}"
    fi
    exit 0
fi

# Strip all existing ANSI color codes
strip_colors() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

# Extract session_mode from Line 2 (will move to Line 3)
SESSION_MODE=$(extract_session_mode "$OUTPUT")

# Get Task API status
TASK_STATUS=$(get_current_task)

# Build Line 3 content
LINE3_CONTENT=""
if [ -n "$TASK_STATUS" ]; then
    LINE3_CONTENT="$TASK_STATUS"
fi
if [ -n "$SESSION_MODE" ]; then
    [ -n "$LINE3_CONTENT" ] && LINE3_CONTENT="$LINE3_CONTENT â”‚ "
    LINE3_CONTENT="${LINE3_CONTENT}${SESSION_MODE}"
fi

# Process and output lines with pastel backgrounds
LINE_NUM=0
while IFS= read -r line; do
    ((LINE_NUM++))

    # Skip empty lines
    if [ -z "$line" ]; then
        continue
    fi

    # Strip existing colors for clean background application
    CLEAN_LINE=$(strip_colors "$line")

    # Remove session_mode from Line 2 (moved to Line 3)
    if [ $LINE_NUM -eq 2 ]; then
        CLEAN_LINE=$(echo "$CLEAN_LINE" | sed 's/ â”‚ Style:[^â”‚]*$//' | sed 's/Style:[^â”‚]* â”‚ //' | sed 's/Style:[^â”‚]*$//')
        CLEAN_LINE=$(echo "$CLEAN_LINE" | sed 's/[[:space:]]*$//')
    fi

    # Apply different background per line with dark text
    case $LINE_NUM in
        1) echo -e "${BG_LINE1}${FG_DARK}${BOLD} ${CLEAN_LINE} ${RESET}" ;;
        2) echo -e "${BG_LINE2}${FG_DARK}${BOLD} ${CLEAN_LINE} ${RESET}" ;;
    esac
done <<< "$OUTPUT"

# Output Line 3 with Task status + Session Mode
if [ -n "$LINE3_CONTENT" ]; then
    echo -e "${BG_LINE3}${FG_DARK}${BOLD} ${LINE3_CONTENT} ${RESET}"
fi
