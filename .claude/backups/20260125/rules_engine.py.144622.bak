"""
Rules Engine Type Definitions for Ontology.

Foundry Rules enables users to actively manage complex business logic with a
point-and-click, low-code interface. Users can create rules and apply them to
datasets, objects, and time series for alert generation, data categorization,
and task generation.

This module provides:
    - LogicBoardType: Types of logic transformation boards
    - InputSourceType: Input source types (DATASET, OBJECT)
    - JoinType: Join operation types
    - ActionRuleType: 10 types of object/link operation rules
    - Logic Board models: FilterBoard, AggregationBoard, JoinBoard, etc.
    - FoundryRule: Main rule definition model

Reference: docs/Ontology.md Section 9
"""

from __future__ import annotations

from enum import Enum
from typing import Any, Optional, Union

from pydantic import BaseModel, ConfigDict, Field


class InputSourceType(str, Enum):
    """
    Input source type for Foundry Rules.

    - DATASET: Input from a Foundry dataset (backing table)
    - OBJECT: Input from an ObjectType
    """

    DATASET = "DATASET"
    OBJECT = "OBJECT"


class LogicBoardType(str, Enum):
    """
    Types of logic transformation boards in Foundry Rules.

    - FILTER_BOARD: Filter rows based on conditions
    - AGGREGATION_BOARD: Group and aggregate data
    - JOIN_BOARD: Join with another dataset/object
    - EXPRESSION_BOARD: Create computed columns
    - WINDOW_BOARD: Apply window functions
    - SELECT_COLUMNS_BOARD: Select specific columns
    - UNION_BOARD: Union multiple datasets
    """

    FILTER_BOARD = "FILTER_BOARD"
    AGGREGATION_BOARD = "AGGREGATION_BOARD"
    JOIN_BOARD = "JOIN_BOARD"
    EXPRESSION_BOARD = "EXPRESSION_BOARD"
    WINDOW_BOARD = "WINDOW_BOARD"
    SELECT_COLUMNS_BOARD = "SELECT_COLUMNS_BOARD"
    UNION_BOARD = "UNION_BOARD"


class JoinType(str, Enum):
    """
    Join operation types for Join Board.

    Standard SQL join types:
    - INNER: Return only matching rows from both sides
    - LEFT: Return all rows from left, nulls for non-matching right
    - RIGHT: Return all rows from right, nulls for non-matching left
    - FULL: Return all rows from both sides, nulls for non-matching
    """

    INNER = "INNER"
    LEFT = "LEFT"
    RIGHT = "RIGHT"
    FULL = "FULL"


class ActionRuleType(str, Enum):
    """
    Action rule types for object/link operations.

    10 types organized by category:

    Object Operations:
    - CREATE_OBJECT: Create new object instance
    - MODIFY_OBJECT: Modify existing object
    - CREATE_OR_MODIFY_OBJECT: Upsert operation
    - DELETE_OBJECT: Delete object

    Link Operations:
    - CREATE_LINK: Create link (many-to-many only)
    - DELETE_LINK: Delete link

    Function Rule:
    - FUNCTION_RULE: Execute custom function (exclusive - no other rules)

    Interface Operations:
    - CREATE_OBJECT_OF_INTERFACE: Create object implementing interface
    - MODIFY_OBJECT_OF_INTERFACE: Modify object implementing interface
    - DELETE_OBJECT_OF_INTERFACE: Delete object implementing interface

    Note: FUNCTION_RULE is exclusive - if used, no other action rules can be defined.
    """

    # Object operations
    CREATE_OBJECT = "createObject"
    MODIFY_OBJECT = "modifyObject"
    CREATE_OR_MODIFY_OBJECT = "createOrModifyObject"
    DELETE_OBJECT = "deleteObject"

    # Link operations
    CREATE_LINK = "createLink"
    DELETE_LINK = "deleteLink"

    # Function rule (exclusive)
    FUNCTION_RULE = "functionRule"

    # Interface operations
    CREATE_OBJECT_OF_INTERFACE = "createObjectOfInterface"
    MODIFY_OBJECT_OF_INTERFACE = "modifyObjectOfInterface"
    DELETE_OBJECT_OF_INTERFACE = "deleteObjectOfInterface"

    @property
    def is_exclusive(self) -> bool:
        """Return True if this rule type is exclusive (cannot combine with others)."""
        return self == ActionRuleType.FUNCTION_RULE

    @property
    def affects_objects(self) -> bool:
        """Return True if this rule type affects objects."""
        return self in {
            ActionRuleType.CREATE_OBJECT,
            ActionRuleType.MODIFY_OBJECT,
            ActionRuleType.CREATE_OR_MODIFY_OBJECT,
            ActionRuleType.DELETE_OBJECT,
            ActionRuleType.CREATE_OBJECT_OF_INTERFACE,
            ActionRuleType.MODIFY_OBJECT_OF_INTERFACE,
            ActionRuleType.DELETE_OBJECT_OF_INTERFACE,
        }

    @property
    def affects_links(self) -> bool:
        """Return True if this rule type affects links."""
        return self in {ActionRuleType.CREATE_LINK, ActionRuleType.DELETE_LINK}


class RuleInputSource(BaseModel):
    """
    Input source definition for a Foundry Rule.

    - source_type: DATASET or OBJECT
    - source: RID for dataset or apiName for ObjectType
    - alias: Optional alias name for this input

    Examples:
        # Dataset input
        RuleInputSource(
            source_type=InputSourceType.DATASET,
            source="ri.foundry.main.dataset.abc123"
        )

        # Object input
        RuleInputSource(
            source_type=InputSourceType.OBJECT,
            source="Employee"
        )
    """

    source_type: InputSourceType = Field(
        ...,
        description="Type of input source: DATASET or OBJECT.",
        alias="type",
    )

    source: str = Field(
        ...,
        description="Dataset RID or ObjectType apiName.",
    )

    alias: Optional[str] = Field(
        default=None,
        description="Optional alias name for this input source.",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        result: dict[str, Any] = {
            "type": self.source_type.value,
            "source": self.source,
        }

        if self.alias:
            result["alias"] = self.alias

        return result

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "RuleInputSource":
        """Create from Foundry JSON format."""
        return cls(
            source_type=InputSourceType(data["type"]),
            source=data["source"],
            alias=data.get("alias"),
        )


class FilterBoard(BaseModel):
    """
    Filter board for row-level filtering.

    Applies filter conditions to rows, similar to SQL WHERE clause.

    - conditions: List of filter conditions (can reference imported FilterCondition)
    """

    conditions: list[dict[str, Any]] = Field(
        ...,
        description="List of filter conditions to apply.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {"conditions": self.conditions}


class AggregationBoard(BaseModel):
    """
    Aggregation board for grouping and aggregating data.

    Similar to SQL GROUP BY with aggregate functions.

    - group_by: List of columns to group by
    - aggregations: Map of output column name to aggregate function

    Example:
        AggregationBoard(
            group_by=["department"],
            aggregations={
                "total_employees": "COUNT(*)",
                "avg_salary": "AVG(salary)"
            }
        )
    """

    group_by: list[str] = Field(
        ...,
        description="List of columns to group by.",
        alias="groupBy",
    )

    aggregations: dict[str, str] = Field(
        ...,
        description="Map of output column name to aggregate function expression.",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {
            "groupBy": self.group_by,
            "aggregations": self.aggregations,
        }

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "AggregationBoard":
        """Create from Foundry JSON format."""
        return cls(
            group_by=data["groupBy"],
            aggregations=data["aggregations"],
        )


class JoinBoard(BaseModel):
    """
    Join board for joining with another dataset/object.

    Similar to SQL JOIN operations.

    - join_type: INNER, LEFT, RIGHT, or FULL
    - join_dataset: RID of dataset to join with
    - join_conditions: List of join condition expressions

    Example:
        JoinBoard(
            join_type=JoinType.INNER,
            join_dataset="ri.foundry.main.dataset.xyz789",
            join_conditions=["left.employeeId = right.managerId"]
        )
    """

    join_type: JoinType = Field(
        ...,
        description="Type of join: INNER, LEFT, RIGHT, or FULL.",
        alias="joinType",
    )

    join_dataset: str = Field(
        ...,
        description="RID of the dataset to join with.",
        alias="joinDataset",
    )

    join_conditions: list[str] = Field(
        ...,
        description="List of join condition expressions.",
        alias="joinConditions",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {
            "joinType": self.join_type.value,
            "joinDataset": self.join_dataset,
            "joinConditions": self.join_conditions,
        }

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "JoinBoard":
        """Create from Foundry JSON format."""
        return cls(
            join_type=JoinType(data["joinType"]),
            join_dataset=data["joinDataset"],
            join_conditions=data["joinConditions"],
        )


class ExpressionBoard(BaseModel):
    """
    Expression board for creating computed columns.

    Similar to SQL SELECT with computed expressions.

    - expressions: Map of output column name to expression

    Example:
        ExpressionBoard(
            expressions={
                "full_name": "firstName || ' ' || lastName",
                "annual_salary": "salary * 12"
            }
        )
    """

    expressions: dict[str, str] = Field(
        ...,
        description="Map of output column name to expression string.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {"expressions": self.expressions}


class WindowBoard(BaseModel):
    """
    Window board for applying window functions.

    Similar to SQL window functions (OVER clause).

    - partition_by: List of columns to partition by
    - order_by: List of columns to order by within partitions
    - window_function: Window function expression

    Example:
        WindowBoard(
            partition_by=["department"],
            order_by=["salary DESC"],
            window_function="ROW_NUMBER()"
        )
    """

    partition_by: list[str] = Field(
        ...,
        description="List of columns to partition by.",
        alias="partitionBy",
    )

    order_by: list[str] = Field(
        ...,
        description="List of columns to order by within partitions.",
        alias="orderBy",
    )

    window_function: str = Field(
        ...,
        description="Window function expression to apply.",
        alias="windowFunction",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {
            "partitionBy": self.partition_by,
            "orderBy": self.order_by,
            "windowFunction": self.window_function,
        }

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "WindowBoard":
        """Create from Foundry JSON format."""
        return cls(
            partition_by=data["partitionBy"],
            order_by=data["orderBy"],
            window_function=data["windowFunction"],
        )


class SelectColumnsBoard(BaseModel):
    """
    Select columns board for column projection.

    Similar to SQL SELECT with specific columns.

    - columns: List of column names to select

    Example:
        SelectColumnsBoard(
            columns=["employeeId", "employeeName", "department"]
        )
    """

    columns: list[str] = Field(
        ...,
        description="List of column names to select.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {"columns": self.columns}


class UnionBoard(BaseModel):
    """
    Union board for combining multiple datasets.

    Similar to SQL UNION.

    - datasets: List of dataset RIDs to union

    Example:
        UnionBoard(
            datasets=[
                "ri.foundry.main.dataset.abc123",
                "ri.foundry.main.dataset.def456"
            ]
        )
    """

    datasets: list[str] = Field(
        ...,
        description="List of dataset RIDs to union.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {"datasets": self.datasets}


class RuleOutput(BaseModel):
    """
    Output configuration for a Foundry Rule.

    - dataset: RID of output dataset
    - schema: List of column definitions for output schema

    Example:
        RuleOutput(
            dataset="ri.foundry.main.dataset.output123",
            schema=[
                {"name": "employeeId", "type": "STRING"},
                {"name": "alertMessage", "type": "STRING"}
            ]
        )
    """

    dataset: str = Field(
        ...,
        description="RID of the output dataset.",
    )

    schema: list[dict[str, Any]] = Field(
        ...,
        description="List of column definitions for output schema.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        return {
            "dataset": self.dataset,
            "schema": self.schema,
        }

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "RuleOutput":
        """Create from Foundry JSON format."""
        return cls(
            dataset=data["dataset"],
            schema=data["schema"],
        )


class FoundryRule(BaseModel):
    """
    Complete Foundry Rule definition.

    Foundry Rules enable users to manage complex business logic with a
    point-and-click interface for alert generation, data categorization,
    and task generation.

    - inputs: List of input sources (datasets or objects)
    - logic_blocks: List of logic transformation boards
    - output: Output dataset and schema configuration
    - action_rules: Optional list of action rules to execute

    Example:
        FoundryRule(
            inputs=[
                RuleInputSource(
                    source_type=InputSourceType.OBJECT,
                    source="Employee"
                )
            ],
            logic_blocks=[
                {
                    "type": "FILTER_BOARD",
                    "board": FilterBoard(
                        conditions=[{"field": "salary", "op": "gt", "value": 100000}]
                    )
                },
                {
                    "type": "AGGREGATION_BOARD",
                    "board": AggregationBoard(
                        group_by=["department"],
                        aggregations={"count": "COUNT(*)"}
                    )
                }
            ],
            output=RuleOutput(
                dataset="ri.foundry.main.dataset.high_earners",
                schema=[{"name": "department", "type": "STRING"}]
            )
        )
    """

    inputs: list[RuleInputSource] = Field(
        ...,
        description="List of input sources (datasets or objects).",
    )

    logic_blocks: list[dict[str, Any]] = Field(
        ...,
        description="List of logic transformation boards.",
        alias="logicBlocks",
    )

    output: RuleOutput = Field(
        ...,
        description="Output dataset and schema configuration.",
    )

    action_rules: Optional[list[ActionRuleType]] = Field(
        default=None,
        description="Optional list of action rules to execute.",
        alias="actionRules",
    )

    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )

    def to_foundry_dict(self) -> dict[str, Any]:
        """Export to Foundry-compatible dictionary format."""
        result: dict[str, Any] = {
            "inputs": [inp.to_foundry_dict() for inp in self.inputs],
            "logicBlocks": self.logic_blocks,
            "output": self.output.to_foundry_dict(),
        }

        if self.action_rules:
            result["actionRules"] = [rule.value for rule in self.action_rules]

        return result

    @classmethod
    def from_foundry_dict(cls, data: dict[str, Any]) -> "FoundryRule":
        """Create from Foundry JSON format."""
        inputs = [RuleInputSource.from_foundry_dict(inp) for inp in data["inputs"]]

        action_rules = None
        if data.get("actionRules"):
            action_rules = [ActionRuleType(rule) for rule in data["actionRules"]]

        return cls(
            inputs=inputs,
            logic_blocks=data["logicBlocks"],
            output=RuleOutput.from_foundry_dict(data["output"]),
            action_rules=action_rules,
        )
