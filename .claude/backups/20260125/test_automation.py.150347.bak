"""
Unit tests for Automation type definitions.

Tests cover:
- TIME-based automation conditions (cron schedules)
- OBJECT_SET-based automation conditions (data triggers)
- Action, Notification, and Fallback effects
- Execution settings and retry policies
- Serialization (to_foundry_dict / from_foundry_dict roundtrip)
"""

import pytest
from pydantic import ValidationError

from ontology_definition.types import (
    Automation,
    AutomationCondition,
    AutomationEffect,
    TimeCondition,
    ObjectSetCondition,
    ActionEffect,
    NotificationEffect,
    FallbackEffect,
    RetryPolicy,
    ExecutionSettings,
)
from ontology_definition.core.enums import (
    AutomationConditionType,
    TimeConditionMode,
    ObjectSetConditionTrigger,
    AutomationEffectType,
    ActionExecutionMode,
    RetryPolicyType,
    NotificationEffectType,
    EvaluationLatency,
    AutomationStatus,
)


class TestTimeCondition:
    """Tests for TIME-based automation conditions."""

    def test_daily_schedule(self):
        """Daily schedule at specific time."""
        condition = TimeCondition(
            mode=TimeConditionMode.DAILY,
            hour=9,
            minute=0,
            timezone="America/New_York"
        )
        assert condition.mode == TimeConditionMode.DAILY
        assert condition.hour == 9

    def test_cron_schedule(self):
        """Custom cron expression schedule."""
        condition = TimeCondition(
            mode=TimeConditionMode.CRON,
            cron_expression="0 9 * * MON-FRI"
        )
        assert condition.mode == TimeConditionMode.CRON
        assert condition.cron_expression == "0 9 * * MON-FRI"

    def test_cron_mode_requires_expression(self):
        """CRON mode requires cron_expression."""
        with pytest.raises(ValidationError) as exc_info:
            TimeCondition(mode=TimeConditionMode.CRON)
        assert "cron_expression" in str(exc_info.value)

    def test_weekly_with_days(self):
        """Weekly schedule with specific days."""
        condition = TimeCondition(
            mode=TimeConditionMode.WEEKLY,
            days_of_week=[1, 3, 5],  # Mon, Wed, Fri
            hour=8,
            minute=30
        )
        assert condition.mode == TimeConditionMode.WEEKLY
        assert condition.days_of_week == [1, 3, 5]


class TestObjectSetCondition:
    """Tests for OBJECT_SET-based automation conditions."""

    def test_objects_added_trigger(self):
        """Trigger when objects are added."""
        condition = ObjectSetCondition(
            trigger=ObjectSetConditionTrigger.OBJECTS_ADDED,
            object_set_ref="CriticalTickets"
        )
        assert condition.trigger == ObjectSetConditionTrigger.OBJECTS_ADDED

    def test_threshold_crossed_with_metric(self):
        """Trigger when metric crosses threshold."""
        condition = ObjectSetCondition(
            trigger=ObjectSetConditionTrigger.THRESHOLD_CROSSED,
            object_set_ref="OpenOrders",
            metric_property="orderCount",
            threshold_value=1000,
            threshold_operator="GREATER_THAN"
        )
        assert condition.trigger == ObjectSetConditionTrigger.THRESHOLD_CROSSED
        assert condition.threshold_value == 1000


class TestAutomationCondition:
    """Tests for AutomationCondition - unified condition wrapper."""

    def test_time_condition(self):
        """TIME condition type."""
        condition = AutomationCondition(
            type=AutomationConditionType.TIME,
            time_condition=TimeCondition(
                mode=TimeConditionMode.DAILY,
                hour=9,
                minute=0
            )
        )
        assert condition.type == AutomationConditionType.TIME

    def test_object_set_condition(self):
        """OBJECT_SET condition type."""
        condition = AutomationCondition(
            type=AutomationConditionType.OBJECT_SET,
            object_set_condition=ObjectSetCondition(
                trigger=ObjectSetConditionTrigger.OBJECTS_ADDED,
                object_set_ref="CriticalTickets"
            )
        )
        assert condition.type == AutomationConditionType.OBJECT_SET


class TestActionEffect:
    """Tests for ACTION effect type."""

    def test_basic_action_effect(self):
        """Basic action effect configuration."""
        effect = ActionEffect(
            action_api_name="escalateTicket",
            execution_mode=ActionExecutionMode.ONCE_EACH_GROUP
        )
        assert effect.action_api_name == "escalateTicket"
        assert effect.execution_mode == ActionExecutionMode.ONCE_EACH_GROUP

    def test_action_effect_with_parameter_mappings(self):
        """Action effect with parameter mappings."""
        effect = ActionEffect(
            action_api_name="notifyUser",
            parameter_mappings={"userId": "object.ownerId", "message": "static:Alert!"}
        )
        assert effect.parameter_mappings["userId"] == "object.ownerId"


class TestNotificationEffect:
    """Tests for NOTIFICATION effect type."""

    def test_platform_notification(self):
        """In-platform notification."""
        effect = NotificationEffect(
            notification_type=NotificationEffectType.PLATFORM,
            recipients=["user:admin@example.com"],
            message_template="New critical ticket: {{object.title}}"
        )
        assert effect.notification_type == NotificationEffectType.PLATFORM

    def test_email_notification(self):
        """Email notification."""
        effect = NotificationEffect(
            notification_type=NotificationEffectType.EMAIL,
            recipients=["admin@example.com"],
            message_template="Alert: {{object.title}}",
            subject_template="[ALERT] New ticket"
        )
        assert effect.notification_type == NotificationEffectType.EMAIL


class TestRetryPolicy:
    """Tests for RetryPolicy."""

    def test_constant_retry(self):
        """Constant delay retry policy."""
        policy = RetryPolicy(
            policy_type=RetryPolicyType.CONSTANT,
            max_retries=3,
            delay_seconds=60
        )
        assert policy.policy_type == RetryPolicyType.CONSTANT
        assert policy.max_retries == 3

    def test_exponential_retry(self):
        """Exponential backoff retry policy."""
        policy = RetryPolicy(
            policy_type=RetryPolicyType.EXPONENTIAL,
            max_retries=5,
            initial_delay_seconds=10,
            max_delay_seconds=300
        )
        assert policy.policy_type == RetryPolicyType.EXPONENTIAL


class TestAutomationEffect:
    """Tests for AutomationEffect - unified effect wrapper."""

    def test_action_effect(self):
        """ACTION effect type."""
        effect = AutomationEffect(
            type=AutomationEffectType.ACTION,
            action_effect=ActionEffect(
                action_api_name="escalateTicket",
                execution_mode=ActionExecutionMode.ONCE_ALL
            )
        )
        assert effect.type == AutomationEffectType.ACTION

    def test_fallback_effect(self):
        """FALLBACK effect type."""
        effect = AutomationEffect(
            type=AutomationEffectType.FALLBACK,
            fallback_effect=FallbackEffect(
                notification=NotificationEffect(
                    notification_type=NotificationEffectType.EMAIL,
                    recipients=["oncall@example.com"],
                    message_template="Automation failed: {{error}}"
                )
            )
        )
        assert effect.type == AutomationEffectType.FALLBACK


class TestExecutionSettings:
    """Tests for ExecutionSettings."""

    def test_basic_settings(self):
        """Basic execution settings."""
        settings = ExecutionSettings(
            evaluation_latency=EvaluationLatency.LIVE,
            batch_size=100,
            max_concurrent=5
        )
        assert settings.evaluation_latency == EvaluationLatency.LIVE
        assert settings.batch_size == 100

    def test_settings_with_retry(self):
        """Execution settings with retry policy."""
        settings = ExecutionSettings(
            evaluation_latency=EvaluationLatency.SCHEDULED,
            retry_policy=RetryPolicy(
                policy_type=RetryPolicyType.CONSTANT,
                max_retries=3,
                delay_seconds=60
            )
        )
        assert settings.retry_policy is not None


class TestAutomation:
    """Tests for Automation - the main automation definition."""

    def test_time_based_automation(self):
        """TIME-based automation (daily report)."""
        automation = Automation(
            api_name="dailySalesReport",
            display_name="Daily Sales Report",
            enabled=True,
            condition=AutomationCondition(
                type=AutomationConditionType.TIME,
                time_condition=TimeCondition(
                    mode=TimeConditionMode.CRON,
                    cron_expression="0 9 * * *",
                    timezone="America/New_York"
                )
            ),
            effects=[
                AutomationEffect(
                    type=AutomationEffectType.ACTION,
                    action_effect=ActionEffect(
                        action_api_name="generateSalesReport",
                        execution_mode=ActionExecutionMode.ONCE_ALL
                    )
                )
            ],
            execution_settings=ExecutionSettings(
                evaluation_latency=EvaluationLatency.SCHEDULED
            ),
            status=AutomationStatus.ACTIVE
        )
        assert automation.api_name == "dailySalesReport"
        assert automation.condition.type == AutomationConditionType.TIME
        assert len(automation.effects) == 1

    def test_object_set_based_automation(self):
        """OBJECT_SET-based automation (critical ticket escalation)."""
        automation = Automation(
            api_name="criticalTicketEscalation",
            display_name="Critical Ticket Escalation",
            enabled=True,
            condition=AutomationCondition(
                type=AutomationConditionType.OBJECT_SET,
                object_set_condition=ObjectSetCondition(
                    trigger=ObjectSetConditionTrigger.OBJECTS_ADDED,
                    object_set_ref="CriticalTickets"
                )
            ),
            effects=[
                AutomationEffect(
                    type=AutomationEffectType.ACTION,
                    action_effect=ActionEffect(
                        action_api_name="escalateTicket",
                        execution_mode=ActionExecutionMode.ONCE_EACH_GROUP
                    )
                ),
                AutomationEffect(
                    type=AutomationEffectType.NOTIFICATION,
                    notification_effect=NotificationEffect(
                        notification_type=NotificationEffectType.PLATFORM,
                        recipients=["group:oncall"],
                        message_template="Critical ticket: {{object.title}}"
                    )
                )
            ],
            execution_settings=ExecutionSettings(
                evaluation_latency=EvaluationLatency.LIVE
            ),
            status=AutomationStatus.ACTIVE
        )
        assert automation.api_name == "criticalTicketEscalation"
        assert len(automation.effects) == 2

    def test_automation_requires_effects(self):
        """Automation must have at least one effect."""
        with pytest.raises(ValidationError) as exc_info:
            Automation(
                api_name="noEffects",
                display_name="No Effects",
                condition=AutomationCondition(
                    type=AutomationConditionType.TIME,
                    time_condition=TimeCondition(mode=TimeConditionMode.DAILY, hour=9)
                ),
                effects=[],  # Empty!
                execution_settings=ExecutionSettings(
                    evaluation_latency=EvaluationLatency.SCHEDULED
                ),
                status=AutomationStatus.ACTIVE
            )
        assert "min_length" in str(exc_info.value).lower() or "effects" in str(exc_info.value).lower()

    def test_to_foundry_dict_roundtrip(self):
        """to_foundry_dict / from_foundry_dict should roundtrip."""
        original = Automation(
            api_name="dailySalesReport",
            display_name="Daily Sales Report",
            description="Generates daily sales report at 9 AM EST.",
            enabled=True,
            condition=AutomationCondition(
                type=AutomationConditionType.TIME,
                time_condition=TimeCondition(
                    mode=TimeConditionMode.CRON,
                    cron_expression="0 9 * * *",
                    timezone="America/New_York"
                )
            ),
            effects=[
                AutomationEffect(
                    type=AutomationEffectType.ACTION,
                    action_effect=ActionEffect(
                        action_api_name="generateSalesReport",
                        execution_mode=ActionExecutionMode.ONCE_ALL
                    )
                )
            ],
            execution_settings=ExecutionSettings(
                evaluation_latency=EvaluationLatency.SCHEDULED,
                retry_policy=RetryPolicy(
                    policy_type=RetryPolicyType.CONSTANT,
                    max_retries=3,
                    delay_seconds=60
                )
            ),
            status=AutomationStatus.ACTIVE
        )

        dict_form = original.to_foundry_dict()
        restored = Automation.from_foundry_dict(dict_form)

        assert restored.api_name == original.api_name
        assert restored.display_name == original.display_name
        assert restored.description == original.description
        assert restored.enabled == original.enabled
        assert restored.condition.type == original.condition.type
        assert len(restored.effects) == len(original.effects)
        assert restored.status == original.status

    def test_disabled_automation(self):
        """Disabled automation."""
        automation = Automation(
            api_name="disabledAutomation",
            display_name="Disabled Automation",
            enabled=False,
            condition=AutomationCondition(
                type=AutomationConditionType.TIME,
                time_condition=TimeCondition(mode=TimeConditionMode.DAILY, hour=9)
            ),
            effects=[
                AutomationEffect(
                    type=AutomationEffectType.ACTION,
                    action_effect=ActionEffect(action_api_name="someAction")
                )
            ],
            execution_settings=ExecutionSettings(
                evaluation_latency=EvaluationLatency.SCHEDULED
            ),
            status=AutomationStatus.PAUSED
        )
        assert automation.enabled is False
        assert automation.status == AutomationStatus.PAUSED
