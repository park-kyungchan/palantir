#!/bin/bash
# =============================================================================
# Statusline Wrapper with Pastel Background Colors (High Contrast)
# =============================================================================
# Applies pastel backgrounds to ALL text with dark foreground for readability
# Extended: Task API integration + Session Mode on Line 3

# Pastel background colors (softer, lighter pastels)
BG_LINE1="\033[48;2;200;220;255m"     # Light Periwinkle Blue
BG_LINE2="\033[48;2;220;200;255m"     # Light Lavender
BG_LINE3="\033[48;2;200;255;220m"     # Light Mint Green

# Dark text color for high contrast (override all colors)
FG_DARK="\033[38;2;30;30;50m"         # Dark navy text
BOLD="\033[1m"
RESET="\033[0m"

# Read stdin (JSON from Claude Code)
INPUT=$(cat)

# =============================================================================
# Task API Integration
# =============================================================================
get_current_task() {
    local task_base="$HOME/.claude/tasks"
    local task_list_id="${CLAUDE_CODE_TASK_LIST_ID:-}"
    local task_count=0
    local in_progress_count=0
    local completed_count=0

    # If no task list ID, return empty
    if [ -z "$task_list_id" ]; then
        echo ""
        return
    fi

    local task_dir="${task_base}/${task_list_id}"

    # Check if task directory exists and has JSON files
    if [ -d "$task_dir" ] && ls "${task_dir}"/*.json &>/dev/null; then
        # Count tasks by status using jq if available, fallback to grep
        if command -v jq &>/dev/null; then
            for f in "${task_dir}"/*.json; do
                [ -f "$f" ] || continue
                ((task_count++))
                local status=$(jq -r '.status // "unknown"' "$f" 2>/dev/null)

                case "$status" in
                    "in_progress") ((in_progress_count++)) ;;
                    "completed") ((completed_count++)) ;;
                esac
            done
        else
            # Fallback: grep-based parsing
            for f in "${task_dir}"/*.json; do
                [ -f "$f" ] || continue
                ((task_count++))
                if grep -q '"status".*"in_progress"' "$f" 2>/dev/null; then
                    ((in_progress_count++))
                elif grep -q '"status".*"completed"' "$f" 2>/dev/null; then
                    ((completed_count++))
                fi
            done
        fi
    fi

    # Build task status string with Task List ID
    if [ $task_count -gt 0 ]; then
        echo "ðŸ“‹ ${task_list_id} â”‚ âœ“${completed_count}/${task_count}"
    else
        echo "ðŸ“‹ ${task_list_id}"
    fi
}

# Extract session_mode directly from Claude Code JSON input
extract_session_mode() {
    local json_input="$1"
    local style_name=""

    # Extract output_style.name from JSON using jq or grep
    if command -v jq &>/dev/null; then
        style_name=$(echo "$json_input" | jq -r '.output_style.name // empty' 2>/dev/null)
    else
        # Fallback: grep-based extraction
        style_name=$(echo "$json_input" | grep -o '"output_style"[^}]*"name"[[:space:]]*:[[:space:]]*"[^"]*"' | grep -o '"name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"\([^"]*\)"$/\1/')
    fi

    # Return formatted style if found
    if [ -n "$style_name" ] && [ "$style_name" != "null" ]; then
        # Add emoji based on style
        case "$style_name" in
            "learning") echo "ðŸŽ“ Style: $style_name" ;;
            "explanatory") echo "ðŸ“š Style: $style_name" ;;
            "default") echo "Style: $style_name" ;;
            *) echo "âœ¨ Style: $style_name" ;;
        esac
    fi
}

# =============================================================================
# Main Processing
# =============================================================================

# Run original statusline and capture output
OUTPUT=$(echo "$INPUT" | ~/.claude/statusline/statusline.sh 2>/dev/null)

# Get Task API status (always fetch, even if statusline fails)
TASK_STATUS=$(get_current_task)

# If statusline fails, show only Task info on Line 3
if [ -z "$OUTPUT" ]; then
    if [ -n "$TASK_STATUS" ]; then
        echo -e "${BG_LINE3}${FG_DARK}${BOLD} ${TASK_STATUS} ${RESET}"
    fi
    exit 0
fi

# Strip all existing ANSI color codes
strip_colors() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

# Extract session_mode directly from Claude Code JSON input
SESSION_MODE=$(extract_session_mode "$INPUT")

# Build Line 3 content (TASK_STATUS already fetched above)
LINE3_CONTENT=""
if [ -n "$TASK_STATUS" ]; then
    LINE3_CONTENT="$TASK_STATUS"
fi
if [ -n "$SESSION_MODE" ]; then
    [ -n "$LINE3_CONTENT" ] && LINE3_CONTENT="$LINE3_CONTENT â”‚ "
    LINE3_CONTENT="${LINE3_CONTENT}${SESSION_MODE}"
fi

# Process and output lines with pastel backgrounds
LINE_NUM=0
while IFS= read -r line; do
    ((LINE_NUM++))

    # Skip empty lines
    if [ -z "$line" ]; then
        continue
    fi

    # Strip existing colors for clean background application
    CLEAN_LINE=$(strip_colors "$line")

    # Remove session_mode from Line 2 (moved to Line 3)
    if [ $LINE_NUM -eq 2 ]; then
        CLEAN_LINE=$(echo "$CLEAN_LINE" | sed 's/ â”‚ Style:[^â”‚]*$//' | sed 's/Style:[^â”‚]* â”‚ //' | sed 's/Style:[^â”‚]*$//')
        CLEAN_LINE=$(echo "$CLEAN_LINE" | sed 's/[[:space:]]*$//')
    fi

    # Apply different background per line with dark text
    case $LINE_NUM in
        1) echo -e "${BG_LINE1}${FG_DARK}${BOLD} ${CLEAN_LINE} ${RESET}" ;;
        2) echo -e "${BG_LINE2}${FG_DARK}${BOLD} ${CLEAN_LINE} ${RESET}" ;;
    esac
done <<< "$OUTPUT"

# Output Line 3 with Task status + Session Mode
if [ -n "$LINE3_CONTENT" ]; then
    echo -e "${BG_LINE3}${FG_DARK}${BOLD} ${LINE3_CONTENT} ${RESET}"
fi
