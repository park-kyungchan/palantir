{
  "version": "3.0.0",
  "tier": 2,
  "description": "Detailed comparison frameworks, validation rules, and authoritative sources for UCLP",
  "comparison_framework": {
    "categories": [
      {
        "category": "Language Design",
        "axes": [
          {"axis": "typing_discipline", "description": "Static vs dynamic, strong vs weak"},
          {"axis": "type_inference", "description": "How much type information is inferred"},
          {"axis": "null_safety", "description": "How the language handles null/nil/none"},
          {"axis": "paradigm_support", "description": "OOP, functional, procedural, protocol-oriented"},
          {"axis": "compilation_model", "description": "Compiled, interpreted, transpiled, JIT"}
        ]
      },
      {
        "category": "Error Handling",
        "axes": [
          {"axis": "primary_mechanism", "description": "Exceptions, error values, Result types"},
          {"axis": "panic_abort", "description": "How unrecoverable errors are handled"},
          {"axis": "error_composition", "description": "Wrapping, chaining, context propagation"},
          {"axis": "recovery_support", "description": "Can you catch panics/errors and recover?"},
          {"axis": "compile_time_checking", "description": "Does compiler enforce error handling?"}
        ]
      },
      {
        "category": "Memory Management",
        "axes": [
          {"axis": "allocation_strategy", "description": "Stack vs heap, automatic vs manual"},
          {"axis": "deallocation_mechanism", "description": "GC, ARC, manual, RAII"},
          {"axis": "determinism", "description": "Predictable deallocation timing?"},
          {"axis": "cycle_handling", "description": "How reference cycles are detected/broken"},
          {"axis": "performance_overhead", "description": "Runtime cost of memory management"}
        ]
      },
      {
        "category": "Concurrency",
        "axes": [
          {"axis": "concurrency_model", "description": "Threads, coroutines, actors, CSP, event loop"},
          {"axis": "race_detection", "description": "Compile-time or runtime race detection"},
          {"axis": "synchronization_primitives", "description": "Mutexes, channels, atomics, actors"},
          {"axis": "async_syntax", "description": "async/await, callbacks, goroutines"},
          {"axis": "parallelism_support", "description": "True parallel execution on multi-core?"},
          {"axis": "structured_concurrency", "description": "Lifecycle management of concurrent tasks"}
        ]
      },
      {
        "category": "Type System",
        "axes": [
          {"axis": "generics_support", "description": "Parametric polymorphism, type parameters"},
          {"axis": "variance", "description": "Covariance, contravariance, invariance"},
          {"axis": "structural_vs_nominal", "description": "Type compatibility rules"},
          {"axis": "union_intersection_types", "description": "Composing types algebraically"},
          {"axis": "dependent_types", "description": "Types depending on values"},
          {"axis": "higher_kinded_types", "description": "Types that take type constructors"}
        ]
      },
      {
        "category": "Functional Programming",
        "axes": [
          {"axis": "first_class_functions", "description": "Functions as values"},
          {"axis": "closures", "description": "Capturing lexical scope"},
          {"axis": "immutability_support", "description": "Immutable data structures, const/let"},
          {"axis": "pattern_matching", "description": "Switch/match with destructuring"},
          {"axis": "lazy_evaluation", "description": "Deferred computation"},
          {"axis": "tail_call_optimization", "description": "Compiler optimizes recursive calls"}
        ]
      },
      {
        "category": "Ecosystem",
        "axes": [
          {"axis": "package_manager", "description": "go mod, pip, SPM, npm/yarn/pnpm"},
          {"axis": "standard_library_size", "description": "Batteries included vs minimal"},
          {"axis": "interop_with_c", "description": "FFI, cgo, bridging headers, N-API"},
          {"axis": "community_size", "description": "Number of developers, packages"},
          {"axis": "learning_curve", "description": "Time to productivity for beginners"},
          {"axis": "tooling_quality", "description": "IDE support, linters, formatters"}
        ]
      },
      {
        "category": "Performance",
        "axes": [
          {"axis": "execution_speed", "description": "Benchmarked runtime performance"},
          {"axis": "startup_time", "description": "Time from launch to ready"},
          {"axis": "memory_footprint", "description": "RAM usage for equivalent programs"},
          {"axis": "binary_size", "description": "Compiled output size"},
          {"axis": "compilation_speed", "description": "Time to build large projects"},
          {"axis": "optimization_level", "description": "Compiler optimization sophistication"}
        ]
      }
    ],
    "total_axes": 44
  },
  "example_explanations": {
    "variable_declaration": {
      "concept": "How to declare and initialize variables in each language",
      "go": {
        "syntax": "var name string = \"value\" OR name := \"value\"",
        "philosophy": "Explicit var for package-level, := for concise local declarations. Zero values guarantee initialization.",
        "code": "var count int // zero value: 0\nname := \"Go\" // type inferred"
      },
      "python": {
        "syntax": "name = \"value\"",
        "philosophy": "Dynamic typing, no declaration keyword. Assignment creates variable.",
        "code": "count = 0\nname = \"Python\" # type inferred dynamically"
      },
      "swift": {
        "syntax": "var name: String = \"value\" OR let name = \"value\"",
        "philosophy": "var for mutable, let for immutable. Type inference preferred. Compiler enforces immutability.",
        "code": "var count: Int = 0\nlet name = \"Swift\" // type inferred, immutable"
      },
      "typescript": {
        "syntax": "let name: string = \"value\" OR const name = \"value\"",
        "philosophy": "let for block-scoped mutable, const for immutable. Type annotations optional.",
        "code": "let count: number = 0;\nconst name = \"TypeScript\"; // type inferred"
      }
    },
    "error_handling": {
      "concept": "How to handle and propagate errors",
      "go": {
        "syntax": "if err != nil { return err }",
        "philosophy": "Errors are values. Explicit checking at every call site. No hidden control flow.",
        "code": "result, err := doSomething()\nif err != nil {\n  return fmt.Errorf(\"failed: %w\", err)\n}\n// use result"
      },
      "python": {
        "syntax": "try: ... except Exception as e: ...",
        "philosophy": "EAFP (Easier to Ask Forgiveness than Permission). Exceptions for error handling.",
        "code": "try:\n    result = do_something()\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    raise"
      },
      "swift": {
        "syntax": "do { try ... } catch { ... } OR guard let result = try? ... else { ... }",
        "philosophy": "Typed errors with throws. Optional try? for ignoring errors, try! for force-unwrap.",
        "code": "do {\n    let result = try doSomething()\n} catch let error as MyError {\n    print(\"Error: \\(error)\")\n}"
      },
      "typescript": {
        "syntax": "try { ... } catch (e) { ... }",
        "philosophy": "JavaScript-style exceptions. No typed catch (until ES2019 optional catch binding).",
        "code": "try {\n    const result = doSomething();\n} catch (e) {\n    console.error('Error:', e);\n    throw e;\n}"
      }
    },
    "concurrency": {
      "concept": "How to write concurrent/asynchronous code",
      "go": {
        "syntax": "go funcName() + channels",
        "philosophy": "Built-in goroutines (cheap threads) and channels (communication). CSP model.",
        "code": "ch := make(chan int)\ngo func() {\n  ch <- 42\n}()\nresult := <-ch"
      },
      "python": {
        "syntax": "async def / await + asyncio",
        "philosophy": "async/await for cooperative multitasking. GIL limits true parallelism.",
        "code": "async def fetch():\n    result = await async_operation()\n    return result\n\nawait fetch()"
      },
      "swift": {
        "syntax": "async/await + actors (Swift 5.5+)",
        "philosophy": "Structured concurrency with tasks. Actors for safe shared state.",
        "code": "func fetch() async throws -> Data {\n    return try await URLSession.shared.data(from: url).0\n}\nlet data = try await fetch()"
      },
      "typescript": {
        "syntax": "async/await + Promises",
        "philosophy": "Event loop concurrency. Single-threaded, non-blocking I/O.",
        "code": "async function fetch(): Promise<Data> {\n    const response = await fetch(url);\n    return response.json();\n}\nconst data = await fetch();"
      }
    }
  },
  "depth_selection": {
    "beginner": {
      "description": "New to programming or the concept",
      "include": ["Basic syntax", "Simple examples", "Common use cases", "Minimal jargon"],
      "exclude": ["Edge cases", "Performance tuning", "Advanced patterns"],
      "example_prompt": "Explain variable declaration like I'm learning to code for the first time."
    },
    "intermediate": {
      "description": "Comfortable with basics, ready for nuance",
      "include": ["Idiomatic patterns", "Common pitfalls", "Comparison across languages", "When to use each approach"],
      "exclude": ["Compiler internals", "Obscure edge cases"],
      "example_prompt": "Compare error handling in Go vs Python for a web API project."
    },
    "advanced": {
      "description": "Expert-level understanding",
      "include": ["Performance implications", "Memory layout", "Compiler behavior", "Edge cases", "Design tradeoffs"],
      "exclude": ["Beginner explanations"],
      "example_prompt": "Discuss zero-cost abstractions in Swift vs Go generics implementation."
    }
  },
  "code_validation": {
    "description": "Rules for ensuring generated code examples are correct",
    "modes": {
      "light": {
        "description": "Quick validation for simple examples",
        "checks": ["Syntax correctness", "Type consistency", "Runnable in isolation"]
      },
      "strict": {
        "description": "Comprehensive validation for production code",
        "checks": ["Syntax correctness", "Type consistency", "Runnable in isolation", "Idiomatic patterns", "Error handling", "Edge cases covered", "Performance considerations"]
      }
    },
    "per_language": {
      "go": {
        "light": ["gofmt checks", "go vet basics"],
        "strict": ["golangci-lint", "staticcheck", "errcheck", "ineffassign"]
      },
      "python": {
        "light": ["pyflakes", "basic type hints"],
        "strict": ["mypy --strict", "pylint", "black formatting", "isort"]
      },
      "swift": {
        "light": ["Swift compiler warnings"],
        "strict": ["SwiftLint", "strict concurrency checking", "no force unwraps"]
      },
      "typescript": {
        "light": ["tsc --noEmit"],
        "strict": ["tsc --strict", "eslint recommended", "prettier formatting"]
      }
    }
  },
  "authoritative_sources": {
    "go": [
      {"title": "Effective Go", "url": "https://go.dev/doc/effective_go"},
      {"title": "Go Language Specification", "url": "https://go.dev/ref/spec"},
      {"title": "Go Blog", "url": "https://go.dev/blog"},
      {"title": "Go Code Review Comments", "url": "https://github.com/golang/go/wiki/CodeReviewComments"}
    ],
    "python": [
      {"title": "Python Tutorial", "url": "https://docs.python.org/3/tutorial/"},
      {"title": "PEP 8 Style Guide", "url": "https://peps.python.org/pep-0008/"},
      {"title": "The Zen of Python (PEP 20)", "url": "https://peps.python.org/pep-0020/"},
      {"title": "Python Language Reference", "url": "https://docs.python.org/3/reference/"}
    ],
    "swift": [
      {"title": "The Swift Programming Language", "url": "https://docs.swift.org/swift-book/"},
      {"title": "Swift API Design Guidelines", "url": "https://swift.org/documentation/api-design-guidelines/"},
      {"title": "Swift Evolution", "url": "https://github.com/apple/swift-evolution"},
      {"title": "WWDC Videos", "url": "https://developer.apple.com/videos/"}
    ],
    "typescript": [
      {"title": "TypeScript Handbook", "url": "https://www.typescriptlang.org/docs/handbook/intro.html"},
      {"title": "TypeScript Deep Dive", "url": "https://basarat.gitbook.io/typescript/"},
      {"title": "Do's and Don'ts", "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html"},
      {"title": "Release Notes", "url": "https://www.typescriptlang.org/docs/handbook/release-notes/overview.html"}
    ]
  },
  "response_templates": {
    "comparison_matrix_example": {
      "description": "Template for generating comparison tables",
      "format": "markdown_table",
      "columns": ["Aspect", "Go", "Python", "Swift", "TypeScript"],
      "example_rows": [
        {"aspect": "Error Handling", "go": "Explicit (err != nil)", "python": "Exceptions", "swift": "throws/Result", "typescript": "try/catch"},
        {"aspect": "Type Safety", "go": "Static", "python": "Dynamic + hints", "swift": "Static", "typescript": "Static (opt-in)"},
        {"aspect": "Memory Mgmt", "go": "GC", "python": "Ref counting + GC", "swift": "ARC", "typescript": "JS runtime GC"}
      ]
    },
    "tradeoff_structure": {
      "description": "Template for discussing language tradeoffs",
      "format": "bulleted_list",
      "sections": ["Pros", "Cons", "When to choose"],
      "example": {
        "language": "Go",
        "pros": ["Fast compilation", "Built-in concurrency", "Simple language"],
        "cons": ["Verbose error handling", "Limited generics (pre-1.18)", "No exceptions"],
        "when_to_choose": "Building networked services, microservices, CLI tools"
      }
    }
  },
  "meta": {
    "last_updated": "2025-12-01",
    "total_comparison_axes": 44,
    "comparison_categories": 8,
    "example_concepts": 3,
    "validation_modes": 2,
    "authoritative_sources_per_language": 4,
    "file_purpose": "Comprehensive reference for deep UCLP comparisons"
  }
}
