"""
PDF Exporter for Stage H (Export).

Exports pipeline results to PDF format with support for:
- LaTeX compilation to PDF
- Direct PDF generation
- Multi-page documents
- Custom styling

Module Version: 1.0.0
"""

import io
import logging
import subprocess
import tempfile
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from ...schemas.export import (
    ExportFormat,
    ExportOptions,
    ExportSpec,
)
from .base import BaseExporter, ExporterConfig
from ..exceptions import ExporterError

logger = logging.getLogger(__name__)


# =============================================================================
# Configuration
# =============================================================================

@dataclass
class PDFExporterConfig(ExporterConfig):
    """Configuration for PDF exporter.

    Attributes:
        page_size: Paper size (letter, a4, etc.)
        margins: Page margins in inches
        font_size: Base font size
        latex_engine: LaTeX engine to use
        keep_tex: Keep intermediate .tex file
        timeout: Compilation timeout in seconds
    """
    page_size: str = "letter"
    margins: Dict[str, float] = field(default_factory=lambda: {
        "top": 1.0,
        "bottom": 1.0,
        "left": 1.0,
        "right": 1.0,
    })
    font_size: int = 11
    latex_engine: str = "pdflatex"
    keep_tex: bool = False
    timeout: int = 60


# =============================================================================
# PDF Exporter
# =============================================================================

class PDFExporter(BaseExporter[PDFExporterConfig]):
    """Export pipeline results to PDF format.

    Generates PDF documents from LaTeX content using pdflatex or
    other LaTeX engines. Falls back to basic PDF generation if
    LaTeX is not available.

    Usage:
        exporter = PDFExporter()
        spec = exporter.export(regeneration_spec, options, "img_123")
    """

    def _default_config(self) -> PDFExporterConfig:
        """Create default configuration."""
        return PDFExporterConfig()

    @property
    def format(self) -> ExportFormat:
        """Get export format."""
        return ExportFormat.PDF

    @property
    def content_type(self) -> str:
        """Get MIME content type."""
        return "application/pdf"

    def _check_latex_available(self) -> bool:
        """Check if LaTeX engine is available.

        Returns:
            True if LaTeX is available
        """
        try:
            result = subprocess.run(
                [self.config.latex_engine, "--version"],
                capture_output=True,
                timeout=5,
            )
            return result.returncode == 0
        except Exception:
            return False

    def _generate_latex_document(
        self,
        data: Any,
        options: ExportOptions,
    ) -> str:
        """Generate complete LaTeX document from data.

        Args:
            data: Data to convert (RegenerationSpec or similar)
            options: Export options

        Returns:
            Complete LaTeX document string
        """
        lines = []

        # Document class
        lines.append(
            f"\\documentclass[{self.config.font_size}pt]{{{self.config.page_size}}}"
        )

        # Packages
        packages = options.latex_options.get("packages", [
            "amsmath",
            "amssymb",
            "geometry",
            "tikz",
        ])
        for pkg in packages:
            lines.append(f"\\usepackage{{{pkg}}}")

        # Geometry
        margins = self.config.margins
        lines.append(
            f"\\geometry{{top={margins['top']}in, bottom={margins['bottom']}in, "
            f"left={margins['left']}in, right={margins['right']}in}}"
        )

        # Begin document
        lines.append("")
        lines.append("\\begin{document}")

        # Title if available
        if hasattr(data, "image_id"):
            lines.append(f"\\section*{{Export: {data.image_id}}}")

        # Content
        latex_content = self._extract_latex_content(data)
        lines.append(latex_content)

        # Metadata
        if options.include_metadata:
            lines.append("")
            lines.append("\\vfill")
            lines.append("\\footnotesize")
            lines.append("\\noindent\\rule{\\textwidth}{0.4pt}")
            lines.append(
                "\\textit{Generated by MathpixPipeline v2.0}"
            )

        lines.append("\\end{document}")

        return "\n".join(lines)

    def _extract_latex_content(self, data: Any) -> str:
        """Extract LaTeX content from data object.

        Args:
            data: Data object (RegenerationSpec, etc.)

        Returns:
            LaTeX content string
        """
        content_parts = []

        # From RegenerationSpec
        if hasattr(data, "outputs"):
            for output in data.outputs:
                if hasattr(output, "format") and output.format.value == "latex":
                    content_parts.append(output.content)

        # From SemanticGraph nodes
        if hasattr(data, "nodes"):
            equations = []
            for node in data.nodes:
                if hasattr(node, "properties") and hasattr(node.properties, "latex"):
                    if node.properties.latex:
                        equations.append(node.properties.latex)
            if equations:
                content_parts.append("\\begin{align*}")
                content_parts.append(" \\\\\n".join(f"  {eq}" for eq in equations))
                content_parts.append("\\end{align*}")

        # Fallback
        if not content_parts:
            if hasattr(data, "get_latex"):
                content_parts.append(data.get_latex() or "% No LaTeX content")
            else:
                content_parts.append("% No LaTeX content available")

        return "\n\n".join(content_parts)

    def _compile_latex(self, tex_content: str) -> bytes:
        """Compile LaTeX to PDF.

        Args:
            tex_content: LaTeX document content

        Returns:
            PDF bytes

        Raises:
            ExporterError: If compilation fails
        """
        with tempfile.TemporaryDirectory() as tmpdir:
            tmppath = Path(tmpdir)
            tex_file = tmppath / "document.tex"
            pdf_file = tmppath / "document.pdf"

            # Write LaTeX file
            tex_file.write_text(tex_content, encoding="utf-8")

            # Compile (run twice for references)
            for _ in range(2):
                try:
                    result = subprocess.run(
                        [
                            self.config.latex_engine,
                            "-interaction=nonstopmode",
                            "-output-directory", str(tmppath),
                            str(tex_file),
                        ],
                        capture_output=True,
                        timeout=self.config.timeout,
                        cwd=tmppath,
                    )
                except subprocess.TimeoutExpired:
                    raise ExporterError(
                        f"LaTeX compilation timed out after {self.config.timeout}s",
                        exporter_type="pdf",
                    )

            if not pdf_file.exists():
                # Try to extract error from log
                log_file = tmppath / "document.log"
                error_msg = "Unknown LaTeX error"
                if log_file.exists():
                    log_content = log_file.read_text()
                    # Find first error
                    for line in log_content.split("\n"):
                        if line.startswith("!"):
                            error_msg = line
                            break

                raise ExporterError(
                    f"LaTeX compilation failed: {error_msg}",
                    exporter_type="pdf",
                )

            return pdf_file.read_bytes()

    def _generate_basic_pdf(self, data: Any) -> bytes:
        """Generate basic PDF without LaTeX.

        Uses reportlab if available, otherwise creates minimal PDF.

        Args:
            data: Data to export

        Returns:
            PDF bytes
        """
        try:
            from reportlab.lib.pagesizes import letter
            from reportlab.pdfgen import canvas

            buffer = io.BytesIO()
            c = canvas.Canvas(buffer, pagesize=letter)
            width, height = letter

            # Title
            c.setFont("Helvetica-Bold", 16)
            if hasattr(data, "image_id"):
                c.drawString(72, height - 72, f"Export: {data.image_id}")
            else:
                c.drawString(72, height - 72, "Pipeline Export")

            # Content
            c.setFont("Helvetica", 11)
            y = height - 120

            content = self._extract_latex_content(data)
            # Simple text rendering (LaTeX won't render properly)
            for line in content.split("\n")[:50]:
                if y < 72:
                    c.showPage()
                    c.setFont("Helvetica", 11)
                    y = height - 72
                # Remove LaTeX commands for plain text
                plain = line.replace("\\", "").replace("{", "").replace("}", "")
                c.drawString(72, y, plain[:80])
                y -= 14

            c.save()
            return buffer.getvalue()

        except ImportError:
            # Minimal PDF without reportlab
            return self._create_minimal_pdf(data)

    def _create_minimal_pdf(self, data: Any) -> bytes:
        """Create minimal valid PDF without external libraries.

        Args:
            data: Data object

        Returns:
            Minimal PDF bytes
        """
        # Create a minimal valid PDF
        title = getattr(data, "image_id", "Export")
        content = f"Pipeline Export: {title}\n\nNote: Full PDF generation requires LaTeX or reportlab."

        pdf_content = f"""%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>
endobj
4 0 obj
<< /Length {len(content) + 50} >>
stream
BT
/F1 12 Tf
72 720 Td
({content}) Tj
ET
endstream
endobj
5 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 6
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000266 00000 n
trailer
<< /Size 6 /Root 1 0 R >>
startxref
{350 + len(content)}
%%EOF"""

        return pdf_content.encode("latin-1")

    def export_to_bytes(
        self,
        data: Any,
        options: ExportOptions,
    ) -> bytes:
        """Export data to PDF bytes.

        Args:
            data: Data to export
            options: Export options

        Returns:
            PDF content as bytes
        """
        if self._check_latex_available():
            tex_content = self._generate_latex_document(data, options)
            return self._compile_latex(tex_content)
        else:
            logger.warning("LaTeX not available, using basic PDF generation")
            return self._generate_basic_pdf(data)

    def export(
        self,
        data: Any,
        options: ExportOptions,
        image_id: str,
    ) -> ExportSpec:
        """Export data to PDF file.

        Args:
            data: Data to export
            options: Export options
            image_id: Source image identifier

        Returns:
            ExportSpec with export metadata
        """
        start_time = time.time()

        # Generate identifiers
        export_id = self._generate_export_id(image_id)
        filename = self._generate_filename(image_id, options)
        filepath = self.config.output_dir / filename

        try:
            # Generate PDF
            pdf_bytes = self.export_to_bytes(data, options)
            checksum = self._calculate_checksum(pdf_bytes)
            file_size = self._write_file(pdf_bytes, filepath)

            # Count pages (rough estimate)
            page_count = max(1, pdf_bytes.count(b"/Type /Page"))

            processing_time = (time.time() - start_time) * 1000

            self._stats["exports_completed"] += 1

            logger.info(
                f"PDF export completed: {filepath}, "
                f"size={file_size} bytes, pages~{page_count}, "
                f"time={processing_time:.1f}ms"
            )

            spec = self._create_export_spec(
                export_id=export_id,
                image_id=image_id,
                filepath=filepath,
                file_size=file_size,
                checksum=checksum,
                processing_time_ms=processing_time,
            )
            spec.page_count = page_count
            return spec

        except Exception as e:
            self._stats["exports_failed"] += 1
            raise ExporterError(
                f"PDF export failed: {e}",
                exporter_type="pdf",
            )


# =============================================================================
# Export
# =============================================================================

__all__ = [
    "PDFExporter",
    "PDFExporterConfig",
]
