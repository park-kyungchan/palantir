{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "version": "3.0.0",
  "description": "UCLP Tier-2 Reference: Comparison framework, example explanations, authoritative sources, and validation rules. For querying by concept_id and language.",

  "comparison_framework": {
    "categories": {
      "basics": {
        "required_axes": ["syntax", "type_system", "default_value", "mutability", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "variable_declaration", "name": "Variable Declaration", "prerequisites": [], "related": ["type_system", "mutability"]},
          {"id": "type_system", "name": "Type System", "prerequisites": ["variable_declaration"], "related": ["type_inference", "generics"]},
          {"id": "operators", "name": "Operators", "prerequisites": ["variable_declaration"], "related": ["operator_overloading"]},
          {"id": "control_flow", "name": "Control Flow", "prerequisites": ["variable_declaration", "operators"], "related": ["pattern_matching"]}
        ]
      },
      "functions": {
        "required_axes": ["definition_syntax", "parameter_handling", "return_mechanism", "invocation_syntax", "first_class_support", "closures", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "function_definition", "name": "Function Definition", "prerequisites": ["variable_declaration"], "related": ["parameters", "return_values"]},
          {"id": "parameters", "name": "Parameters & Arguments", "prerequisites": ["function_definition"], "related": ["default_values", "variadic"]},
          {"id": "closures", "name": "Closures", "prerequisites": ["function_definition"], "related": ["capturing", "escaping"]},
          {"id": "methods", "name": "Methods", "prerequisites": ["function_definition", "structs_classes"], "related": ["receivers", "self"]}
        ]
      },
      "data_structures": {
        "required_axes": ["creation_syntax", "access_pattern", "mutation_operation", "iteration_method", "immutability_support", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "arrays_slices", "name": "Arrays & Slices/Lists", "prerequisites": ["variable_declaration"], "related": ["iteration", "comprehensions"]},
          {"id": "maps_dicts", "name": "Maps & Dictionaries", "prerequisites": ["variable_declaration"], "related": ["hashing", "iteration"]},
          {"id": "structs_classes", "name": "Structs & Classes", "prerequisites": ["variable_declaration", "function_definition"], "related": ["methods", "encapsulation"]},
          {"id": "enums", "name": "Enumerations", "prerequisites": ["variable_declaration"], "related": ["pattern_matching", "associated_values"]}
        ]
      },
      "error_handling": {
        "required_axes": ["error_model", "propagation_mechanism", "recovery_pattern", "panic_vs_exception", "result_type", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "error_types", "name": "Error Types", "prerequisites": ["function_definition"], "related": ["error_propagation"]},
          {"id": "error_propagation", "name": "Error Propagation", "prerequisites": ["error_types"], "related": ["error_wrapping"]},
          {"id": "optionals_nullability", "name": "Optionals & Nullability", "prerequisites": ["type_system"], "related": ["unwrapping", "nil_coalescing"]}
        ]
      },
      "concurrency": {
        "required_axes": ["concurrency_model", "scheduling_mechanism", "synchronization_primitive", "shared_state_approach", "async_syntax", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "async_await", "name": "Async/Await", "prerequisites": ["function_definition", "closures"], "related": ["goroutines", "tasks"]},
          {"id": "channels_streams", "name": "Channels & Streams", "prerequisites": ["async_await"], "related": ["csp_model"]},
          {"id": "synchronization", "name": "Synchronization", "prerequisites": ["async_await"], "related": ["locks", "actors"]}
        ]
      },
      "abstraction": {
        "required_axes": ["definition_syntax", "implementation_mechanism", "inheritance_model", "polymorphism_type", "extension_method", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "interfaces_protocols", "name": "Interfaces & Protocols", "prerequisites": ["methods"], "related": ["composition", "duck_typing"]},
          {"id": "generics", "name": "Generics", "prerequisites": ["type_system", "interfaces_protocols"], "related": ["type_constraints"]},
          {"id": "extensions", "name": "Extensions", "prerequisites": ["structs_classes", "interfaces_protocols"], "related": ["protocol_extensions"]}
        ]
      },
      "modules": {
        "required_axes": ["module_structure", "visibility_control", "dependency_syntax", "namespace_mechanism", "import_export", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "packages", "name": "Packages & Modules", "prerequisites": [], "related": ["imports", "visibility"]},
          {"id": "visibility", "name": "Visibility & Access Control", "prerequisites": ["packages"], "related": ["encapsulation"]},
          {"id": "dependencies", "name": "Dependency Management", "prerequisites": ["packages"], "related": ["versioning"]}
        ]
      },
      "memory": {
        "required_axes": ["allocation_mechanism", "deallocation_strategy", "ownership_model", "lifecycle_management", "gc_vs_manual", "philosophy", "tradeoff"],
        "concepts": [
          {"id": "value_vs_reference", "name": "Value vs Reference Types", "prerequisites": ["structs_classes"], "related": ["copying", "mutation"]},
          {"id": "garbage_collection", "name": "Garbage Collection & ARC", "prerequisites": ["value_vs_reference"], "related": ["memory_leaks", "retain_cycles"]}
        ]
      }
    },

    "axes": {
      "syntax": {"name": "Syntax", "description": "Concrete notation differences"},
      "semantics": {"name": "Semantics", "description": "Runtime behavior differences"},
      "philosophy": {"name": "Philosophy", "description": "Design values and principles"},
      "performance": {"name": "Performance", "description": "Speed, memory, compilation characteristics"},
      "idiom": {"name": "Idiom", "description": "Community-preferred patterns"},
      "type_system": {"name": "Type System Implications", "description": "How the type system affects this feature"},
      "mutability": {"name": "Mutability", "description": "Data mutability/immutability handling model"},
      "default_value": {"name": "Default Value", "description": "How default values are handled for variables/fields"},
      "definition_syntax": {"name": "Definition Syntax", "description": "Syntax for defining functions/methods/types"},
      "parameter_handling": {"name": "Parameter Handling", "description": "How parameters are passed and processed"},
      "return_mechanism": {"name": "Return Mechanism", "description": "How return values are handled"},
      "invocation_syntax": {"name": "Invocation Syntax", "description": "Syntax for calling functions/methods"},
      "first_class_support": {"name": "First-Class Support", "description": "Whether functions are first-class citizens"},
      "closures": {"name": "Closures", "description": "Closure capture semantics and syntax"},
      "creation_syntax": {"name": "Creation Syntax", "description": "Syntax for creating data structures"},
      "access_pattern": {"name": "Access Pattern", "description": "How elements are accessed in data structures"},
      "mutation_operation": {"name": "Mutation Operation", "description": "How data structures are modified"},
      "iteration_method": {"name": "Iteration Method", "description": "How to iterate over data structures"},
      "immutability_support": {"name": "Immutability Support", "description": "Built-in support for immutable data structures"},
      "error_model": {"name": "Error Model", "description": "Language-level error handling model"},
      "propagation_mechanism": {"name": "Propagation Mechanism", "description": "How errors propagate to callers"},
      "recovery_pattern": {"name": "Recovery Pattern", "description": "Patterns for error recovery"},
      "panic_vs_exception": {"name": "Panic vs Exception", "description": "Handling unrecoverable errors"},
      "result_type": {"name": "Result Type", "description": "Explicit error type usage (Result/Option)"},
      "concurrency_model": {"name": "Concurrency Model", "description": "Fundamental concurrency paradigm"},
      "scheduling_mechanism": {"name": "Scheduling Mechanism", "description": "How concurrent tasks are scheduled"},
      "synchronization_primitive": {"name": "Synchronization Primitive", "description": "Primitives for coordinating concurrent access"},
      "shared_state_approach": {"name": "Shared State Approach", "description": "How shared state is handled in concurrent code"},
      "async_syntax": {"name": "Async Syntax", "description": "Syntax for asynchronous operations"},
      "implementation_mechanism": {"name": "Implementation Mechanism", "description": "How abstractions are implemented"},
      "inheritance_model": {"name": "Inheritance Model", "description": "Approach to inheritance and code reuse"},
      "polymorphism_type": {"name": "Polymorphism Type", "description": "Type of polymorphism supported"},
      "extension_method": {"name": "Extension Method", "description": "Ability to extend existing types"},
      "module_structure": {"name": "Module Structure", "description": "How code is organized into modules"},
      "visibility_control": {"name": "Visibility Control", "description": "Access modifiers and encapsulation"},
      "dependency_syntax": {"name": "Dependency Syntax", "description": "Syntax for declaring dependencies"},
      "namespace_mechanism": {"name": "Namespace Mechanism", "description": "How namespaces prevent naming conflicts"},
      "import_export": {"name": "Import/Export", "description": "How symbols are imported and exported"},
      "allocation_mechanism": {"name": "Allocation Mechanism", "description": "How memory is allocated"},
      "deallocation_strategy": {"name": "Deallocation Strategy", "description": "How memory is freed"},
      "ownership_model": {"name": "Ownership Model", "description": "Who owns allocated memory"},
      "lifecycle_management": {"name": "Lifecycle Management", "description": "How object lifecycles are managed"},
      "gc_vs_manual": {"name": "GC vs Manual", "description": "Memory management approach"},
      "tradeoff": {"name": "Tradeoff", "description": "Pros and cons analysis of the design"}
    },

    "idiomatic_patterns": {
      "go": [
        {"pattern": "if err != nil", "usage": "Error checking at every call site", "philosophy": "Explicit error handling"},
        {"pattern": "defer cleanup()", "usage": "Resource cleanup", "philosophy": "Cleanup close to acquisition"},
        {"pattern": "go func() {}()", "usage": "Spawning concurrent work", "philosophy": "Lightweight concurrency"},
        {"pattern": "ch := make(chan T)", "usage": "Channel communication", "philosophy": "Share by communicating"},
        {"pattern": "type T struct { OtherType }", "usage": "Embedding for composition", "philosophy": "Composition over inheritance"}
      ],
      "python": [
        {"pattern": "[x for x in items]", "usage": "List transformation", "philosophy": "Readable, declarative"},
        {"pattern": "with resource:", "usage": "Context management", "philosophy": "Automatic cleanup"},
        {"pattern": "try: ... except:", "usage": "Error handling", "philosophy": "EAFP"},
        {"pattern": "def func(*args, **kwargs):", "usage": "Flexible arguments", "philosophy": "Duck typing flexibility"},
        {"pattern": "if hasattr(obj, 'method'):", "usage": "Duck typing check", "philosophy": "Behavior over type"}
      ],
      "swift": [
        {"pattern": "guard let x = optional else { return }", "usage": "Early exit on nil", "philosophy": "Safety through unwrapping"},
        {"pattern": "if let x = optional { }", "usage": "Optional binding", "philosophy": "Explicit nil handling"},
        {"pattern": "array.map { $0.property }", "usage": "Functional transformation", "philosophy": "Expressive closures"},
        {"pattern": "protocol P { }; extension P { }", "usage": "Protocol with default implementation", "philosophy": "Protocol-oriented"},
        {"pattern": "async let x = fetch()", "usage": "Concurrent binding", "philosophy": "Structured concurrency"}
      ],
      "typescript": [
        {"pattern": "const x: Type = value", "usage": "Type annotation", "philosophy": "Explicit types for clarity"},
        {"pattern": "async function f(): Promise<T>", "usage": "Async function with typed return", "philosophy": "Type-safe async"},
        {"pattern": "type Result<T> = { ok: true; value: T } | { ok: false; error: Error }", "usage": "Discriminated union for Result", "philosophy": "Type-safe error handling"},
        {"pattern": "interface I { method(): void }", "usage": "Interface definition", "philosophy": "Structural contracts"},
        {"pattern": "arr.filter((x): x is T => ...)", "usage": "Type guard in filter", "philosophy": "Narrowing with predicates"}
      ]
    }
  },

  "examples": {
    "variable_declaration": {
      "go": {
        "syntax": "name := \"Alice\" (short) or var name string = \"Alice\" (explicit)",
        "design_decision": "':=' provides brevity for obvious types while 'var' signals intent for zero values. Two syntaxes serve different purposes.",
        "sources": [
          {"title": "A Tour of Go - Variables", "url": "https://go.dev/tour/basics/8", "type": "official_doc", "language": "go"},
          {"title": "Effective Go - Names", "url": "https://go.dev/doc/effective_go#names", "type": "official_doc", "language": "go"}
        ]
      },
      "python": {
        "syntax": "name = \"Alice\" (dynamic) or name: str = \"Alice\" (with hint)",
        "design_decision": "No type declaration required - duck typing prioritizes rapid development. Type hints (PEP 484) added later for tooling, not runtime.",
        "sources": [
          {"title": "PEP 484 - Type Hints", "url": "https://peps.python.org/pep-0484/", "type": "pep", "language": "python"}
        ]
      },
      "swift": {
        "syntax": "let name = \"Alice\" (immutable) or var count = 0 (mutable)",
        "design_decision": "Explicit let/var distinction makes mutability a conscious choice. Compiler warns if var never mutated.",
        "sources": [
          {"title": "The Swift Programming Language - Constants and Variables", "url": "https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html", "type": "official_doc", "language": "swift"}
        ]
      },
      "typescript": {
        "syntax": "const name: string = 'Alice' or let count: number = 0",
        "design_decision": "const/let from ES6 for mutability. Type annotations optional due to inference. Structural typing for flexibility.",
        "sources": [
          {"title": "TypeScript Handbook - Basic Types", "url": "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html", "type": "official_doc", "language": "typescript"}
        ]
      }
    },

    "error_handling": {
      "go": {
        "syntax": "result, err := func(); if err != nil { return err }",
        "design_decision": "Errors as values, not exceptions. Every error site is visible. 'Errors are values' philosophy.",
        "sources": [
          {"title": "Errors are values", "url": "https://go.dev/blog/errors-are-values", "type": "official_doc", "language": "go"},
          {"title": "Error handling and Go", "url": "https://go.dev/blog/error-handling-and-go", "type": "official_doc", "language": "go"}
        ]
      },
      "python": {
        "syntax": "try: result = func() except ValueError as e: handle(e)",
        "design_decision": "EAFP (Easier to Ask Forgiveness than Permission). Exceptions separate happy path from error handling.",
        "sources": [
          {"title": "Errors and Exceptions", "url": "https://docs.python.org/3/tutorial/errors.html", "type": "official_doc", "language": "python"}
        ]
      },
      "swift": {
        "syntax": "do { let data = try func() } catch FileError.notFound { handle() }",
        "design_decision": "'try' keyword makes throwing visible at call site. Compiler enforces handling.",
        "sources": [
          {"title": "Error Handling", "url": "https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html", "type": "official_doc", "language": "swift"},
          {"title": "SE-0413: Typed throws", "url": "https://github.com/apple/swift-evolution/blob/main/proposals/0413-typed-throws.md", "type": "swift_evolution", "language": "swift"}
        ]
      },
      "typescript": {
        "syntax": "try { const data = await func(); } catch (e) { if (e instanceof Error) handle(e); }",
        "design_decision": "JavaScript exceptions + union types for Result pattern. No checked exceptions, but discriminated unions enable type-safe error handling.",
        "sources": [
          {"title": "TypeScript Handbook - Narrowing", "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html", "type": "official_doc", "language": "typescript"}
        ]
      }
    },

    "concurrency": {
      "go": {
        "syntax": "go func() { ch <- result }()",
        "design_decision": "CSP model: goroutines + channels. 'Do not communicate by sharing memory; share memory by communicating.'",
        "sources": [
          {"title": "Go Concurrency Patterns", "url": "https://go.dev/blog/pipelines", "type": "official_doc", "language": "go"},
          {"title": "Share Memory By Communicating", "url": "https://go.dev/blog/codelab-share", "type": "official_doc", "language": "go"}
        ]
      },
      "python": {
        "syntax": "async def fetch(): data = await request()",
        "design_decision": "GIL limits threading, so asyncio provides cooperative concurrency for I/O. Multiprocessing for CPU-bound.",
        "sources": [
          {"title": "asyncio - Asynchronous I/O", "url": "https://docs.python.org/3/library/asyncio.html", "type": "official_doc", "language": "python"}
        ]
      },
      "swift": {
        "syntax": "Task { let data = await fetch() }",
        "design_decision": "Structured concurrency + actors. Compiler prevents data races.",
        "sources": [
          {"title": "Swift Concurrency", "url": "https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html", "type": "official_doc", "language": "swift"},
          {"title": "SE-0306: Actors", "url": "https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md", "type": "swift_evolution", "language": "swift"}
        ]
      },
      "typescript": {
        "syntax": "async function fetch(): Promise<Data> { return await api.get(); }",
        "design_decision": "async/await syntax sugar over Promises. Single-threaded event loop model inherited from JavaScript.",
        "sources": [
          {"title": "TypeScript 1.7 Release Notes", "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-7.html", "type": "official_doc", "language": "typescript"},
          {"title": "TypeScript 4.5 - Awaited Type", "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html", "type": "official_doc", "language": "typescript"}
        ]
      }
    }
  },

  "sources": {
    "go": [
      {"title": "Go Documentation", "url": "https://go.dev/doc/", "type": "official_doc", "language": "go"},
      {"title": "Go Blog", "url": "https://go.dev/blog/", "type": "official_doc", "language": "go"},
      {"title": "Go Talks", "url": "https://go.dev/talks/", "type": "creator_talk", "language": "go"},
      {"title": "Go Proposals", "url": "https://github.com/golang/proposal", "type": "go_proposal", "language": "go"}
    ],
    "python": [
      {"title": "Python Documentation", "url": "https://docs.python.org/", "type": "official_doc", "language": "python"},
      {"title": "Python Enhancement Proposals", "url": "https://peps.python.org/", "type": "pep", "language": "python"},
      {"title": "Real Python", "url": "https://realpython.com/", "type": "community", "language": "python"}
    ],
    "swift": [
      {"title": "Swift Documentation", "url": "https://docs.swift.org/", "type": "official_doc", "language": "swift"},
      {"title": "Swift Evolution", "url": "https://github.com/apple/swift-evolution", "type": "swift_evolution", "language": "swift"},
      {"title": "Apple Developer Documentation", "url": "https://developer.apple.com/documentation/swift", "type": "official_doc", "language": "swift"},
      {"title": "Swift by Sundell", "url": "https://www.swiftbysundell.com/", "type": "community", "language": "swift"}
    ],
    "typescript": [
      {"title": "TypeScript Documentation", "url": "https://www.typescriptlang.org/docs/", "type": "official_doc", "language": "typescript"},
      {"title": "TypeScript Design Goals", "url": "https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals", "type": "official_doc", "language": "typescript"},
      {"title": "TypeScript GitHub Wiki", "url": "https://github.com/microsoft/TypeScript/wiki", "type": "official_doc", "language": "typescript"},
      {"title": "TypeScript Deep Dive", "url": "https://basarat.gitbook.io/typescript/", "type": "community", "language": "typescript"}
    ]
  },

  "depth_selection": {
    "levels": ["beginner", "intermediate", "advanced"],
    "default_level": "beginner",
    "indicators": {
      "beginner": ["what is", "how to", "basic", "simple", "explain", "introduce", "tutorial", "getting started", "first time", "new to", "beginner", "learn", "understand"],
      "intermediate": ["why", "difference between", "compare", "best practice", "should i", "when to use", "pros and cons", "alternative", "versus", "better than", "recommend", "common patterns"],
      "advanced": ["internals", "implementation", "performance", "optimize", "under the hood", "deep dive", "architecture", "trade-offs", "edge cases", "scalability", "memory layout", "algorithm complexity", "bytecode", "compiler", "runtime"]
    },
    "level_response_differences": {
      "beginner": {
        "include": ["Simple problem statement", "Direct solution", "Line-by-line code explanation", "Visual analogies"],
        "exclude": ["Historical context (unless essential)", "Alternative solutions", "Performance considerations", "Edge cases"]
      },
      "intermediate": {
        "include": ["Problem context", "Primary solution + 1-2 alternatives", "When to use each", "Common pitfalls", "Basic trade-offs"],
        "exclude": ["Full historical evolution", "Deep implementation details", "Advanced edge cases"]
      },
      "advanced": {
        "include": ["Complete historical evolution", "All major alternatives", "Comprehensive trade-off analysis", "Implementation details", "Performance characteristics", "Edge cases", "Design decision rationale"],
        "exclude": ["Over-simplified analogies"]
      }
    }
  },

  "code_validation": {
    "default_mode": "light",
    "languages": {
      "go": {
        "light": {
          "command": "gofmt -e {file}",
          "fallback": "echo 'package main' | cat - {file} > /tmp/go_temp.go && gofmt -e /tmp/go_temp.go",
          "description": "Format check + syntax errors, no module required"
        },
        "strict": {
          "command": "go vet {file}",
          "fallback": "go build -o /dev/null {file}",
          "description": "Full static analysis, requires go.mod"
        }
      },
      "python": {
        "light": {
          "command": "python3 -m py_compile {file}",
          "fallback": "python3 -c \"import ast; ast.parse(open('{file}').read())\"",
          "description": "Syntax check only, no imports verified"
        },
        "strict": {
          "command": "pylint {file} --errors-only",
          "fallback": "pyflakes {file}",
          "description": "Error-level lint, requires pylint"
        }
      },
      "swift": {
        "light": {
          "command": "swiftc -parse {file}",
          "fallback": "echo 'import Foundation' | cat - {file} > /tmp/swift_temp.swift && swiftc -parse /tmp/swift_temp.swift",
          "description": "Parse only, no compilation"
        },
        "strict": {
          "command": "swiftc {file} -o /tmp/swift_out",
          "description": "Full compilation"
        }
      },
      "typescript": {
        "light": {
          "command": "npx tsc --noEmit --skipLibCheck {file}",
          "fallback": "npx tsc --noEmit --skipLibCheck --isolatedModules {file}",
          "description": "Type check without emit, skip lib for speed"
        },
        "strict": {
          "command": "npx tsc --noEmit --strict {file}",
          "fallback": "npx tsc --noEmit {file}",
          "description": "Full strict type checking"
        }
      }
    }
  }
}
